{"searchDocs":[{"title":"Applications documentation","type":0,"sectionRef":"#","url":"/dokku/docs/apps","content":"Applications documentation This section provides documentation for the applications of the SBA Framework.","keywords":"","version":"Next"},{"title":"Large Language Models Integration","type":0,"sectionRef":"#","url":"/dokku/docs/apps/llm-integration","content":"Large Language Models Integration The SBA Framework LLM Integration is available in a separate branch chatgpt-integration of the SBA respository. Please read the documentation of the Sinequa Retrieval Augmented Generation repository for guidance on how to set up the necessary plugins and configuration on your Sinequa server. This application is a customization of Vanilla Search in which a chat component (sq-chat from @sinequa/components/machine-learning) is used to interact with a Large-Language Model (LLM), such as GPT-4, the model powering the popular ChatGPT. This application is not meant to be used as-is, but rather as a set of examples to understand how to integrate a LLM in a Sinequa application for various use cases: Retrieval Augmented Generation (RAG): the LLM is fed with search results and prompted to generate an answer to the user query, along with a summary of the documents.Query intent detection: the LLM takes a search query from the user, rephrases it and automatically applies filters.Document summarization: the LLM summarizes a set of passages extracted from a document.Entity extraction: the LLM generates a graph of entities from a set of passages extracted from a document.Translation: the LLM translates a search query from one language to another.Personnalized greeting: the LLM generates a greeting message based on the user's information.","keywords":"","version":"Next"},{"title":"SBA Framework Documentation","type":0,"sectionRef":"#","url":"/dokku/docs","content":"","keywords":"","version":"Next"},{"title":"About Sinequa​","type":1,"pageTitle":"SBA Framework Documentation","url":"/dokku/docs#about-sinequa","content":" Sinequa brings the leading platform for intelligent search to large, global companies and government agencies. Our platform is deployed on four continents, and the company has offices in New York, Paris, San Francisco, London, and Frankfurt.  Sinequa excels at searching and extracting information from unstructured data (like text in natural language from documents and files). However, Sinequa can be readily process large amounts of both structured and unstructured data, enabling many use cases in large and complex organizations across industries. These use cases include, but are not limited to, Enterprise Search (An enterprise-wide smart search engine that includes many heterogeneous sources of content and tens of millions of documents), 360° Views (An application that retrieves all relevant information about a product, person or any other entity across heterogenous and unstructured data sources), and more specialized applications (e.g., GDPR compliance, contract analysis, customer support portal, data loss prevention, pharmaceutical R&amp;D, etc.).  The platform integrates proprietary and open-source technologies to deliver top performance and relevance in Search, Natural Language Processing and Deep Learning. We provide rich and extensible User Interfaces with our Angular-based SBA framework. We release this framework as open source to give our customers more flexibility and to foster a worldwide community of developers.    Overview of the Sinequa platform ","version":"Next","tagName":"h2"},{"title":"Usage Analytics","type":0,"sectionRef":"#","url":"/dokku/docs/apps/usage-analytics","content":"Usage Analytics Usage analytics is a set of analytic dashboards that lets Sinequa administrators/users track the activity of their application(s). This application relies on the dataset web service to fetch usage data from an audit-type index. The application is designed to be fully customizable via a simple JSON configuration. Usage analytics has a single route &quot;/audit&quot;. The dashboards are composed of many standard components from the @sinequa/components and @sinequa/analytics libraries. The 2 top-level components are: The App component, which is essentially a wrapper for the &lt;router-outlet&gt;.An Audit route, allowing users to browse analytic dashboards and customize them. Dashboards are built on top of the angular-gridster2 library, like the dashboard module powering Pepper. To access the comprehensive technical documentation of Usage analytics, please refer to the detailed information available in the GitHub repository","keywords":"","version":"Next"},{"title":"Hello Search","type":0,"sectionRef":"#","url":"/dokku/docs/apps/hello-search","content":"","keywords":"","version":"Next"},{"title":"App module​","type":1,"pageTitle":"Hello Search","url":"/dokku/docs/apps/hello-search#app-module","content":" Hello Search has one Angular module (AppModule) in src/app/app.module.ts. It looks very much like the default app.module.ts you would get from creating a new Angular app with ng new, with some specific points:  We import required modules from @sinequa/core and pass them configuration via their forRoot() methods.In particular we must pass the StartConfig object to the WebServicesModule. This object contains the URL of the sinequa server (which can be omitted when the app is hosted on the server) and the name of the App configured in the Sinequa administration.We use {provide: LocationStrategy, useClass: HashLocationStrategy}, to manage routes (which is not specific to Hello Search).  ","version":"Next","tagName":"h2"},{"title":"App component​","type":1,"pageTitle":"Hello Search","url":"/dokku/docs/apps/hello-search#app-component","content":" Hello Search has one Angular component (AppComponent). It is made of:  A template: src/app/app.component.htmlA controller: src/app/app.component.tsA stylesheet: src/app/app.component.scss  ","version":"Next","tagName":"h2"},{"title":"Template​","type":1,"pageTitle":"Hello Search","url":"/dokku/docs/apps/hello-search#template","content":" The template (src/app/app.component.html) is divided in four parts:  Search Form:  The search form has a search field &lt;input&gt;, and two buttons (&quot;Search&quot; and &quot;Clear&quot;). When submitting the form, the search() method from the controller is called. Note that the form is deactivated if the user is not logged in.  &lt;form novalidate [formGroup]=&quot;form&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Enter search terms...&quot; formControlName=&quot;search&quot; spellcheck=&quot;false&quot; autocomplete=&quot;off&quot; [attr.disabled]=&quot;!loginService.complete? '' : null&quot;&gt; &lt;button type=&quot;submit&quot; (click)=&quot;search()&quot; [attr.disabled]=&quot;!loginService.complete? '' : null&quot;&gt;Search&lt;/button&gt; &lt;button *ngIf=&quot;results$ | async&quot; type=&quot;button&quot; (click)=&quot;clear()&quot;&gt;Clear&lt;/button&gt; &lt;/form&gt;   Results:  The results list displays the list of Record objects from a Results object provided by the controller. The first *ngIf and | async allow to display the results only when they become available (it is asynchronous, since the server cannot respond instantaneously). Then, the *ngFor iterates through the list of results. Inside this &lt;div&gt;, we then display the title, source and relevant extracts of each document.  &lt;div *ngIf=&quot;results$ | async; let results&quot;&gt; &lt;hr&gt; &lt;div *ngFor=&quot;let record of results.records&quot; class=&quot;record&quot;&gt; &lt;a href=&quot;{{record.url1}}&quot;&gt; &lt;h3 [innerHtml]=&quot;record.displayTitle || record.title&quot;&gt;&lt;/h3&gt; &lt;/a&gt; &lt;div class=&quot;source&quot;&gt;{{record.url1}}&lt;/div&gt; &lt;p *ngIf=&quot;record.relevantExtracts&quot; [innerHTML]=&quot;record.relevantExtracts&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;   Login/Logout buttons:  These buttons call the login() and logout() methods of the controller.  &lt;button *ngIf=&quot;loginService.complete&quot; type=&quot;button&quot; (click)=&quot;logout()&quot;&gt;Logout&lt;/button&gt; &lt;button *ngIf=&quot;!loginService.complete&quot; type=&quot;button&quot; (click)=&quot;login()&quot;&gt;Login&lt;/button&gt;   Notifications:  Notifications are typically some error messages coming from the Sinequa services and managed by the NotificationModule from @sinequa/core. If you fail to log in or to get data from the Sinequa indexes, you will likely see a message displayed at the bottom of the app.  &lt;ng-container *ngIf=&quot;notificationsService.notificationsStream | async as notification&quot;&gt; &lt;hr&gt; &lt;div *ngIf=&quot;deleteNotification(notification)&quot; class=&quot;notification&quot;&gt; &lt;div *ngIf=&quot;notification.title&quot; class=&quot;title&quot;&gt; &lt;span&gt;{{notification.title | sqMessage}}&lt;/span&gt; &lt;hr&gt; &lt;/div&gt; &lt;div&gt;{{notification.text | sqMessage:{values: notification.params} }}&lt;/div&gt; &lt;/div&gt; &lt;/ng-container&gt;   ","version":"Next","tagName":"h3"},{"title":"Controller​","type":1,"pageTitle":"Hello Search","url":"/dokku/docs/apps/hello-search#controller","content":" The controller (src/app/app.component.ts) consists of the class AppComponent, which is made of the main following parts:  Fields:  The AppComponent class has the following fields:  searchControl: An Angular UntypedFormControl object used to handle the search input value.form: An Angular UntypedFormGroup object needed to interact with the content of a &lt;form&gt;.results$: An rxjs Observable of Results (since results are retrieved asynchronously) which can also be undefined.  searchControl: UntypedFormControl; form: UntypedFormGroup; results$: Observable&lt;Results&gt; | undefined;   Constructor:  In the constructor, we inject the following services from @sinequa/core (and initialize our form):  LoginService: Service in charge of authentication and initialization of other services.AppService: Service in charge of retrieving the configuration of your application from the Sinequa server.QueryWebService: Service in charge of sending queries and retrieving results from the Sinequa server.NotificationsService: Service in charge of centralizing errors and warnings from other services.  constructor( protected formBuilder: FormBuilder, public loginService: LoginService, public appService: AppService, public queryWebService: QueryWebService, public notificationsService: NotificationsService) { this.searchControl = new UntypedFormControl(&quot;&quot;); this.form = this.formBuilder.group({ search: this.searchControl }); }   Search method:  The search() method is called when the user clicks on the &quot;search&quot; button. It performs the following tasks:  Create a new Query object (with the right name, retrieved from the app configuration.Set the query.text to the value typed by the user in the search form (this.searchControl.value).Send the query to the QueryWebService and get the results observable (results$). When results are available (asynchronously), the template will display them.  search() { const ccquery = this.appService.ccquery; const query = new Query(ccquery ? ccquery.name : &quot;_unknown&quot;); query.text = this.searchControl.value || &quot;&quot;; this.results$ = this.queryWebService.getResults(query); }   Login and Logout method:  The login() and logout() methods are essentially proxies to the corresponding methods in the LoginService which manages the authentication. Note that the LoginService also takes care of retrieving data from the server via three services:  The AppWebService, which retrieves the configuration of the applications.The PrincipalWebService, which retrieves the user data from its domain (it includes the name, email, id, and other data).The UserSettingsWebService, which retrieves the User Settings (more information in the Tutorial and the Tips &amp; Tricks)  Additionally, we clear the results on log out, by removing the results$ and emptying the search form.  clear() { this.results$ = undefined; this.searchControl.setValue(&quot;&quot;); } login() { this.loginService.login(); } logout() { this.clear(); this.loginService.logout(); }   ","version":"Next","tagName":"h3"},{"title":"Stylesheet​","type":1,"pageTitle":"Hello Search","url":"/dokku/docs/apps/hello-search#stylesheet","content":" The component's stylesheet (src/app/app.component.scss) contains CSS rules applied only within the component. In particular:  Page layout rules, making our search results more readable: .search { max-width: 800px; margin-left: 100px; } Text sizing, coloring and spacing for the title (h1), document title (h3), document source (.source) and relevant extracts (p). Styling of the notifications: .notification { border: solid; padding: 8px; .title { font-weight: bold; } }   In addition to the component's stylesheet, a global stylesheet (src/styles/app.scss) contains styles that apply to the whole app. This is where you would import (globally) third party styling libraries such as Bootstrap (see the tutorial).  @import &quot;~@angular/cdk/overlay-prebuilt&quot;; body { font-family: Arial, &quot;Helvetica Neue&quot;, Helvetica, sans-serif; } a { text-decoration: none; color: #3434d6; } .record .match-highlight { font-weight: bold; font-style: italic; }  ","version":"Next","tagName":"h3"},{"title":"Pepper","type":0,"sectionRef":"#","url":"/dokku/docs/apps/pepper","content":"","keywords":"","version":"Next"},{"title":"Integrated search form​","type":1,"pageTitle":"Pepper","url":"/dokku/docs/apps/pepper#integrated-search-form","content":" The search form of Pepper is more advanced than the one of Vanilla Search. Because of the reduced &quot;UI real estate&quot; of the dashboard, the search form integrates the filters and facets in addition to the traditional autocomplete.    This search form is composed of the following components:  The sq-search-form component (from @sinequa/components/search-form), which displays the search input and the search button, and manages the expanded/collapsed state of the panel below.The sq-filters-view component (from @sinequa/components/filters), which displays the filters (if any) in normal mode or advanced mode (letting users customize their query more deeply).The sq-facet-container component (from @sinequa/components/facet), which displays the list of available facets (aka &quot;filters&quot;) and lets users click and open them.The app-autocomplete component (from the Vanilla Search application).  This search form can be customized by editing the app-search-form component of Pepper.  ","version":"Next","tagName":"h2"},{"title":"Dashboard​","type":1,"pageTitle":"Pepper","url":"/dokku/docs/apps/pepper#dashboard","content":" The dashboard of Pepper is based on the @sinequa/analytics/dashboard module, which itself is based on the angular-gridster2 library.  Dashboards can be customized by the user by dragging and resizing widgets and by adding new ones from a list of predefined widget types. A developer can easily add new widget types or configure the existing ones.    Pepper includes the following widgets by default:  Network (from @sinequa/analytics/network)Google Maps (from @sinequa/analytics/googlemaps)Timeline (from @sinequa/analytics/timeline)Chart (from @sinequa/analytics/fusioncharts)Heatmap (from @sinequa/analytics/heatmap)Tag cloud (from @sinequa/components/facet)Money cloud and Money timeline (from @sinequa/analytics/finance)  The dashboard also allows you to open multiple document previews by clicking on documents from the result list. When the dashboard is reopened, these previews are fetched again from the Sinequa indexes.    ","version":"Next","tagName":"h2"},{"title":"Architecture​","type":1,"pageTitle":"Pepper","url":"/dokku/docs/apps/pepper#architecture","content":" Pepper's search route (app-search component) looks similar to Vanilla Search.  Pepper's dashboard is defined in the app-dashboard component, which is displayed in the app-search component:  &lt;app-dashboard [results]=&quot;results&quot;&gt;&lt;/app-dashboard&gt;   The definition of the list of widgets and their configuration is done in the app-dashboard component. Its template looks as follows:  &lt;sq-dashboard [dashboard]=&quot;dashboard&quot;&gt; &lt;ng-template let-widget&gt; &lt;sq-facet-card [title]=&quot;widget.state.title&quot; [icon]=&quot;widget.icon&quot; [collapsible]=&quot;false&quot; [actions]=&quot;widget.actions&quot; [ngSwitch]=&quot;widget.state.type&quot;&gt; &lt;widget-type-foo *ngSwitchCase=&quot;'foo'&quot;&gt; &lt;widget-type-bar *ngSwitchCase=&quot;'bar'&quot;&gt; ... &lt;/sq-facet-card&gt; &lt;/ng-template&gt; &lt;/sq-dashboard&gt;   This snippet contains the following elements:  The sq-dashboard component (from @sinequa/analytics/dashboard). This component handles the dashboard layout and configuration management.The ng-template encapsulates one widget. The sq-dashboard component will create one instance of this template for each widget in the dashboard.All widgets are displayed within an sq-facet-card component (from @sinequa/components/facet). This component is used to display the widget title, icon and actions.Within this card, an ngSwitch directive is used to display the appropriate widget component, depending on the type of the widget.  Internally, the app-dashboard component uses the DashboardService (from @sinequa/analytics/dashboard). This service handles the following tasks:  Exporting and importing the dashboard state in JSON format.Displaying the &quot;Add Widget&quot; popup shown above.Creating new widgets based on a WidgetOption object.  The app-dashboard component persists the state of the dashboard in the User Preferences.  ","version":"Next","tagName":"h2"},{"title":"Developing new widgets​","type":1,"pageTitle":"Pepper","url":"/dokku/docs/apps/pepper#developing-new-widgets","content":" Pepper is meant to be customized easily, especially to let developers create new types of widgets, either generic or specific to their project.  Adding a widget will impact different parts of the code, and the following must be considered:  The widget must be displayed (within its parent component app-dashboard).The widget must be synchronized with other widgets and the results list.The widget might have properties that need to be persisted.The widget size must adapt to the dashboard grid.  ","version":"Next","tagName":"h2"},{"title":"Widget definition​","type":1,"pageTitle":"Pepper","url":"/dokku/docs/apps/pepper#widget-definition","content":" A widget is defined by adding a new WidgetOption object to the list of options of the app-dashboard component. This object defines the following properties:  type: A unique identifier for the widget type.icon: The icon of the widget.text: The name of the widget (displayed next to the icon).state: An object that can be used to store a custom state of the widget (see below).init: A function that is called when the widget is created. This function can be used to initialize the state of the widget (see below).unique (default: true): A boolean indicating whether the widget is unique (only one instance of this widget can exist in the dashboard).maximizable (default: true): A boolean indicating whether the widget can be maximized (taking up the whole dashboard).removable (default: true): A boolean indicating whether the widget can be removed from the dashboard.renamable (default: false): A boolean indicating whether the widget can be renamed.rows (default: 2): The number of rows the widget takes in the dashboard grid.cols (default: 2): The number of columns the widget takes in the dashboard grid.  The widget's display must be implemented in the app-dashboard HTML template (see above). Adding a new component simply means adding a new &quot;case&quot; such as:  &lt;my-custom-widget *ngSwitchCase=&quot;'my-custom-type'&quot; [results]=&quot;results&quot;&gt; &lt;/my-custom-widget&gt;   ","version":"Next","tagName":"h3"},{"title":"Widget creation / initialization​","type":1,"pageTitle":"Pepper","url":"/dokku/docs/apps/pepper#widget-creation--initialization","content":" The creation of the widget can occur in different ways:  By clicking the &quot;Add Widget&quot; button and selecting your widget type.On initialization, when a default dashboard is created.When another type of user action is taken (e.g., we open the preview when the user clicks on a document).  Add Widget popup​  A custom widget will automatically be included in the &quot;Add Widget&quot; popup as soon as it is added to the list of WidgetOption objects in the app-dashboard component.  If you do not want your widget to be displayed in the popup, you can customize the addWidget() method of app-dashboard (there is already a special rule for excluding the preview widget).  Default dashboard​  The list of widgets included in the default dashboard is defined in the app-dashboard component (defaultWidget property).  The default widgets include:  defaultWidgets = ['map', 'timeline', 'network', 'chart'];   Manual creation​  Adding a widget programmatically (like when opening a document preview) can be done in 3 steps:  Create a WidgetOption object (see above).Create a Widget object by calling DashboardService.createWidget(option).Add the widget to the dashboard by calling DashboardComponent.add(widget). (Notice that the app-dashboard component has access to an instance of DashboardComponent.)  ","version":"Next","tagName":"h3"},{"title":"Widget synchronization​","type":1,"pageTitle":"Pepper","url":"/dokku/docs/apps/pepper#widget-synchronization","content":" The way the built-in widgets are designed is actually to avoid explicit synchronization, that is: to do nothing and keep the components independent from each other.  However, it is clear when using Pepper that some form of synchronization happens when the user interacts with a component. For example, if I use the map to filter the search results, all the other components that display parts of the results are updated.  The way it works is that the widgets respond only to an update of the global results. Widgets cannot talk to each other, but some user interactions (like selecting an area on the map) can trigger a refresh of the global results (which itself triggers a refresh of the widgets).  Similarly, widgets can listen to other types of global events. For example, the SelectionService keeps track of documents selected via their sq-result-selector checkbox (See Selection). If a widget displays a document in one form or another (like a pin on the map), it can update the pin display when the document becomes selected, and conversely select the document when the user clicks on the pin.  ","version":"Next","tagName":"h3"},{"title":"Widget persistence​","type":1,"pageTitle":"Pepper","url":"/dokku/docs/apps/pepper#widget-persistence","content":" Users expect that when they refresh the page, the dashboard is restored in the same state as they left it. This means that the state of the widgets must be persisted.  The dashboard component automatically persists any data stored in the widget.state object. This object is serialized in JSON format and stored in the user preferences.  To persist or not to persist​  Not all of the state needs to be persisted. For example, your custom widget might look like the following:  &lt;my-custom-widget *ngSwitchCase=&quot;'my-custom-type'&quot; [constant]=&quot;'Hello world'&quot; [results]=&quot;results&quot; [parameter]=&quot;widget.parameter&quot; [parameterPersistent]=&quot;widget.state.parameter&quot;&gt; &lt;/my-custom-widget&gt;   This example shows different types of inputs that a widget can have:  Constants: fixed values that are hard-coded or defined in the app configuration.Variables: Values that may change at any time (for example, the results object).Parameters: values defined when the widget is created and stored in the widget object (but lost or recomputed when you refresh the page).Persistent parameters: parameters that are stored in widget.state and persisted in the user settings.  Only the minimum amount of information should be persisted in widget.state. If a complex object can be re-computed based on the state, it is better to do so than to persist it.  For example:  If your component expects a Results object, do not store the Results object in the state. Instead, store the Query object and generate the Results object when the widget is created.If your component expects a Record object, store the id of the record and generate the Record object when the widget is created.  For example, in the standard components, the persisted items include:  For all widgets: Widget size and position in the dashboard.For the preview widget: id of the opened document and the search query yielding that document.For the chart widget: Selected aggregation and chart type.  Initializing the widget​  The definition of the WidgetOption is very important to properly initialize the state. For example:  option = { type: &quot;my-custom-type&quot;, icon: &quot;fas fa-chart-bar&quot;, text: &quot;My custom widget&quot;, ...defaultOptions, state: { param: &quot;Hello world&quot;, }, init: (widget) =&gt; widget.otherParam = createComplexObject(widget), }   In the above example, param is the default state (that can be later modified during the life of the widget). otherParam is a complex object that is generated when the widget is created and does not need to be persisted.  Note that the init method will also be called when the widget is restored from the user preferences to guarantee that otherParam is always defined.  Handling state changes​  If the (persisted) state of your custom widget changes, it should be reflected in the user preferences.  The simplest way to achieve this is to call DashboardComponent.update(widget, state), where state is only a &quot;patch&quot; of the state that has changed.  For example, when the user modifies the chartType property of a chart widget, an event handler is called:  (typeChange)=&quot;dashboardComponent.update(widget, {chartType: $event})&quot;   (In turn, the sq-dashboard component triggers a (changed) event handled by the app-dashboard component, which saves the state in the user preferences.)  ","version":"Next","tagName":"h3"},{"title":"Widget sizing​","type":1,"pageTitle":"Pepper","url":"/dokku/docs/apps/pepper#widget-sizing","content":" One difficulty in building widgets is that their size is strongly constrained by the dashboard, so the components cannot take their ideal size. They must be able to adapt to any size (for example, by forcing a width and height of 100% or by scrolling vertically or horizontally) or conform to an explicit size (in pixels) provided by the parent (sq-dashboard) via the widget.width and widget.height properties.  The built-in components behave differently in that respect:  The network's canvas takes the available space using width: 100% and height: 100%.The charts are explicitly resized when the dashboard is initialized or resized.The map's height is bound explicitly (i.e., the width is automatically 100%).The heatmap and timeline are svg-based and are redrawn when resized. Therefore, the width and height are explicitly bound.  For example a custom widget with a fixed size and scrollable content might look like:  &lt;div *ngSwitchCase=&quot;'my-custom-type'&quot; class=&quot;overflow-auto&quot; [ngStyle]=&quot;{ 'height.px': widget.height, 'width.px': widget.width }&quot;&gt; content &lt;/div&gt;   If your component must be redrawn when its size changes, it is likely to need an interface similar to the timeline or heatmap components. Concretely, it will probably require explicit width and height inputs (probably with default values). The ngOnChange() will then catch any change of dimension from the parent and trigger the redrawing:  @Input() width = 600; @Input() height = 400; ngOnChanges(changes: SimpleChanges) { if(changes['width'] || changes['height']) { redraw(); } }   The width and height inputs may also be used in the template. For example:  &lt;svg width=&quot;{{width}}&quot; height=&quot;{{height}}&quot;&gt; ... &lt;/svg&gt;  ","version":"Next","tagName":"h3"},{"title":"Contact Us","type":0,"sectionRef":"#","url":"/dokku/docs/contact","content":"Contact Us Interested in Sinequa? Contact us by email or give us a call! (See our contact page)","keywords":"","version":"Next"},{"title":"Vanilla Search","type":0,"sectionRef":"#","url":"/dokku/docs/apps/vanilla-search","content":"","keywords":"","version":"Next"},{"title":"Home route​","type":1,"pageTitle":"Vanilla Search","url":"/dokku/docs/apps/vanilla-search#home-route","content":" The Home route has a search bar (Search Form component), and a list of facets:    You can also switch to a dark theme, by clicking the button under the search bar.    You can easily change the logo at the top of the template:  &lt;!-- Home page logo --&gt; &lt;img src=&quot;{{ (isDark$ | async) ? 'assets/sinequa-logo-dark-lg.png' : 'assets/sinequa-logo-light-lg.png' }}&quot; id=&quot;logo&quot; class=&quot;mb-5&quot;&gt;   This is followed by the search form in the center.  Then, by default, the homepage includes four facets:  Recent documents: sq-facet-recent-documentsRecent queries: sq-facet-recent-queriesSaved queries: sq-facet-saved-queriesCollections (aka &quot;Baskets&quot;): sq-facet-baskets  These facets can of course be added or removed, directly in the component template, or via configuration.  The controller manages:  Login and Logout, via the LoginService.Light / Dark theme toggling.The list of facets to display and their responsive sizing.  ","version":"Next","tagName":"h2"},{"title":"Search route​","type":1,"pageTitle":"Vanilla Search","url":"/dokku/docs/apps/vanilla-search#search-route","content":" The Search route has a navbar on top, which includes a search bar (Search Form component), and user menus coming from various libraries of @sinequa/components. Under it are a facet bar (with two facets) and the search results. It is also possible to open a preview of a document on the right, by selecting it in the results.    The template starts with the navbar, which contains:  A responsive logo (&lt;img id=&quot;logo&quot; src=...&gt;)The search formUser menus, which include by default: Collections (aka &quot;Baskets&quot;): sq-baskets-menuSaved Queries: sq-saved-queries-menuAlerts: sq-alerts-menuLabels: sq-labels-menuGeneral User Menu: sq-user-menu The navbar also includes responsive buttons to toggle the visibility of the menu and the facets. The implementation is similar to the one in the tutorial.  The main view under the navbar includes:  A Facet Bar on the left, with by default: A hierarchical source facet: sq-facet-listA multiple metadata facet: sq-facet-multi In the center, a list of results, including: Tabs: sq-tabsA &quot;Did you mean?&quot; component: sq-did-you-meanSponsored links: sq-sponsored-resultsThe filters list applied to the query: sq-filters-viewA facet displaying the top passages: sq-facet-card containing sq-top-passagesA Results counter: sq-results-counterA Sort selector: sq-sort-selectorFor each document: A selector (checkbox): sq-result-selectorThe document's title: sq-result-titleThe document's source: sq-result-sourceThe document's relevant extracts: sq-result-extractsThe document's missing terms: sq-result-missing-termsThe document's labels: sq-labelsThe document's duplicates: sq-result-duplicatesThe document's thumbnail: sq-result-thumbnail An infinite scroller: sq-scroller On the right, an sq-facet-card containing: An image and description when no document is currently selectedDocument details when one is selected: The document's icon: sq-result-iconThe document's title: sq-result-titleThe document's metadata: sq-metadataThe document's passages (in a view tab): sq-passage-listThe document's preview (in a view tab): sq-previewThe document's duplicates (in a view tab): sq-result-duplicates-list And at the bottom left corner: A list of actions available for the currently selected document(s): sq-results-selector  The controller manages:  The list of facets displayed within sq-facet-multi (which can be modified via configuration).The list of menus displayed in the navbar (which can be modified via configuration).The list of metadata displayed by the &quot;mini-preview&quot; (which can be modified via configuration).The opening and closing of documents in the &quot;mini-preview&quot; on the right.The (responsive) visibility of facets, results and menus, based on screen size and user actions.  ","version":"Next","tagName":"h2"},{"title":"Preview route​","type":1,"pageTitle":"Vanilla Search","url":"/dokku/docs/apps/vanilla-search#preview-route","content":" The Preview route displays the HTML preview of the document on the right. On the left, a panel contains various tools to interact with the document:  A search bar (sq-preview-search-form), to search and highlight text within the document (note that it uses Sinequa NLP to recognize the language and find words in all their possible forms).A list of relevant extracts (sq-preview-extracts-panel), to quickly navigate to the important parts of the document.A list of entities and relevant keywords (sq-preview-entity-panel), to visualize the diversity of topics, navigate between them and control their highlighting.  On the right, the HTML preview is displayed within the sq-preview component. Additionally, a dynamic tooltip (sq-preview-tooltip) is inserted in the HTML preview to provide additional functionality when users hover their mouse over entities or select text, and a minimap (sq-preview-minimap) is also inserted to add a right bar to preview container that allows to identify the extracts' locations more easily.    The controller manages:  Navigation events (fetch the preview data when the page is reloaded, or when we search for text within the document).Preview Tooltip custom actions (like the search button when text is selected)The list of entities highlights that sq-preview, sq-preview-extracts-panel and sq-preview-entity-panel have to display (which can be modified via configuration).  ","version":"Next","tagName":"h2"},{"title":"Search form​","type":1,"pageTitle":"Vanilla Search","url":"/dokku/docs/apps/vanilla-search#search-form","content":" The Search Form component uses sq-search-form as the one developed in the tutorial, but with a more advanced Autocomplete component allowing to search into User Settings objects, such as the recent queries, documents, baskets, etc.    The controller includes a search method with onAutocompleteSearch() triggered when the autocomplete component emits that it should trigger the search. Additionally, it manages the list of custom features that the autocomplete can search into, like the recent documents, the recent queries, the baskets and the saved queries (this list can be configured).  The autocomplete component is responsible for getting the suggestions when typing.  The getSuggests() method can search in custom objects, as mentioned above (in addition to the classical &quot;Suggest Queries&quot; configured on the server). Notice that, to merge the different sources of autocomplete, we use the forkJoin operator from rxjs: // The forkJoin method allows to merge the suggestions into a single array, so the parent // directive only sees a single source. return forkJoin(dataSources).pipe( map(suggests =&gt; suggests .flat() .sort(this.sortComparator) .slice(0, this.maxItems) ) ); Notice that each data source has a custom search method, leveraging the SuggestService's searchData() method. For example: searchRecentDocuments(text: string): Promise&lt;AutocompleteItem[]&gt; { return this.suggestService.searchData( 'recent-document', text, this.recentDocumentsService.recentdocuments, doc =&gt; doc.title, doc =&gt; ([] as string[]).concat(doc.url1, doc.treepath, doc.authors), &quot;msg#searchForm.recentDocument&quot;); } The selectItem() method performs custom actions, depending on the category of suggestion. For example, recent documents are directly opened, via previewService.openRoute(), saved queries are searched in the /search route, etc.  ","version":"Next","tagName":"h2"},{"title":"Configuration​","type":1,"pageTitle":"Vanilla Search","url":"/dokku/docs/apps/vanilla-search#configuration","content":" Vanilla Search can be configured via two methods (as described in Configuration):  A central Typescript source file: src/config.ts, which is built with your application.A JSON object downloaded from the Sinequa server on start-up (configured in your App's &quot;Customization (JSON)&quot; tab) and available via the AppService (post-login).  The components of Vanilla Search described above use three configuration objects:  FEATURES: a list of string that controls which features are activated in the app. This list is used to determine which facets are displayed in the homepage, which menus are displayed in the search page, which objects are searched by the autocomplete, and which options are available in the search form, such as the advanced search form or the voice recognition button. FACETS: a list of FacetConfig objects that determines the facets displayed within the sq-facet-multi component. Each object contains a number of options that are passed to the corresponding facet components. For example: { name: &quot;geo&quot;, aggregation: &quot;Geo&quot;, title: &quot;msg#facet.geo.title&quot;, type: &quot;list&quot;, icon: &quot;fas fa-fw fa-globe-americas&quot;, parameters: { showCount: true, searchable: true, focusSearch: true, allowExclude: true, allowOr: true, allowAnd: false, displayEmptyDistributionIntervals: false, } } Of course, these facets require a corresponding Aggregation to exist on the Sinequa server, and consequently within the Results object. METADATA_CONFIG: a list of MetadataConfig to be displayed in the &quot;mini-preview&quot;, within a sq-metadata component (More information in the Custom Metadata section). PREVIEW_HIGHLIGHTS: a list of PreviewHighlightColors used in the preview related components to define the highlights colors for the different entities (More information in the Custom Entities section).  The four objects above can be customized statically in the src/config.ts file. It is also possible to override their value dynamically, via the &quot;Customization (JSON)&quot; tab of your App (See Configuration). For example, you could configure the following object to override the features:  { &quot;features&quot;: [ &quot;recent-queries&quot;, &quot;saved-queries&quot;, &quot;baskets&quot;, &quot;labels&quot;, &quot;alerts&quot;, &quot;suggests&quot; ] }   The reason this works is that Vanilla Search always implement the following logic:  if server-configuration exists use server-configuration else use config.ts   For example, in search.component.ts the metadata displayed in the &quot;mini-preview&quot; comes from the following method:  import { FEATURES } from '../../config'; // src/config.ts ... public get features(): string[] { return this.appService.app?.data?.features as string[] || FEATURES; }   ","version":"Next","tagName":"h2"},{"title":"Styles​","type":1,"pageTitle":"Vanilla Search","url":"/dokku/docs/apps/vanilla-search#styles","content":" The styles of Vanilla Search come from various sources:  Third-Party stylesheets, in particular Bootstrap. Third-Party stylesheets are imported in the minimal and sinequa theme from Sinequa Theme that you can import in your global stylesheet (src/styles/app.scss): // Sinequa global theme (contains Bootstrap imports) // @import &quot;../../../components/theme/minimal&quot;; @import &quot;../../../components/theme/sinequa&quot;; Note that Bootstrap is used throughout the app (and the @sinequa/components library) via well documented class names. See Responsive Design. Sinequa Modules stylesheets, which are global-level styles that could not be encapsulated in the Angular components (for good reasons). They are imported in the app's global stylesheet (src/styles/app.scss): @import &quot;../../../components/theme/breakpoints&quot;; Components stylesheets, like home.component.scss, search.component.scss, preview.component.scss. This is generally the preferred way of styling components (besides Bootstrap), since the CSS is well encapsulated in your component scope (there cannot be side-effects to other components) and it alleviates the global stylesheet. The app's global stylesheet (src/styles/app.scss). This file is mostly used to setup the variables and handling imports. Even though it is possible to make changes there, we advise to use src/styles/vanilla.scss to make custom changes. This stylesheet contains many rules that override the rules in the above stylesheets. For example, we restyle the tabs component: sq-tabs { .nav-tabs { margin-bottom: 0.5rem; } .nav-item .count { font-size: 0.875em; color: $secondary; } } Other styles imported by the global stylesheets:  styles/icons.scss contains many classes defining icons.styles/vanilla.scss contains the overrides as described above.styles/dark.scss contains the rules that override the normal styles to produce a &quot;dark mode&quot;. It is imported at the very end of styles/vanilla.scss. ","version":"Next","tagName":"h2"},{"title":"Vanilla Builder","type":0,"sectionRef":"#","url":"/dokku/docs/apps/vanilla-builder","content":"","keywords":"","version":"Next"},{"title":"Project's folder structure​","type":1,"pageTitle":"Vanilla Builder","url":"/dokku/docs/apps/vanilla-builder#projects-folder-structure","content":" ","version":"Next","tagName":"h2"},{"title":"/configurators​","type":1,"pageTitle":"Vanilla Builder","url":"/dokku/docs/apps/vanilla-builder#configurators","content":" Contains all configurators widgets used to customize the vanilla-search application. Usually, a configurator widget is associated to a SBA components. But it's not always the case.  Specific to Analytics components  configurator\tdescriptionchart\tconfigure a specific chart within a list of charts heatmap\tconfigure an heatmap component network\tconfigure a network component timeline\tconfigure a timeline component  Specific to SBA Components  configurator\tdescriptioncomments\tconfigure a comments component facet\tconfigure a specific facet within a list of facets facet-multi\tconfigure a facet multi component menu\tconfigure the navbar menu metadata\tconfigure a metadata component predefined-results-layout\tconfigure how the results are displayed preview\tconfigure a preview component search-form-legacy\tconfigure a search bar (legacy) component slide-builder\tconfigure a slide builder component  Specific to Application component  Each application's pages contains a specific configurator component. This component describes how to customize the page and which SBA components are allowed to drop within it.  configurator\tdescriptionhome-facet\tconfigure a home's facet component home\tconfigure the Vanilla's Home components search\tconfigure the Vanilla's Search components  ","version":"Next","tagName":"h3"},{"title":"/configurators/app-configuration​","type":1,"pageTitle":"Vanilla Builder","url":"/dokku/docs/apps/vanilla-builder#configuratorsapp-configuration","content":" configurator\tdescriptionglobal\tconfigure the global's application configuration Today, only those parameters are customizable: - application's name - font family - background image/color - color's theme global-service\tuse the configuration from the ui-builder when builder is enable and use the config.ts configuration in static mode (see static export section)  ","version":"Next","tagName":"h3"},{"title":"/toolbar​","type":1,"pageTitle":"Vanilla Builder","url":"/dokku/docs/apps/vanilla-builder#toolbar","content":" The toolbar component allows you to add custom options to the ui-builder's toolbar. By default, the ui-builder's toolbar contains only the eye icon used to enable/disable the ui-builder and the undo/redo buttons.  To add your own buttons, just add them inside the &lt;uib-toolbar&gt;&lt;/uib-toolbar&gt; tag.  ","version":"Next","tagName":"h3"},{"title":"config.ts​","type":1,"pageTitle":"Vanilla Builder","url":"/dokku/docs/apps/vanilla-builder#configts","content":" This file contains the configuration by default. When you reset your configuration, the content of this file will be applied.  Configuration are split in multiple configuration's constants to ease it's customization. Updating this file, allows you to specify your own configuration when the application is first launched but also when you reset the whole configuration.  ","version":"Next","tagName":"h3"},{"title":"The ngx-ui-builder directives​","type":1,"pageTitle":"Vanilla Builder","url":"/dokku/docs/apps/vanilla-builder#the-ngx-ui-builder-directives","content":" To allow customization within a page, each page contains one or more &lt;uib-zone&gt;&lt;/uib-zone&gt;  Each &lt;uib-zone&gt;&lt;/uib-zone&gt; contains one or more uib-directive. Those directives allow the ui-builder library to know which components can be customized within each zones.  ","version":"Next","tagName":"h2"},{"title":"Inside the ui-builder directives​","type":1,"pageTitle":"Vanilla Builder","url":"/dokku/docs/apps/vanilla-builder#inside-the-ui-builder-directives","content":" Here we are exploring the directives allowing components customization.  Below a snippet of the Home page template (html)  &lt;uib-zone id=&quot;home&quot;&gt; ... &lt;ng-template uib-template=&quot;search-form&quot; display=&quot;Search form&quot; let-config&gt; &lt;app-search-form [autocompleteSources]=&quot;config.autocompleteSources&quot;&gt;&lt;/app-search-form&gt; &lt;/ng-template&gt; ... &lt;/uib-zone&gt;   Here a zone called home is set. Inside this zone, a uib-directive called search-form is set. Now, the ui-builder library knows the app-search-form component can be customized. As you can notice in this example, app-search-form is not a SBA component: indeed, the uib-builder can be used with any kind of components.  Now, take a look at the home configuration object:  { id: 'home', type: '_container', classes: 'd-flex align-items-center flex-column w-100', items: ['home-logo', 'home-title', 'search-form', 'home-actions', 'home-facets'] }   This configuration is associated with the uib-zone with the id home. So, this describes the zone:  the zone is a container (type: '_container')the zone contains various components (items: [...]). Each component within this array will be rendered by index order.class is just for css styling the host element  In the items property, you can notice the search-form id. This tells the ui-builder library to render a component whose id is search-form  Let's see what this component is... The template (html) gives us the answer:   &lt;ng-template uib-template=&quot;search-form&quot; display=&quot;Search form&quot; let-config&gt; &lt;app-search-form [autocompleteSources]=&quot;config.autocompleteSources&quot;&gt;&lt;/app-search-form&gt; &lt;/ng-template&gt;   search-component is an app-search-form component.  Take a look at it's configuration object:  { id: 'search-form', type: 'search-form', classes: 'col-8 col-md-7 col-lg-5 col-xl-4 app-search-form px-2', autocompleteSources: ['suggests','baskets','recent-documents','recent-queries','saved-queries'], enableVoiceRecognition: true, keepTab: true, enableKeepFilters: true, keepFilters: true, enableAdvancedForm: true, keepAdvancedSearchFilters: true }   All properties after classes are the component's inputs default values. If you want keep some inputs not configurable, do not include them in the configuration.  Now, to allow an user to customize this values, you need to set a configurator. Configurators are all set inside a special HTML tag: &lt;uib-configurator&gt;&lt;/uib-configurator&gt;  In our example, the configutor's template looks like this:  &lt;uib-configurator&gt; ... &lt;ng-template uib-template=&quot;search-form&quot; let-context&gt; &lt;sq-search-form-legacy-configurator [context]=&quot;context&quot;&gt; &lt;/sq-search-form-legacy-configurator&gt; &lt;/ng-template&gt; ... &lt;/uib-configurator&gt;   Here we tell to the ui-builder which configurator to use with search-form. The context associated is (to be simple) the search-form's configuration object, so the configurator knows how to interact with the component.  Building a configurator is quite easy.  Below the search-form configurator:  import { Component, Input } from &quot;@angular/core&quot;; import { ConfiguratorContext } from &quot;@sinequa/ngx-ui-builder&quot;; @Component({ selector: 'sq-search-form-legacy-configurator', template: ` &lt;h6&gt;Autocomplete sources&lt;/h6&gt; &lt;uib-multi-selector [options]=&quot;sources&quot; valueField=&quot;value&quot; displayField=&quot;display&quot; [(ngModel)]=&quot;context.config.autocompleteSources&quot; (ngModelChange)=&quot;context.configChanged()&quot;&gt; &lt;/uib-multi-selector&gt; ` }) export class SearchFormLegacyConfiguratorComponent { @Input() context: ConfiguratorContext; sources = [ {value: &quot;suggests&quot;, display: &quot;Suggestions&quot;}, {value: &quot;baskets&quot;, display: &quot;Collections (aka. baskets)&quot;}, {value: &quot;recent-documents&quot;, display: &quot;Recent documents&quot;}, {value: &quot;recent-queries&quot;, display: &quot;Recent queries&quot;}, {value: &quot;saved-queries&quot;, display: &quot;Saved queries&quot;}, ] }   ui-builder comes with multiple built-in components and configurators ready to use. Here &lt;uib-multi-selector&gt;&lt;/uib-multi-selector&gt; is a kind of checkboxes list.  Configurators are displayed in the ui-builder panel, but while drag'n dropping component inside a uib-zone, those configurators can also be displayed as a modal window.  You must have now a good understanding how the ui-builder works in the backstage.  ","version":"Next","tagName":"h3"},{"title":"Static export​","type":1,"pageTitle":"Vanilla Builder","url":"/dokku/docs/apps/vanilla-builder#static-export","content":" Static website generation is done using Angular's schematics provided by the ui-builder library.  This step can be done by the Platform using a json plugin.  But you can also do this using a command line. Inside the package-json file you can find a make-static script. This script tells to the Angular's schematics how to convert &lt;uib-zone&gt; and uib-directive in a static website application.  Before, you need to download the configuration as a JSON file.  Take a look to this script:  &quot;make-static&quot;: &quot;ng generate @sinequa/ngx-ui-builder:make-static --app-module-dependencies=projects/vanilla/src/app-dependencies.json --config=projects/vanilla/src/config.json --config-path=projects/vanilla/src/config.ts --config-identifier=GLOBAL_CONFIG&quot;,   --app-module-dependencies is a configuration's dependencies file specific to vanilla-builder. It allows to remove useless dependencies depending on what components you use inside the application.--config is the path of the project's configuration json previously downloaded.--config-path is the path of the config.ts file to use to paste the global configuration.--config-identifier is the name of the constant to use inside the config.ts file to paste the configuration. By default it's value is GLOBAL_CONFIG, so it's optional if you don't use your own value.  When the static generation ends, a full static Angular's application will be available without any traces of the ui-builder's components and directives. All the global configuration will be written inside the config.ts file and used by de configuration service by default. ","version":"Next","tagName":"h2"},{"title":"Guides","type":0,"sectionRef":"#","url":"/dokku/docs/guides","content":"Guides This section contains various guides to support developers during the key stages of a project.","keywords":"","version":"Next"},{"title":"Architecture","type":0,"sectionRef":"#","url":"/dokku/docs/guides/architecture","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Architecture","url":"/dokku/docs/guides/architecture#overview","content":" In the Sinequa administration, Search-Based Applications are listed under the &quot;Apps&quot; section. An app acts as entry point for all the necessary configuration and resources of the application. In particular:  The web services contain the configuration of the application's REST API endpoints.The workspace contains the application's source code, dependencies and build artifacts.  info The source code and dependencies are only needed to build the application. The build artifacts are needed to deploy the application.  SBAs are Single-Page Applications (SPAs). The business logic of the application runs in the user's browser. The application is bundled into a static JavaScript file (generated during the build) that is downloaded on the application's startup. The application then communicates with Sinequa through its REST API.    This architecture allows for a clear separation of concerns between the generic web services and the specific business logic of the application. Notice that the application does not strictly need to be deployed on the Sinequa server. It could be deployed on a different server (or even on a CDN) as long as the application can communicate with the Sinequa REST API.  The configuration of the SBA-related components on the server (i.e., app, workspace and web services) is documented in the following guide (Server Configuration).  ","version":"Next","tagName":"h2"},{"title":"SBA architecture​","type":1,"pageTitle":"Architecture","url":"/dokku/docs/guides/architecture#sba-architecture","content":" Angular applications are organized into components and services. Components are the building blocks of the User Interface. Services manage the application's state and communicate with the server.  The SBA Framework provides a set of components and services that encapsulate Sinequa functionalities. These components and services are packaged into libraries that can be imported into applications.  An application can be seen as the stacking of the following layers that are bound together by the Angular framework:  Root components and custom application logic. This layer is specific to the application and can be largely customized by developers. For example, the Vanilla Search sample application has 1 top-level component and 3 sub-components (one for each route): the home page, the search page and the document preview page.High-level components and services from the SBA Framework (Components and Analytics libraries). These components and services provide specific Sinequa functionalities. They are designed to be used as-is, but they can also be customized by developers.Low-level interfaces, components and services from the SBA Framework (Core library). This layer provides the minimum utilities required to communicate with the Sinequa REST API. It is generally not customized by developers.  Theses layers are illustrated in the following diagram:    ","version":"Next","tagName":"h2"},{"title":"State management​","type":1,"pageTitle":"Architecture","url":"/dokku/docs/guides/architecture#state-management","content":" All applications have a state: what is the user searching for, which filter(s) did they apply, what results are displayed, which document was clicked, etc.  Each piece of state raises the following questions:  where does the state come from?which service or component manages the state?what happens when the state changes?should the state be persisted, and if so, where? (i.e., saved so that it can be restored later; for example, when the user refreshes the page)  ","version":"Next","tagName":"h2"},{"title":"Where does the state come from?​","type":1,"pageTitle":"Architecture","url":"/dokku/docs/guides/architecture#where-does-the-state-come-from","content":" State can originate from different places:  User actions: For example, navigating in the application, typing text in the search bar or clicking on a facet modifies the state of the application.Data from the Sinequa REST API (e.g., search results, saved queries, preferred UI language, etc.).  warning Note that prior to user login, the application will have no data from the server. A common mistake is calling the server too early. To avoid this, add an *ngIf=&quot;loginService.complete&quot; test to components that should only be displayed after the user is authenticated.  ","version":"Next","tagName":"h3"},{"title":"Which service or component manages the state?​","type":1,"pageTitle":"Architecture","url":"/dokku/docs/guides/architecture#which-service-or-component-manages-the-state","content":" In an SBA, the state can exist in various places:  The SearchService stores both the search query and search results. Many components can modify SearchService.query to change the search criteria, and many components display properties or sub-properties of SearchService.results (in particular, records: the list of documents and aggregations: the list of metadata displayed in facets).The User Settings are a storage system for user preferences and data. User settings are persisted on the Sinequa server and accessible only post-login.Other state can exist locally within a component class. This state is lost when the component is destroyed (e.g., when the user navigates to another page). For example, in Vanilla Search, the SearchComponent stores the document that is currently displayed in the preview panel.  ","version":"Next","tagName":"h3"},{"title":"What happens when the state changes?​","type":1,"pageTitle":"Architecture","url":"/dokku/docs/guides/architecture#what-happens-when-the-state-changes","content":" Angular supports different strategies for responding to state changes:  Input bindings: A component can receive data from its parent component (via the syntax &lt;my-component [inputParameter]=&quot;value&quot;&gt;). When the parent component's data changes, the child component is automatically updated (and its ngOnChanges method is called). Many SBA components have an @Input() results parameter to display data from the search results.Output bindings: A child component can emit events to its parent component (via the syntax &lt;my-component (outputEvent)=&quot;handler($event)&quot;&gt;). When the child component emits an event, the parent component's handler is called.Events: Services can emit events that are listened to by components. For example, the Angular router emits events when the URL changes. Similarly, the SearchService emits events when the search results are updated.Observables: RxJS observables are used to represent asynchronous data streams. For example, the SearchService exposes an observable resultsStream that emits a new value each time the search results are updated. Observables can be triggered by events and transformed by &quot;pipelines&quot;. Angular provides a pipe async that can be used to bind an observable to a component's template.  ","version":"Next","tagName":"h3"},{"title":"Should the state be persisted, and if so, where?​","type":1,"pageTitle":"Architecture","url":"/dokku/docs/guides/architecture#should-the-state-be-persisted-and-if-so-where","content":" In general, the state should be persisted if:  It is important to the user. For example, the current search query should be persisted if the user refreshes the page, so that they see the same results.It cannot be recomputed from other state: For example, the search query cannot be recomputed from something else, but the current search results can be recomputed from the search query, so they do not need to be persisted.  The state can be persisted in the following places:  The browser URL: A URL /hello?query=world encodes a navigation state (i.e., the page is &quot;hello&quot; and the query is &quot;world&quot;). The URL is &quot;de facto&quot; persisted as it remains the same when the user refreshes the page. In an SBA, the search query is generally encoded in the URL. This allows the user to bookmark the page and share the URL with other users. In fact, the SearchService listens to URL changes and performs new search queries accordingly.User settings are well-suited for small amounts of data that are specific to the user. For example, the user's preferred language or the list of saved queries.Other persistence systems can be used occasionally such as: the browser's local storage (for example, to store the user's preferred theme)Sinequa's engine metadata stores (used to attach custom metadata to documents such as labels)other server-side storage that could be accessed via a custom API endpoint (see for example the comments module).  ","version":"Next","tagName":"h3"},{"title":"Example: Searching for text​","type":1,"pageTitle":"Architecture","url":"/dokku/docs/guides/architecture#example-searching-for-text","content":" Here is a typical example of state management in an SBA: The user types text in the search bar and hits enter. The application then performs a search query and stores the query in &quot;recent queries&quot;.    This example illustrates various mechanisms of state management:  Events (user actions, router changes, results update)Persistence (URL, user settings)Services (search service, user settings service)Input bindings (results, facets) ","version":"Next","tagName":"h3"},{"title":"Deploying an application","type":0,"sectionRef":"#","url":"/dokku/docs/guides/deployment","content":"","keywords":"","version":"Next"},{"title":"Build process​","type":1,"pageTitle":"Deploying an application","url":"/dokku/docs/guides/deployment#build-process","content":" Your build process may be entirely manual, entirely automated (via Continuous Deployment), or something in-between.  For example, your environment might look like this:  Your workspace is hosted on a Git repository (e.g., GitHub, Gitlab, Bitbucket, etc.).When a git push is made to the main branch, a CI/CD pipeline is triggered (e.g., via GitHub Actions, Jenkins, etc.).The pipeline builds the application and runs some end-to-end testsWhen successful, the pipeline copies the build artifacts to your Sinequa server  There could be many variations of this process, but the key steps are:  Building the application with e.g., npm run buildvanilla (see Building an app).Serving the build artifact (i.e., the dist folder) on a web server (which is often a Sinequa server).  ","version":"Next","tagName":"h2"},{"title":"Deploying an SBA on a Sinequa server​","type":1,"pageTitle":"Deploying an application","url":"/dokku/docs/guides/deployment#deploying-an-sba-on-a-sinequa-server","content":" Sinequa serves the dist folder of the workspace of an app at the URL https://&lt;sinequa server&gt;/app/&lt;app name&gt;.  ","version":"Next","tagName":"h2"},{"title":"Example:​","type":1,"pageTitle":"Deploying an application","url":"/dokku/docs/guides/deployment#example","content":" Let's assume:  Your Sinequa server is hosted at https://example.comYour app (in the Sinequa configuration) is named &quot;foo&quot;Your workspace folder is named &quot;bar&quot;.Your Angular application within that workspace is named &quot;baz&quot;.  Then:  Your application will be available at https://example.com/app/foo. Your app configuration will look like: You workspace folder will look like:  ","version":"Next","tagName":"h3"},{"title":"Workspace content​","type":1,"pageTitle":"Deploying an application","url":"/dokku/docs/guides/deployment#workspace-content","content":" On the Sinequa server, the project workspace is stored in &lt;sinequa data folder&gt;/sba. The workspace does not need to include the source code or node modules. For deployment, only the dist folder is needed (along with a few config files). This is summarized in this table:  Folder/File\tDescription\tNeeded for build\tNeeded for deploymentprojects\tSource code of projects\tYes\tNo node_modules\tDependencies (installed via npm install)\tYes\tNo dist\tBuild artifacts (generated via npm run build)\tNo\tYes package.json\tProject configuration\tYes\tYes angular.json\tAngular configuration\tYes\tYes sba-workspace.xml\tSinequa configuration object\tYes\tYes  It is possible to run the build command (e.g., npm run buildvanilla) via the administration interface to generate the dist folder. (This requires the projects and node_modules folders.) Conversely, if your build is generated in a CI/CD pipeline, do not bother uploading the projects and node_modules to Sinequa.  ","version":"Next","tagName":"h3"},{"title":"Debug version​","type":1,"pageTitle":"Deploying an application","url":"/dokku/docs/guides/deployment#debug-version","content":" In addition to serving the dist folder at the /app/&lt;app name&gt; URL, Sinequa also serves the dist-debug folder at the /app-debug/&lt;app name&gt; URL.  This is useful when building your application in development mode (using npm run build &lt;app name&gt; -- --configuration=development), which generates a dist-debug folder instead of a dist folder. The debug version can be inspected with the browser's developer tools, which is very useful for debugging. It is equivalent to the version served by ng serve.  ","version":"Next","tagName":"h3"},{"title":"Deploying an SBA on another server​","type":1,"pageTitle":"Deploying an application","url":"/dokku/docs/guides/deployment#deploying-an-sba-on-another-server","content":" An SBA can be deployed on any kind of static web server. Simply copy the dist folder to the server and serve it at the URL of your choice.  However, when the URL of the SBA is different from the URL of the Sinequa server, there are two issues to consider:  The SBA cannot send requests to relative URLs (e.g., /api/v1/query), which is the default. It needs an absolute URL.Cross-origin requests must be enabled to avoid CORS errors (See CORS and WebApp configuration).  This is exactly the same issue as when using ng serve (See Development configuration).  And similarly, these issues can be solved with the following approaches:  by setting up a proxy (i.e., a web server that forwards requests from the SBA host to the Sinequa server).  OR:  by enabling cross-origin requests on the Sinequa server (e.g., adding https://&lt;sba-host&gt; to the Permitted Origins in your WebApp &gt; Stateless Mode configuration). by specifying the URL of the Sinequa server in the StartConfig object in your app.module.ts. export const startConfig: StartConfig = { url: &quot;https://my-sinequa-server&quot;, app: &quot;&lt;name of your app&gt;&quot;, production: environment.production };  ","version":"Next","tagName":"h2"},{"title":"Why contribute","type":0,"sectionRef":"#","url":"/dokku/docs/guides/contribute","content":"","keywords":"","version":"Next"},{"title":"Git and Github​","type":1,"pageTitle":"Why contribute","url":"/dokku/docs/guides/contribute#git-and-github","content":" We use Git (the version control system) and Github (the popular online Git repository hosting service) to manage our source code.  A Git repository contains files that were added and modified over time by developers. These changes are bundled in commits that come one after the other. Developers work in parallel, so this history is not a straight line. It is more like a tree, where branches stem out of the main trunk (the master branch). But unlike real trees, the goal of a branch is eventually to be merged back into the master. You can learn all about Git with online tutorials like this one.  Github is a cloud service that hosts Git repositories, for communities to develop software collaboratively. Github laid down the blueprint of modern open-source development, and we choose to adopt their established conventions and guidelines. You can learn about the Github collaborative workflow in the online documentation.  ","version":"Next","tagName":"h2"},{"title":"Repository structure​","type":1,"pageTitle":"Why contribute","url":"/dokku/docs/guides/contribute#repository-structure","content":" The repository has a master branch which contains the latest working and validated version of our source code. The master branch is also what gets packaged in Sinequa, when a new version is built and released.  Contributors cannot push code directly to the master branch because this could unintentionally break things. Instead, contributors can fork the repository, push code in a new branch (eg. my-feature) and submit a Pull Request. Pull Requests (PR for shorts) are the way to say &quot;I've done these changes, can we merge them in the master?&quot;. Your PR may not be immediately accepted (there might be conflicts with the master, or the need for improvements). In that case, just push additional changes in the same branch (Github detects these changes and updates the PR) until it can be merged safely.  ","version":"Next","tagName":"h2"},{"title":"Rules and Good Practices​","type":1,"pageTitle":"Why contribute","url":"/dokku/docs/guides/contribute#rules-and-good-practices","content":" In addition to Pull Requests, Github allows to open issues, to discuss bugs and features openly with all the community, which we recommend doing before actually pushing code to the repository.  Contributors should take a number of rules/principles into account:  Do not break genericity: The SBA framework needs to remain generic. This means all the functionality in the repository needs to be relevant and usable for more than one project. For example, never hard-code the name of your index columns.Do not break modularity: The SBA framework needs to remain modular. Modularity is broken when some code ties together various modules that are supposed to be independent from each other. Prefer breaking down your code in small independent files, and prefer creating new libraries or apps, rather than pilling up additional functionality on a bloated module.Do not diverge from conventions: We follow as much as possible Typescript and Angular good practices, so that developers are immediately familiar with our code.Do include documentation of your contribution: Documentation starts with clear comments in the source code, but can also include readme files and other markdown pages (in the /docs folder) that will show up automatically on this website.Do internationalize your code: Our modules include strings in three languages (English, French and German), rather than single-language hard-coded strings. Please include at least an English language file in your contributions (which we can then translate in the PR process). ","version":"Next","tagName":"h2"},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/dokku/docs/getting-started","content":"","keywords":"","version":"Next"},{"title":"Browse sample applications and components​","type":1,"pageTitle":"Getting Started","url":"/dokku/docs/getting-started#browse-sample-applications-and-components","content":" If you are new to Sinequa and just want to see what is on the menu, you can start by browsing our list of sample applications.  If you want to discover new functionalities that may be useful for an existing application, have a look at the Components and Analytics libraries. You can also test most of the SBA Framework's components in the Vanilla Builder application.  Sinequa also comes with pre-packaged apps (that are deployed out-of-the-box), and you can test these apps directly with your own data (See prepackaged applications below).  ","version":"Next","tagName":"h2"},{"title":"Create a first application​","type":1,"pageTitle":"Getting Started","url":"/dokku/docs/getting-started#create-a-first-application","content":" ","version":"Next","tagName":"h2"},{"title":"Vanilla Builder​","type":1,"pageTitle":"Getting Started","url":"/dokku/docs/getting-started#vanilla-builder","content":" A good way to get started that does not require any developer skills is to use the Vanilla Builder application. Vanilla Builder is a no-code tool that lets administrators customize an application by drag-and-dropping components and editing their settings, appearance and behavior.  When the customization is complete, it can be exported as a standalone application that can be deployed independently on Sinequa.  Vanilla Builder is also a good way to discover and try out a wide range of components available in the SBA Framework without having to study the documentation and API.  ","version":"Next","tagName":"h3"},{"title":"Pre-packaged applications​","type":1,"pageTitle":"Getting Started","url":"/dokku/docs/getting-started#pre-packaged-applications","content":" Another common way to get started is to copy one of the pre-packaged apps available in the Sinequa administration:    However, please note the following warnings:  warning Copying the &quot;app&quot; object exposes a new application at the URL &lt;sinequa&gt;/app/&lt;app-name&gt;, but it does not copy the application's workspace, which contains the source code and build artifacts for the app. The new app will still be referencing the original workspace (See server configuration).  warning While it is possible to copy the workspace as well, you should carefully consider Version Control and Continuous Integration for the long-term maintainability of your project (See our Version Control and Updates guides).  note To recap: Copying the &quot;app&quot; object is fine if you just want to customize the application's configuration and web services. However, if you copy the workspace and want to edit the source code, you must have a clear understanding of how to develop an application, which you can learn more about in the next section.  ","version":"Next","tagName":"h3"},{"title":"Develop an application​","type":1,"pageTitle":"Getting Started","url":"/dokku/docs/getting-started#develop-an-application","content":" SBA developers should be familiar with the following topics:  General web development (HTML, CSS and JavaScript languages)The basics of the Angular web development framework (i.e., by completing an online tutorial)  After ensuring an understanding of these topics, new developers should use this website to become familiar with Sinequa-specific concepts. In particular:  The tutorial is a good way to learn about the main Sinequa services and components. It can be completed in a few hours.The architecture, development and version control guides are important first reads as well.The tips &amp; tricks can also answer many common beginner questions.  BUT, if you are a learn-by-doing person who doesn't read documentation if they can avoid it and you really just want to get started now, then let's go:  Clone the repository git clone https://github.com/sinequa/sba-angular.git cd sba-angular Install dependencies with npm npm install Build Vanilla Search and test it using our demo server (Sinequa account required): npm run start:vanilla This commands is shorthand for ng serve vanilla-search --ssl=true --proxy-config=./projects/vanilla-search/src/proxy.conf.json. It builds the application then serves it on your computer at https://localhost:4200. The proxy file specifies the URL of the Sinequa server (in this case, our demo server)  ","version":"Next","tagName":"h2"},{"title":"Maintain and monitor an existing application​","type":1,"pageTitle":"Getting Started","url":"/dokku/docs/getting-started#maintain-and-monitor-an-existing-application","content":" If you manage an existing application, you typically have to perform different tasks:  Monitor the usage of the application (e.g., evaluate the adoption, the relevance of search results, the performance of the engine, read user feedback, etc.). Fortunately, there's an app for that! The Usage Analytics application displays all this information within a set of dashboards. info The SBA standard components and applications have a built-in audit system that records all relevant user actions into logs. These logs can be periodically indexed in an audit index. The Usage Analytics application computes metrics directly based on this data. Modify the application's configuration. Applications can be customized without changing their source code (to some extent). There are three possible ways to achieve this: Customizing the configuration of the application's web services, in particular the query web service. This approach is documented in the server configuration guide.Customizing the application's JSON configuration. Each application has a set of internal settings that can be overridden by adding properties in the &quot;Customization (JSON)&quot; tab of the application. This typically includes the list of facets, metadata, and preview highlights, and it allows certain functionalities to be turned on or off (e.g., baskets, saved queries, etc.).Customizing the application's UI with Vanilla Builder. Note that modifying the application in Vanilla Builder does not directly modify its source code. It modifies a JSON configuration describing the layout and configuration of each component. This configuration is persisted in the administrator's User Settings, but it can also be downloaded and reopened later for further customization. Implement changes in the application code. Making changes in the application's source code is more consequential than changes in the configuration because there are multiple factors to consider: The versioning of the code (see version control guide)The process of deployment (see deployment guide)And most importantly: any change that you apply may eventually conflict with a future update and/or might necessitate future maintenance (see the next point). Update the SBA Framework. Sinequa regularly releases new versions of the libraries and applications. These updates often introduce breaking changes: Library upgrades (Angular, Bootstrap, RxJS, D3, etc.) often introduce breaking changes. So when Sinequa upgrades these libraries, the entire codebase is migrated accordingly.As the SBA Framework evolves, bugs are fixed, features are added, and components &amp; applications are refactored. These changes can be in direct conflict with how you use these components or how you customized these components. warning If your application is heavily customized, these updates will probably be difficult. If your customization makes use of, say, Bootstrap, you will have to follow the relevant guide from Bootstrap to migrate your code. Carefully read the updates guide to learn how to manage this situation and how to be prepared by adopting development and version control best practices. note To recap: You must take ownership of anything you customize. This includes taking responsibility for fixing conflicts with future updates and potentially migrating your code when libraries are upgraded. ","version":"Next","tagName":"h2"},{"title":"Managing updates of the SBA framework","type":0,"sectionRef":"#","url":"/dokku/docs/guides/updates","content":"","keywords":"","version":"Next"},{"title":"Merge conflicts​","type":1,"pageTitle":"Managing updates of the SBA framework","url":"/dokku/docs/guides/updates#merge-conflicts","content":" ","version":"Next","tagName":"h2"},{"title":"Conflicts are good!​","type":1,"pageTitle":"Managing updates of the SBA framework","url":"/dokku/docs/guides/updates#conflicts-are-good","content":" At first, merge conflicts look like they should be avoided at all costs. But conflicts are not a bad thing. They are a natural consequence of the fact that multiple developers work in parallel on the same codebase. Conflicts are a way for Git to ask you to review the changes and decide which version to keep.  Git actually resolves most conflicts automatically when it can. The remaining conflicts are the ones that require your attention.  ","version":"Next","tagName":"h3"},{"title":"Size matters​","type":1,"pageTitle":"Managing updates of the SBA framework","url":"/dokku/docs/guides/updates#size-matters","content":" When applying a small change to a component (i.e., changing only a few lines of code and preserving its general usage), it is generally fine to modify the component directly, even if it is part of the Sinequa libraries. The update process might generate conflicts, but they will be easy to resolve.  When applying a large change to a component, the update process will generate conflicts that are more difficult to resolve. In this case, it is better to copy or extend the component. This way, you fully own your code and will not face conflicts during updates (although you may still have to migrate your code).  The same principle applies to the sample applications. If you want to make a small change to an application but leave the code ownership to Sinequa, you should modify the application directly. Conversely, if your application diverges too much from the original sample app, then you should take full ownership of the application by making a copy and editing it.  ","version":"Next","tagName":"h3"},{"title":"Minimize conflicts​","type":1,"pageTitle":"Managing updates of the SBA framework","url":"/dokku/docs/guides/updates#minimize-conflicts","content":" Conflicts occur when Sinequa makes changes to files that you have also modified. To prevent conflicts, you can:  Avoid modifying the SBA framework files when possible: Choose to use the input parameters and templates of the Sinequa components when they exist.Make a copy of a file and modify the copy. (The drawback of this approach is that your copy will not be updated when the original file is updated! So this approach can actually make the update process harder.)Alternatively, extend a component or a service by creating a new class that inherits from the original class. (The benefit here is that you can override the methods that you want to customize, but the underlying code is still managed by Sinequa and benefits from updates.)Contact us or contribute if you think that your changes should be included in the SBA framework. We are open to contributions! Avoid cosmetic changes like changing the indentation or the order of the properties in a JSON file. These changes are not relevant, and they will generate conflicts for no good reason. Note that these changes can sometimes be caused by your IDE or by a linter.  ","version":"Next","tagName":"h3"},{"title":"Resolve conflicts​","type":1,"pageTitle":"Managing updates of the SBA framework","url":"/dokku/docs/guides/updates#resolve-conflicts","content":" When a conflict occurs during a git pull or git merge command, Git will tell you which files are in conflict.  In Visual Studio Code, the conflicting files are highlighted, and the conflicting lines of code are marked with a red background. You can click on the &quot;Accept Incoming Change&quot; or &quot;Accept Current Change&quot; buttons to resolve the conflict.    After fixing all the conflicts, you can commit your changes and continue the merge process with git merge --continue. In a tool like GitHub Desktop, this process is even simpler: you just have to click on the &quot;Merge&quot; button and then push the fixed version to your main repository.  ","version":"Next","tagName":"h3"},{"title":"Migrate your code​","type":1,"pageTitle":"Managing updates of the SBA framework","url":"/dokku/docs/guides/updates#migrate-your-code","content":" ","version":"Next","tagName":"h2"},{"title":"Library migrations​","type":1,"pageTitle":"Managing updates of the SBA framework","url":"/dokku/docs/guides/updates#library-migrations","content":" When a library is upgraded, it may introduce breaking changes. In this case, you should follow the migration guide of the library. For example:  Angular update guideBootstrap migration guideRxJS change list  ","version":"Next","tagName":"h3"},{"title":"SBA migrations​","type":1,"pageTitle":"Managing updates of the SBA framework","url":"/dokku/docs/guides/updates#sba-migrations","content":" When a new version of the SBA framework is released, we describe the changes in the release notes. You should read these notes to understand what has changed and what you need to do to migrate your code. When migrating from an older version, you should read all the release notes published since the release of the version you are currently using.  The sample applications of the SBA framework are good reference points to see how components are used. If a particular component generates errors after an update, you can check how it is used in the sample applications.  ","version":"Next","tagName":"h3"},{"title":"Compile-time errors​","type":1,"pageTitle":"Managing updates of the SBA framework","url":"/dokku/docs/guides/updates#compile-time-errors","content":" A single breaking change can generate an overwhelming chain reaction of compile-time errors. This typically happens when an Angular component breaks an Angular module, which in turns breaks all the components that depend on that module (and so on). The errors might look like Can't bind to X since it isn't a known property of Y. But these errors are often misleading, and a good strategy to find the root cause is to look for the first error in the list.    ","version":"Next","tagName":"h3"},{"title":"Runtime errors​","type":1,"pageTitle":"Managing updates of the SBA framework","url":"/dokku/docs/guides/updates#runtime-errors","content":" Similarly, some runtime errors can fill your browser console with a cascade of errors. Errors often read Cannot read property 'X' of undefined. But again, this is a generic error message that can be caused by many different things.  A good approach is to use ng serve (or ng build --configuration=development) so that your browser can provide you with useful debugging information. Then, look at the first error in the list, and click on the first item in the stack trace that belongs to your code base (as opposed to internal Angular methods). This will give you two important pieces of information:  Which component or service to look at in your IDE.Which variable was undefined (or more generally, what was the state that caused the error). From there, you can investigate further and determine what caused this state.  After an update, it's possible that a component can now expect a mandatory input parameter that was not required previously. Compilation does not catch this type of error, but the runtime will.   ","version":"Next","tagName":"h3"},{"title":"Libraries documentation","type":0,"sectionRef":"#","url":"/dokku/docs/libraries","content":"Libraries documentation This section provides documentation for the libraries of the SBA Framework.","keywords":"","version":"Next"},{"title":"Version Control","type":0,"sectionRef":"#","url":"/dokku/docs/guides/version-control","content":"","keywords":"","version":"Next"},{"title":"Download the standard SBA workspace​","type":1,"pageTitle":"Version Control","url":"/dokku/docs/guides/version-control#download-the-standard-sba-workspace","content":" Simply run on your local computer:  git clone https://github.com/sinequa/sba-angular.git my-project cd my-project     The Git repository contains the source code of the SBA Framework, but the dependencies (i.e., the node modules) are not included. You need to install them with:  npm install   (Note that the list of dependencies is defined in the package.json file, and the exact library versions are defined in the package-lock.json file.)  ","version":"Next","tagName":"h2"},{"title":"Track changes in the code​","type":1,"pageTitle":"Version Control","url":"/dokku/docs/guides/version-control#track-changes-in-the-code","content":" View your modified files with:  git status   A tool like GitHub Desktop can also help you visualize the changes in your code.  Commit your changes (to your local clone of the repository) with:  git add . git commit -m &quot;My commit message&quot;     ","version":"Next","tagName":"h2"},{"title":"Work collaboratively with other developers​","type":1,"pageTitle":"Version Control","url":"/dokku/docs/guides/version-control#work-collaboratively-with-other-developers","content":" When working collaboratively, you need a central repository to host the code. This can be a private repository on an internal server or a public repository on a service like Github.  warning If you cloned the official SBA repository, your local clone is configured to push to that repository. But obviously, you do not have write access to it! You need to add a new remote repository that you own and have write access to.  For example:  git remote add internal https://my-internal-git-server/my-project.git   Then you can push your changes to that repository with:  git push internal master   Then, other developers can clone your repository with:  git clone https://my-internal-git-server/my-project.git     Whenever new changes are pushed to the central repository, you can pull them with:  git pull internal master     git pull is actually a shortcut for git fetch (which downloads the changes) and git merge (which merges the changes into your local branch). If there are conflicts, the merge process will ask you to resolve them manually.  warning Note that after a git pull, the project dependencies might have been updated, so you need to run npm install again.  ","version":"Next","tagName":"h2"},{"title":"Review and approve changes before they are deployed​","type":1,"pageTitle":"Version Control","url":"/dokku/docs/guides/version-control#review-and-approve-changes-before-they-are-deployed","content":" A good habit is working on a separate branch for each feature or bug fix. This allows you to review the changes before they are merged into the master branch.  To create a new branch for a special feature, run:  git checkout -b my-feature   Then, commit your changes as usual.  When you are ready to merge your changes into the master branch, push your branch to the central repository with:  git push internal my-feature   Then in the central repository, create a Pull Request to merge your branch into the master branch. This will trigger a code review process, and the changes will only be merged into the master branch when they are approved.    After that, the branch can be deleted, and all developers can pull the changes with a simple git pull.    ","version":"Next","tagName":"h2"},{"title":"Update the code with new versions of the SBA Framework​","type":1,"pageTitle":"Version Control","url":"/dokku/docs/guides/version-control#update-the-code-with-new-versions-of-the-sba-framework","content":" The SBA repository is updated regularly. The changes might conflict with your own code, so the update process can be complicated (See the Updates guide).  In the simple case when there are no conflicts, you can run:  # Fetch the latest changes from the official SBA repository (your &quot;origin&quot; remote) git fetch origin # Merge the changes into your local &quot;master&quot; branch git merge origin/master   Now your local master branch has all the commits from the official SBA repository AND all the commits from your project.    When there are conflicts (i.e., when the same lines of code were modified in both repositories), Git points them out, and you will need to resolve them manually (i.e., choose which change to keep, which change to discard, or a mix of both).  ","version":"Next","tagName":"h2"},{"title":"Deploy the code on a server​","type":1,"pageTitle":"Version Control","url":"/dokku/docs/guides/version-control#deploy-the-code-on-a-server","content":" A simple strategy to deploy your application on a Sinequa server is to clone the repository in the Sinequa data folder, run npm install and then build the application with npm run buildvanilla. (This command can be executed from the administration interface.) See the deployment guide for more details.    While this process works, it has some drawbacks:  It forces you to install the node modules on the server (requiring Internet access and various tools)It requires you to build the application on the server (which can be slow and consume resources)It cannot be fully automated  ","version":"Next","tagName":"h2"},{"title":"Integrate with a Continuous Integration system​","type":1,"pageTitle":"Version Control","url":"/dokku/docs/guides/version-control#integrate-with-a-continuous-integration-system","content":" A Continuous Integration (CI) system is a tool that automates the build and deployment process. It can be used to build and deploy your application on a Sinequa server and also to run automated tests and perform other tasks. It can be configured to run automatically when new commits are pushed to the central repository.    Your CI system must have access to the Sinequa server. This could be done by configuring the Sinequa server to allow remote access (e.g., via PowerShell Remoting). Alternatively, the CI system could be hosted on the same server as Sinequa. ","version":"Next","tagName":"h2"},{"title":"SBA Development","type":0,"sectionRef":"#","url":"/dokku/docs/guides/development","content":"","keywords":"","version":"Next"},{"title":"Prerequisites​","type":1,"pageTitle":"SBA Development","url":"/dokku/docs/guides/development#prerequisites","content":" SBA developers should be familiar with Angular and Bootstrap. Specific knowledge about Sinequa is not strictly required, although it is useful to understand where the data comes from, how it can be customized and what additional features can be enabled through custom APIs and plug-ins.  We recommend reading the architecture guide and completing the tutorial before starting development.  ","version":"Next","tagName":"h2"},{"title":"Development environment​","type":1,"pageTitle":"SBA Development","url":"/dokku/docs/guides/development#development-environment","content":" An SBA development environment requires the following tools and accesses:  NodeJS: Node and npm (Node Package Manager) are required to download and manage the dependencies of the project (like the Angular library). ⚠️ To pick the right version, check the Angular documentation and compare it with the version of Angular found in your package.json.Visual Studio Code: The recommended IDE (Integrated Development Environment) for Angular development.Git: The version control system allowing you to sync your workspace with a Git or Github repository to work collaboratively and deploy the project on a server.Access to a Sinequa server over HTTP(S) and an account on this server with access to some data (for testing purposes).An Internet connection to download 3rd party libraries from the Internet via npm (Node Package Manager). Note that this is not a strict requirement since these libraries could be manually copied into the environment.  warning It can be tempting to use the Sinequa server as the development environment and/or use the administration interface to make changes to the source code, but this is not recommended. The preference is to use a local development environment (on your own computer) and deploy your application on the Sinequa server only when it is ready for production.  ","version":"Next","tagName":"h2"},{"title":"Workspace​","type":1,"pageTitle":"SBA Development","url":"/dokku/docs/guides/development#workspace","content":" The workspace is the directory containing the source code of your application. The dependencies of your project are declared in the package.json file at the root of the workspace. These dependencies are installed by running npm install (they are stored in the node_modules folder). The workspace also contains the configuration files for Angular (angular.json) and TypeScript (tsconfig.json).  There are two ways to create a workspace with different pros and cons:  ","version":"Next","tagName":"h2"},{"title":"Use the standard workspace​","type":1,"pageTitle":"SBA Development","url":"/dokku/docs/guides/development#use-the-standard-workspace","content":" The SBA Framework is developed as an open-source project on Github. New versions of the SBA framework are published at the same time as the releases of the Sinequa product. You can clone the repository and use the standard workspace as a starting point for your own project.  git clone https://github.com/sinequa/sba-angular.git my-project cd my-project   Updating the workspace is as simple as pulling the latest version from Github, although you may have to resolve some conflicts between your own code and the new version of the workspace (See Updates).  The standard workspace contains the main Sinequa libraries (Core, Components and Analytics) and sample applications (Vanilla Search and Pepper).  You can either modify an existing application directly or create a new one (and modify the angular.json accordingly):  Modify an existing application directly if you do not intend to customize it significantly. The benefit is that you can easily update the application by pulling the latest version of the workspace from Github with only a small amount of conflicts to manage.Create a new application if you want to start from scratch or if you want to deviate significantly from a sample application. You will not have any conflicts to resolve during updates, but you will need to manually update your application to benefit from the latest features of the SBA Framework.  Using the standard workspace allows you to customize anything you want, including the low-level libraries. Having access to the source code of the libraries is also useful to help you understand how they work and how to write your own components.  warning The standard workspace is also packaged as a .zip file in the Sinequa product. However, if you use this file, you will not be able to update the workspace by pulling the latest version from Github!  ","version":"Next","tagName":"h3"},{"title":"Create a new workspace and install the npm packages​","type":1,"pageTitle":"SBA Development","url":"/dokku/docs/guides/development#create-a-new-workspace-and-install-the-npm-packages","content":" You can also create a new workspace from scratch and include only the npm packages you need. In this case, you must install the SBA Framework libraries in your project via npm.  # Create a new Angular workspace ng new my-project cd my-project # Install the SBA Framework libraries npm install @sinequa/core @sinequa/components @sinequa/analytics --legacy-peer-deps   warning This last command requires the --legacy-peer-deps flag to prevent npm from installing the peer dependencies automatically. We recommend installing the peer dependencies manually on a case-by-case basis. An alternative approach is to copy the list of dependencies from the standard workspace's package.json file.  info With this approach, updating the SBA libraries is done via npm using the npm update @sinequa/&lt;library&gt; command. The Sinequa npm packages are published at same time as the Sinequa product.  ","version":"Next","tagName":"h3"},{"title":"Building the libraries​","type":1,"pageTitle":"SBA Development","url":"/dokku/docs/guides/development#building-the-libraries","content":" When using the standard workspace (see above), it is possible to build the SBA libraries. This step is NOT required because applications can reference the libraries' source code directly rather than the compiled code.  npm run buildcore npm run buildcomponents npm run buildanalytics   The buildcore, buildcomponents and buildanalytics scripts are defined in the package.json. The builds are generated in the /dist folder at the root of your workspace.  info We recommend npm run &lt;command&gt; vs ng &lt;command&gt;: This guarantees that you are using the same version of Angular as the one defined in the package.json file.  ","version":"Next","tagName":"h2"},{"title":"Building an app​","type":1,"pageTitle":"SBA Development","url":"/dokku/docs/guides/development#building-an-app","content":" Building an application is similar to building a library:  npm run buildvanilla   This script runs the ng build command (see the package.json), which generates a build artifact in the dist folder. This build is needed to deploy the application on a server (See the deployment guide).  ","version":"Next","tagName":"h2"},{"title":"Testing an app​","type":1,"pageTitle":"SBA Development","url":"/dokku/docs/guides/development#testing-an-app","content":" In order to test the application, developers generally use the ng serve command, which performs 3 tasks:  builds the application in development mode (like ng build --configuration=development would)watches for changes in your code and updates the build immediately (like the --watch flag would)starts a local web server and serves the application on http://localhost:4200.  This command is also defined in the package.json file and can be run with:  npm run start:vanilla   The start:vanilla script contains options that can be customized based on your environment:  ng serve vanilla-search --ssl=true --proxy-config=./projects/vanilla-search/src/proxy.conf.json   ssl=true serves the app with HTTPS (using a self-signed certificate). This option might be necessary depending on the authentication method used by the Sinequa server.proxy-config configures a proxy to redirect HTTP requests to the Sinequa server (See below for more details)  ","version":"Next","tagName":"h2"},{"title":"Connecting to the Sinequa server​","type":1,"pageTitle":"SBA Development","url":"/dokku/docs/guides/development#connecting-to-the-sinequa-server","content":" ","version":"Next","tagName":"h2"},{"title":"TL;DR​","type":1,"pageTitle":"SBA Development","url":"/dokku/docs/guides/development#tldr","content":" Connect your app to the Sinequa server by:  Specifying the app property in the StartConfig object of the app.module.ts file. (Also specify the name of your webapp's login provider if any).Specifying the url of the Sinequa server in the proxy.conf.json.  ","version":"Next","tagName":"h3"},{"title":"Basic configuration​","type":1,"pageTitle":"SBA Development","url":"/dokku/docs/guides/development#basic-configuration","content":" An app communicates with Sinequa via its REST API (See architecture). But how does the app know where to find the Sinequa server?  The standard workspace contains a StartConfig object in the app.module.ts file of each application:  // Initialization of @sinequa/core export const startConfig: StartConfig = { app: &quot;training&quot;, production: environment.production, autoSAMLProvider: environment.autoSAMLProvider, auditEnabled: true };   This object contains the following optional properties:  url: The URL of the Sinequa server. If not specified, the app will use the URL of the host server.app: The name of the app on the Sinequa server. If not specified, the app will be inferred from the URL (/app/&lt;appname&gt;)autoSAMLProvider or autoOAuthProvider: The name of the login provider on the Sinequa server (if any). If not specified, the app attempts to retrieve it from the server. See Login methods for more details.  When building your app for deployment on a Sinequa server, it should be fine to omit the above properties.  ","version":"Next","tagName":"h3"},{"title":"Development configuration​","type":1,"pageTitle":"SBA Development","url":"/dokku/docs/guides/development#development-configuration","content":" warning During development, the ng serve command serves your app on http://localhost:4200, which is NOT the Sinequa server and does NOT contain the name of the app!  This is why we recommend defining the app and login providers (if any). For the url, there are two possibilities:  If the url property is specified in the StartConfig, your browser URL (http://localhost:4200) and Sinequa URL will NOT match, and you will run into CORS issues. You can fix these issues by configuring https://localhost:4200 as a permitted origin in Sinequa (See CORS and WebApp configuration).Alternatively, you can define a proxy configuration (See below) so that your browser URL and Sinequa URL (seemingly) share the same origin.  ","version":"Next","tagName":"h3"},{"title":"Proxy​","type":1,"pageTitle":"SBA Development","url":"/dokku/docs/guides/development#proxy","content":" The --proxy-config option makes the local server redirect HTTP requests from http://localhost:4200 to the Sinequa server. From the point of view of the browser, the requests are sent to the same origin, so there are no CORS issues.  The proxy configuration is a simple JSON file passed as an argument to the ng serve command.  { &quot;context&quot;: [ &quot;/api&quot;, &quot;/xdownload&quot;, &quot;/saml/redirect&quot;, &quot;/r&quot; ], &quot;target&quot;: &quot;https://vm-su-sba.sinequa.com:13343&quot;, &quot;secure&quot;: false, &quot;changeOrigin&quot;: true }   The context property is an array of paths that will be redirected to the target URL. The secure property indicates whether to validate the SSL certificate of the target server. The changeOrigin property indicates whether the origin of the request should be changed to the target URL.  See the Angular and Webpack documentation for more details. ","version":"Next","tagName":"h3"},{"title":"Analytics library","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/analytics","content":"","keywords":"","version":"Next"},{"title":"Building the library​","type":1,"pageTitle":"Analytics library","url":"/dokku/docs/libraries/analytics#building-the-library","content":" At the root of the workspace, run the following command:  npm run buildanalytics   The build takes a few minutes to complete and produces a folder dist/analytics/. Note that this folder is aliased as @sinequa/analytics, in the tsconfig.json file. This means that all the imports of code of this library from the applications look like:  import { ... } from '@sinequa/analytics/....';   ","version":"Next","tagName":"h2"},{"title":"Modules​","type":1,"pageTitle":"Analytics library","url":"/dokku/docs/libraries/analytics#modules","content":" This library contains several sub-libraries (or &quot;secondary endpoints&quot;). Each sub-library generally includes:  One or more Angular modules. Generally, only one module is used. If the library depends on the Bootstrap library, the module is packaged within a bootstrap/ subfolder and the module is prefixed by Bs (eg. BsSearchModule). Zero or one Angular service. Services are where the intelligence of the application is concentrated. Components generally use a service for the complex data processing tasks and the interactions with @sinequa/core and the web services (eg. SearchService). Services are always designed to be component-agnostic, and therefore do not depend on the Bootstrap or Material Design libraries. When a service depends on a component type, it is actually injected by dependency injection. Various Angular components, directives and pipes exported by the Angular module, and tied together by the service. Zero or one stylesheet, to be imported in your application's global stylesheet. Internationalization &quot;messages&quot;, which are simple Typescript files exporting key/value pairs of text allowing to switch between various languages in your app (See Internationalization).  See the tutorial introduction for additional information on the modules' structure and how to get started with them.  Below is list of documented modules. ","version":"Next","tagName":"h2"},{"title":"Server configuration","type":0,"sectionRef":"#","url":"/dokku/docs/guides/server-config","content":"","keywords":"","version":"Next"},{"title":"Minimum configuration​","type":1,"pageTitle":"Server configuration","url":"/dokku/docs/guides/server-config#minimum-configuration","content":" The minimum configuration required to get started is an App and a Query web service.  To create an App configuration, in the administration:  Go to Search-based applications &gt; Apps,In Apps, click New Angular app, give it a name then click Ok. You will be redirected to the configuration page of the new App. It is also pre-filled with the default web services.If you want to use a different Query web service other than the default one, click Edit, and in the list of Queries, choose your web service and save.    'New Angular app' action in Apps  At this point, your Sinequa server can be used to develop an SBA, and you can start the development guide or spend more time reading the documentation below to learn more about fully configuring the server.  ","version":"Next","tagName":"h2"},{"title":"Apps​","type":1,"pageTitle":"Server configuration","url":"/dokku/docs/guides/server-config#apps","content":" In order to work, an SBA needs a named App configuration to exist on the Sinequa server. This configuration is the entry point which references all the Web Services that the SBA will use. The App can also contain configuration (in JSON format) which may be passed to the Angular application. Finally, the App can be restricted to specific Users and Groups, rather than being open to all.  The list of Apps can be found in the administration interface under Search-Based Applications &gt; Apps:    List of applications in the Sinequa server administration  In this form, a new App may be created by clicking on the New Angular App button.  The name of the App is important, as it will be used by the Angular application to request data via the Web Services. The configuration of an App specifies the list of Web Services available for this App. If the App is deployed on the Sinequa server, it needs to point to an Angular workspace, which is shown via the property Workspace application.    App configuration - General tab  In the Customization (JSON) tab of the App configuration, it is possible to write data (in JSON syntax), which will be passed to the Angular app on initialization. The benefit of using this field (rather than just writing the data in the app source code) is that this data may change without having to recompile the Angular app. For example, if you specify a list of widgets to be displayed, you will only need to modify this field and refresh the page to visualize the difference.  The underlying Monaco editor can verify that your JSON is valid and in any case, Sinequa ES verifies the JSON validity when saving the App configuration and notifies you should the JSON be not valid.    App configuration - Customization (JSON) tab  App configuration - Customization (JSON) tab - when the JSON is not valid  Please refer to Tips &amp; tricks - Server-side-configuration for an example of how to use the JSON data to customize vanilla-search.  In the Advanced tab of the App configuration, it is possible to restrict the availability of the app to certain users and groups. You can also assign the current App configuration as the default Angular app for a user or a group. This default Angular app is used when the assigned user navigates on the Sinequa server without specifying the app that they want to use.  App configuration - Advanced tab  ","version":"Next","tagName":"h2"},{"title":"Web Services​","type":1,"pageTitle":"Server configuration","url":"/dokku/docs/guides/server-config#web-services","content":" The Web Services configurations allow you to configure the behaviour of certain endpoints of the REST API, which allows:  To minimize the size and complexity of the requests sent to the serverTo prevent exposing sensitive or internal parameters and settings to the client side, which could be used maliciously or impact negatively the overall performance of Sinequa ES.  The list of Web Services can be found in the administration interface under Search-Base Applications &gt; Web Services  List of configurable Web Services in the Sinequa server administration  ","version":"Next","tagName":"h2"},{"title":"Query web service (default: _query)​","type":1,"pageTitle":"Server configuration","url":"/dokku/docs/guides/server-config#query-web-service-default-_query","content":" The Query web service is one of the most integrated and sophisticated web service of Sinequa. It is at the heart of our application samples, Vanilla Search and Pepper. This service allows to build complex search queries (incl. tabs, facet selection, advanced search, etc.) to retrieve data from the Sinequa indexes.  The General tab of the Query web service configuration allows the configuration of these key parameters:  Index list: The list of indexes which this web service may query.QueryPlugin: A server-side plugin (written in C#), which lets you customize the search queries, or post-process the responses.Aggregations: A list of Aggregations. An aggregation is a short-list of metadata computed for the given query. For example, if you search for &quot;automobile manufacturer&quot;, the Company aggregation could contain entries like &quot;Volkswagen&quot;, &quot;BMW&quot;, &quot;Tesla&quot;, etc.  Query Web Service configuration - General tab  The Results Page tab of the Query web service configuration allows to configure these key parameters:  Tab Search: Specifies a list of tabs to search in a specific subset of the corpus. Tabs filter on a single column of the index (e.g. the format of document, name of the data source, etc.). The Angular application may select a tab by setting query.tab = '&lt;tab name&gt;'.Search scopes: A &quot;scope&quot; can restrict the search to a specific subset of the corpus, with SQL rules. The Angular application may select a scope by setting query.scope = '&lt;scope name&gt;'. Unlike tabs, it is not possible to compute the number of documents for each scope with one query (since each scope has a specific ruleset).Relevant Extracts: The relevant extracts are key passages and sentences found in the searched documents, which are then used to compute a short summary typically displayed in the search results.  Example of relevant extracts  The Search settings tab of the Query web service configuration allows to configure in fine detail the query sent to the Sinequa engine. In particular:  Analysis of the user query: Language detection &amp; dictionariesIntent detectionEntity detection Custom SQL: Custom columns (SELECT)Custom filters (WHERE)Duplicate removal (GROUP BY)Sorting options (ORDER BY) Other options: Calculation of most relevant &quot;Concepts&quot;Similar document search settings  The Relevance tab of the Query web service configuration allows to configure in fine detail the relevance calculations performed by the Sinequa engine. In particular:  The statistical part of the relevance (global score formula, words &amp; forms weighting)The freshness score (favoring most recent content)The part name weights (favoring specific parts of the content)The class weights (favoring specific classes of content)The relevance transforms (allowing for custom forms of relevance, such as popularity, ratings or importance)The relevance feedback model (allowing to account for user feedback)  The Advanced tab of the Query web service configuration allows to configure meaningful aliases and labels for specific columns. This is useful to avoid exposing the bare structure of the index to front-end developers. Instead, developers will see and use explicit variable names, which are used consistently across the different web services.  Example of query aliases  ","version":"Next","tagName":"h3"},{"title":"Preview web service (default: _preview)​","type":1,"pageTitle":"Server configuration","url":"/dokku/docs/guides/server-config#preview-web-service-default-_preview","content":" The Preview web service form configures the access to document HTML previews (stored in Sinequa document cache). It has two settings:  .css file: Contains one (or more) CSS file names that are injected in the HTML previews as &lt;link&gt; elements, either with a relative path (relative to the URL of the application), or an absolute URL. The default SBA includes a preview/preview.scss file which is built as /preview.css. The default setting is therefore preview.css..js file: Contains one (or more) JS file names that are injected in the HTML previews as &lt;script&gt; elements, either with a relative path (relative to the URL of the application), or an absolute URL. The default setting is preview/preview.js. This is packaged by default in the SBA workspace. It is necessary to let the SBA interact with the content of the preview.Highlights to display: Categories to be &quot;highlighted&quot; in the preview. For example, relevant extracts are highlighted by wrapping &lt;span&gt; tags around the relevant text. The visual highlight itself is effectively done by the aforementioned preview.css file (for example with a CSS rule of the type background-color: yellow;).  Example of preview configuration  Example of a highlighted HTML (each colored passage corresponds to a &lt;span&gt; element with a specific highlighted entity class)  ","version":"Next","tagName":"h3"},{"title":"Labels web service (default: _labels)​","type":1,"pageTitle":"Server configuration","url":"/dokku/docs/guides/server-config#labels-web-service-default-_labels","content":" The Labels web service form allows to configure the columns of the index where tags are stored.Labels may be private (specific to each user) or public (visible to everyone). Both options may be enabled simultaneously.  It is possible to restrict specific actions (Label creation, label modification) to specific populations of users.  This service also exposes an auto-complete feature to easily search and select a specific label.  Example of labels configuration  ","version":"Next","tagName":"h3"},{"title":"Auto-complete web service (default: _autocomplete)​","type":1,"pageTitle":"Server configuration","url":"/dokku/docs/guides/server-config#auto-complete-web-service-default-_autocomplete","content":" The auto-complete web service essentially lists suggest queries that provide suggestions when the user types some text in a form. Refer to the documentation on suggest queries for more information.  The last option &quot;Match the search terms anywhere in field values&quot; is useful for the facet component's search bar: A search for &quot;York&quot; will match both &quot;New York&quot; and &quot;Yorkshire&quot; values. However this option comes incurs a performance penalty, so it should be used only when necessary.  Example of auto-complete configuration  ","version":"Next","tagName":"h3"},{"title":"Export web service (default: _queryexport)​","type":1,"pageTitle":"Server configuration","url":"/dokku/docs/guides/server-config#export-web-service-default-_queryexport","content":" The export web service specifies the list of columns and maximum number of lines (records) to be exported when a user requests an export of the results list. For obvious security and performance reasons, these parameters are not exposed directly to the user themselves.  Note that this web service is always used with the query web service. The latter provides the query configuration to retrieve the documents that user sees in the SBA. Therefore, the number of exported records is also limited by the configuration of the associated query web service. In particular, the query configuration can limit the maximum number of records per index that can be returned by the query.  You need to verify such options in the query web service when you change the maximum number of lines in the export web service.  Example of export configuration  ","version":"Next","tagName":"h3"},{"title":"Sponsored links service (default: _sponsoredlinks)​","type":1,"pageTitle":"Server configuration","url":"/dokku/docs/guides/server-config#sponsored-links-service-default-_sponsoredlinks","content":" The configuration of the sponsored links specifies the number of links returned by the API. Refer to the documentation on sponsored links for more information.  Example of Sponsored links configuration  ","version":"Next","tagName":"h3"},{"title":"Workspaces​","type":1,"pageTitle":"Server configuration","url":"/dokku/docs/guides/server-config#workspaces","content":" The third part of the server-side configuration that powers the SBA framework is the Workspaces section. &quot;Workspaces&quot; literally refer to Angular workspaces, (which is what this Github repository contains).  The SBA Framework includes an Angular workspace available on Github, which is also shipped with Sinequa releases as a zip file. This archive can be unzipped, downloaded and uploaded on the Sinequa server via the Sinequa administration.  The workspaces are located in &lt;Sinequa data folder&gt;\\sba, which is where Sinequa looks for them, to display their content in the administration and to serve the built applications that they contain. This is also where you would deploy your application for Sinequa to serve it (via an upload, or a git pull -- See Workspace).  The Workspaces section displays the workspaces under &lt;Sinequa data folder&gt;\\sba. It is located in the administration under Search-Based Applications &gt; Workspaces:  Angular workspaces in the administration  At the start, there will be no workspace pre-loaded in Sinequa ES. You can:  either load the default Sinequa Angular workspace from a default zip provided with your Sinequa release,or clone the Github repository in &lt;Sinequa data folder&gt;/sba (See Workspace),or import your own Angular workspace, noting that only multi-project Angular workspaces are supported (cf. multi-project Angular workspace for more information about Angular workspace type).  ","version":"Next","tagName":"h2"},{"title":"Unzip the Sinequa Angular workspace​","type":1,"pageTitle":"Server configuration","url":"/dokku/docs/guides/server-config#unzip-the-sinequa-angular-workspace","content":" To unzip the default Sinequa workspace, click New &gt; Unzip default Angular workspace  'Unzip default Angular workspace' action  You will be prompted to choose a name for your workspace. This process can take a few minutes. You can follow its progress either by looking at the banner on the top of Workspaces administration page or by going to Tasks status page, the progress status is named UnzipAngularWorkspace.  Status of 'Unzip default Angular workspace' action in Tasks status  ","version":"Next","tagName":"h3"},{"title":"Upload your Angular workspace to Sinequa ES​","type":1,"pageTitle":"Server configuration","url":"/dokku/docs/guides/server-config#upload-your-angular-workspace-to-sinequa-es","content":" :::warning IMPORTANT:  Please verify with the administrator of your Sinequa server that the size of your zip does not exceed the upload size limit of the server. If it is the case, the server will refuse the upload request with HTTP 413 (Request Entity Too Large). :::  This size limit is controlled in IIS by the option maxAllowedContentLength:  &lt;requestFiltering&gt; &lt;requestLimits maxAllowedContentLength=&quot;&lt;limit-in-bytes&gt;&quot; /&gt; &lt;/requestFiltering&gt;   To import your workspace, click New &gt; Import Angular workspace  'Import Angular workspace' action  A wizard will be shown to guide you through the import procedure.  First you need to provide the zip of your workspace. You can only import one workspace at a time. Then choose the name of the exported workspace. If you want to overwrite an existing workspace, remember to tick the checkbox Overwite existing workspace. Otherwise, the wizard will not let you continue with the import procedure.  'Import Angular workspace' wizard - page 1  Once you have finished, click on Next. The next page provides you a summary of the steps that will be executed to import your workspace.  'Import Angular workspace' wizard - page 2  Click on Next when you are ready to begin the import procedure. The import can take some time, once it is complete you can click on the Finish button to view the newly-imported workspace.  'Import Angular workspace' wizard - page 3 - Finish  ","version":"Next","tagName":"h3"},{"title":"Workspace​","type":1,"pageTitle":"Server configuration","url":"/dokku/docs/guides/server-config#workspace","content":" When opening a workspace in the administration, you will see a variety of information related to your workspace.  Firstly, there is information about the download link of your workspace. If there are no download links, you can generate them via More actions &gt; Generate workspace zip orMore actions &gt; Generate minimal workspace zip (without 'node_modules' folder). Note that distributable folders dist and dist-folder are not included in download zip.  Generating a zip file can take a few minutes. You can follow the generation progress either by looking at the banner on the top of Workspaces administration page or by going to Tasks status page, the progress status is named GenerateAngularWorkspaceZip.  Note that if your workspace does not contain a node_modules folder, only the generation action and entry of the minimal zip are shown.  Workspace - Generate zip actions and download link  Secondly, there is a list of all build scripts declared in the package.json file at the root of the workspace. You can execute the build script directly in the grid or from the Build menu at the top-right of the administration page.  You can follow the script progress either by looking at the banner on the top of Workspaces administration page or by going to Tasks status page, the progress status is named BuildAngularWorkspace.  Workspace - Build scripts  The build commands write their result to either /dist or /dist-debug depending on the configuration of the Angular workspace. This is where Sinequa looks for when serving a particular application. Obviously, the Angular app needs to be built in order to be served...  When the app is hosted on Sinequa, the URL contains the name of the App, which itself points to a specific workspace and app  Finally, you can browse the content of workspace folder and that of its files or sub-folders. Note that the contents of the node_modules folder are not shown in the administration due to their size  Workspace - Content  If there is a README markdown file in the workspace root, this file is also rendered at the end of the workspace page.  Workspace - README  ","version":"Next","tagName":"h3"},{"title":"Other actions with workspace​","type":1,"pageTitle":"Server configuration","url":"/dokku/docs/guides/server-config#other-actions-with-workspace","content":" You can execute npm install directly on the workspace administration page, if the WebApp server has access to the Internet. By default, this action is disabled on the administration. You need to activate it via Global options &gt; Advanced &gt; Enable 'npm install' (default: false).  You can follow the execution of the npm install action either by looking at the banner on the top of Workspaces administration page or by going to Tasks status page, the progress status is named ExecuteNpmInstallAngularWorkspace.  Workspace - Execute 'npm install' action  From the workspace administration, you can create an App configuration based on one of the application project of the workspace. To create a new App, go to More actions &gt; New app from, where you can choose the base project for the App.  Workspace - New app actions  ","version":"Next","tagName":"h3"},{"title":"CORS and WebApp configuration​","type":1,"pageTitle":"Server configuration","url":"/dokku/docs/guides/server-config#cors-and-webapp-configuration","content":" The REST API of Sinequa can be used by a remote application (which is the case when you serve your app with ng serve, without a proxy -- See Connecting to the Sinequa server). Note that this mode causes Cross-Origin Resource Sharing (CORS) issues.  Distributed Architecture &gt; Webapp &gt; Stateless Mode &gt; Permitted origins for Cross-Origin Resource Sharing (CORS) requests set to the URL you will use to test your app locally. For example, http://localhost:4200 (or just *).Distributed Architecture &gt; Webapp &gt; Stateless Mode &gt; Return HTTP error codes enabled (default).  As some authentication methods need to store a JSON Web Token (JWT) on the client-side, a cookie must be stored with the SameSite=None and Secure options. This means that the Sinequa API must necessarily be served over HTTPS for these authentication methods to work. ","version":"Next","tagName":"h2"},{"title":"Dashboard Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/analytics/dashboard","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Dashboard Module","url":"/dokku/docs/libraries/analytics/dashboard#features","content":" The module exports a component that takes in a list of widget configurations and displays these widgets within the gridster component. The component handles common operations such as resizing, adding &amp; removing, renaming, and reordering widgets.  The usage of this component is illustrated in the Pepper application.    ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Dashboard Module","url":"/dokku/docs/libraries/analytics/dashboard#import","content":" Import the standalone dashboard component in your app.module.ts.  import { DashboardComponent } from '@sinequa/analytics/dashboard'; @NgModule({ imports: [ ... DashboardComponent   This component is internationalized: If not already the case, you need to import its messages for the language(s) of your application. For example, in your app's src/locales/en.ts:  ... import {enDashboard} from &quot;@sinequa/analytics/dashboard&quot;; const messages = Utils.merge({}, ..., enDashboard, appMessages);   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"Dashboard Module","url":"/dokku/docs/libraries/analytics/dashboard#usage","content":" The sq-dashboard component can be used with this minimal setup:    Notice that you can drag and drop the widgets by clicking on the card header.  In a more typical usage, widgets have a different type property that is used to determine what to display.  For example:  &lt;ng-template let-widget&gt; &lt;div class=&quot;card h-100&quot;&gt; &lt;div class=&quot;card-header&quot;&gt;{{widget.title}}&lt;/div&gt; &lt;div class=&quot;card-body&quot; [ngSwitch]=&quot;widget.state.type&quot;&gt; &lt;span *ngSwitchCase=&quot;foo&quot;&gt;This is a &quot;foo&quot; widget&lt;/span&gt; &lt;span *ngSwitchCase=&quot;bar&quot;&gt;This is a &quot;bar&quot; widget&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/ng-template&gt;   It is also recommended to use the sq-facet-card component from the Facet Module to encapsulate the widgets. This allows to display built-in &quot;actions&quot; to remove, rename and maximize the widgets:  &lt;ng-template let-widget&gt; &lt;sq-facet-card [title]=&quot;widget.state.title&quot; [icon]=&quot;widget.icon&quot; [collapsible]=&quot;false&quot; [actions]=&quot;widget.actions&quot; [actionsFirst]=&quot;false&quot; [ngSwitch]=&quot;widget.state.type&quot;&gt; ... &lt;/sq-facet-card&gt; &lt;/ng-template&gt;   Thanks to the facet-card API, many functionalities are supported out-of-the-box, like the display of the actions of the child &quot;facet components&quot; (marked with the #facet template variable).  Here is a more complete example with two different types of widgets and usage of the facet card:    ","version":"Next","tagName":"h2"},{"title":"Sizing​","type":1,"pageTitle":"Dashboard Module","url":"/dokku/docs/libraries/analytics/dashboard#sizing","content":" Notice that the sizing of the each type of widget needs to be handled differently, based on whether the component takes all the available space or a fixed given size. The widget.width and widget.height properties are computed by the dashboard component and recomputed upon resize. The horizontalPadding and verticalPadding inputs allow to subtract the size of the border and header of the widget.  ","version":"Next","tagName":"h3"},{"title":"Persistence​","type":1,"pageTitle":"Dashboard Module","url":"/dokku/docs/libraries/analytics/dashboard#persistence","content":" The widget configurations can be persisted in any storage system (including the browser local storage). Only the widget.state should be persisted, as the other properties are computed by the dashboard component.  Therefore, storing the widget configuration could be done like this:  save(widgets.map(widget =&gt; widget.state));   And restoring them with:  widgets = load().map(state =&gt; ({ state, maximizable: true, removable: true, otherProperties: computeFromState(state) }));   (Notice that we avoid storing properties and data that are constant and/or can be re-computed from the state) ","version":"Next","tagName":"h3"},{"title":"Finance Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/analytics/finance","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Finance Module","url":"/dokku/docs/libraries/analytics/finance#features","content":" This module includes components for visualizing financial data. These components are based on the D3 library.  The module includes two components:  A timeline component taking a list of records as an input and displaying amounts of money found in these records along a time axis.A &quot;cloud&quot; component taking an aggregation as an input and displaying amounts of money associated to pre-defined categories.    ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Finance Module","url":"/dokku/docs/libraries/analytics/finance#import","content":" Import this module in your app.module.ts.  import { FinanceModule } from '@sinequa/analytics/finance'; @NgModule({ imports: [ ... FinanceModule   This module is internationalized: If not already the case, you need to import its messages for the language(s) of your application. For example, in your app's src/locales/en.ts:  ... import {enFinance} from &quot;@sinequa/analytics/finance&quot;; const messages = Utils.merge({}, ..., enFinance, appMessages);   ","version":"Next","tagName":"h2"},{"title":"Extracting amounts of money from indexed content​","type":1,"pageTitle":"Finance Module","url":"/dokku/docs/libraries/analytics/finance#extracting-amounts-of-money-from-indexed-content","content":" Some components in this module require &quot;amounts of money&quot; to be extracted from the content indexed by Sinequa. What we call an &quot;amount of money&quot; is for example the text in bold below:  The company grew its revenue by $1.32 billion this quarter.  Sinequa provides a built-in entity which extracts such amounts of money in English and French. What's more, it normalizes the entity so it can be used in components like these ones. For example, the above amount is normalized as USD 1320000000. To use this entity in your application, perform the following steps:  Add the bult-in entity (&quot;_amount&quot;, extracted in entity4) to your NLP Analysis Parameters.Index the content.In your App's query web service, configure an alias for entity4 (eg. &quot;money&quot;).If required by the component, configure an aggregation for this column (eg. &quot;Money&quot;).  Additionally, you might want to extract co-occurrence of amounts of money with another entity. Typically, you can have a simple &quot;whitelist&quot; entity (eg. &quot;value&quot;) that extracts and normalizes a list of categories:  revenue income equity assets cash salary;compensation   Then you can configure a cooccurrence entity (eg. &quot;amount&quot;) that looks for combinations of the &quot;value&quot; and &quot;money&quot; entities, like in the sentence:  The company grew its revenue by $1.32 billion this quarter.  Such a cooccurrence entity would be extracted and normalized as (REVENUE)#(USD 1320000000). In the case of the &quot;money-cloud&quot; component, you will need to configure an alias and aggregation for this entity.  ","version":"Next","tagName":"h2"},{"title":"Money Timeline​","type":1,"pageTitle":"Finance Module","url":"/dokku/docs/libraries/analytics/finance#money-timeline","content":" The money timeline component (sq-money-timeline) displays amounts of money found in records (ie. search results, along a time axis). The component only requires a Results input. By default, the component assumes that amounts of money are extracted in a &quot;money&quot; column and that a &quot;Money&quot; aggregation is calculated against this column. The aggregation is used to size the &quot;bubbles&quot; representing each amount of money (the bigger the bubble means the amount of money is often mentioned in the results). The time axis corresponds to the &quot;modifed&quot; column of the records. The colors corresponds to different records in the results.    Main inputs:  results: The Results from which to extract the records and aggregation plotted on the timeline.moneyColumn (defaults: 'money'): The column that stores the entity formatted as USD 1234.moneyAggregation (defaults: 'Money'): The aggregation computed over the above column.  When an amount is hovered with the mouse, and the user clicks on the &quot;Inspect this document&quot; button, the component emits an event recordClicked (which can be used by the parent to perform a custom action). The component automatically handles the action of filtering an amount of money (which adds a filter to the search query, of the type money: USD 1234).  ","version":"Next","tagName":"h2"},{"title":"Money Cloud​","type":1,"pageTitle":"Finance Module","url":"/dokku/docs/libraries/analytics/finance#money-cloud","content":" The money cloud component (sq-money-cloud) displays amounts of money found in the results sorted by categories. The component only requires a Results input. By default, the component assumes that cooccurrence of amounts of money and categories are extracted in a &quot;value_amount&quot; column and that a &quot;ValueAmounts&quot; aggregation is calculated against this column. Only the aggregation is used to plot the data (no records are used, unlike the timeline component). The bigger the bubble means the cooccurrence is often mentioned in the results. The colors correspond to the currencies found in the amount of money.    Main inputs:  results: The Results from which to extract the aggregation plotted on the timeline.moneyValueColumn (defaults: 'value_amount'): The column that stores the entity formatted as (REVENUE)#(USD 1320000000).moneyAggregation (defaults: 'ValueAmounts'): The aggregation computed over the above column.  The component automatically handles the action of filtering a cooccurrence (which adds a filter to the search query, of the type value_amount: (REVENUE)#(USD 1320000000)). ","version":"Next","tagName":"h2"},{"title":"AG Grid Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/analytics/ag-grid","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"AG Grid Module","url":"/dokku/docs/libraries/analytics/ag-grid#features","content":" This module includes an integration of the AG Grid library to display data from Sinequa indexes in the form of a grid view. Note that this module uses the AG Grid Community library which is released under the MIT License.  The module exports one component which is a wrapper of the ag-grid-angular component provided by the library, and enriched with a custom toolbar.    ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"AG Grid Module","url":"/dokku/docs/libraries/analytics/ag-grid#import","content":" Import this module in your app.module.ts.  import { AgGridModule } from '@sinequa/analytics/ag-grid'; @NgModule({ imports: [ ... AgGridModule   This module is internationalized: If not already the case, you need to import its messages for the language(s) of your application. For example, in your app's src/locales/en.ts:  ... import {enGrid} from &quot;@sinequa/analytics/ag-grid&quot;; const messages = Utils.merge({}, ..., enGrid, appMessages);   Additionally, the AG Grid component requires various global stylesheets. Import at least the first one of the following, as well as the theme(s) that your application will use.  @import &quot;~ag-grid-community/dist/styles/ag-grid.css&quot;; @import &quot;~ag-grid-community/dist/styles/ag-theme-balham.css&quot;; @import &quot;~ag-grid-community/dist/styles/ag-theme-alpine.css&quot;; @import &quot;~ag-grid-community/dist/styles/ag-theme-balham-dark.css&quot;; @import &quot;~ag-grid-community/dist/styles/ag-theme-alpine-dark.css&quot;;   ","version":"Next","tagName":"h2"},{"title":"Configuration​","type":1,"pageTitle":"AG Grid Module","url":"/dokku/docs/libraries/analytics/ag-grid#configuration","content":" The sq-ag-grid-view component can be integrated in an Angular template with the following minimal inputs:  &lt;sq-ag-grid-view [results]=&quot;results&quot; [columns]=&quot;columns&quot;&gt;&lt;/sq-ag-grid-view&gt;   In the snippet above,  results is a Results object containing the data to be displayed. A change in the results triggers a new rendering of the component.columns is the list of columns to be displayed by the Grid. Each column definition is a ColDef object (see AG Grid Documentation). Only the field property is actualy required, and must correspond to a column (or alias) name existing in the record objects. The component creates automatically other properties of the ColDef object, namely: headerName, headerTooltip, filter, sortable, hide, width, cellRenderer and tooltipValueGetter.  If the filter property is not provided for a given column, it is automatically guessed in function of the type of the column (eg. a &quot;double&quot; column will be set to use the built-in agNumberColumnFilter filter). Additionally, it is possible to:  disable filtering for that column (filter: false)specify the built-in filter you wish to use (filter: &quot;agNumberColumnFilter&quot;)use a Sinequa facet in place of the built-in filters (filter: &quot;facet&quot;). Note that you need to configure an aggregation in the query web service for this to work. Facets are designed to work with the SearchService, so they will work best in the &quot;Global Query&quot; mode (see below).  A sample configuration for the columns input could be:  columns: Column[] = [ {field: &quot;displayTitle&quot;, headerName: &quot;Custom title&quot;}, {field: &quot;url1&quot;}, {field: &quot;modified&quot;}, {field: &quot;sourcestr4&quot;}, {field: &quot;sourcedouble1&quot;}, {field: &quot;geo&quot;, filter: &quot;facet&quot;}, {field: &quot;docformat&quot;} ]   Additionally the component can be configured with the following optional inputs:  query: A Query object to fetch data from the server (when scrolling down the list of results). ⚠️ If the query is provided, the grid works in the &quot;Local Query&quot; mode, and when omitted, the grid works in the &quot;Global Query&quot; mode using the search service query instead (see below).width (default: '100%'): The width of grid.height (default: '600px'): The height of grid.toolbarActions (default: [&quot;columnVisibility&quot;, &quot;gridReset&quot;, &quot;autosize&quot;, &quot;copySelection&quot;, &quot;downloadSelection&quot;, &quot;formatContent&quot;]): This parameter is a list of string and/or Action objects that are displayed as a toolbar above the grid. The strings correspond to predefined actions supported by the component. It is possible to provide a custom combination of string and Action to fully customize this toolbar.showCounter (default: true): Whether or not to show the number of results next to the toolbar.formatContent (default: true): Whether or not to format the data (using the FormatService). This property is overriden by the user's preference once they make a choice.rowSelection (default: 'multiple'): Whether the user can select one ('single') or multiple ('multiple') or no (undefined) row(s).displayCheckbox (default: false): Display checkboxes in the first column of the grid, to make row selection more intuitive.theme (default: 'ag-theme-alpine'): Choice of the theme. Note that the corresponding stylesheet must be imported in your global stylesheet (see above). The library provides a regular theme ('ag-theme-alpine') and a dense theme ('ag-theme-balham') when there is a lot of data to display. On top of this, each of these themes has a dark mode (append -dark to the above theme names).defaultColumnWidth (default: 200): Default column width in pixels.defaultColDef: A default ColDef with properties applied to all columns (unless overriden in the column's definition).renderCell: A default cell renderer used for all columns (unless overriden in the column's definition). The default renderer uses the FormatService to format data.tooltipValueGetter A default function to generate a tooltip for each cell.exportValueGetter A default function to generate export data for each cell.  ","version":"Next","tagName":"h2"},{"title":"Understanding the \"infinite\" row model​","type":1,"pageTitle":"AG Grid Module","url":"/dokku/docs/libraries/analytics/ag-grid#understanding-the-infinite-row-model","content":" Internally, the component is configured to use the &quot;infinite&quot; row model.  This means that the grid downloads only the bits of data that it needs to display. Concretely, when users scroll down the list of results, the component fetches more data from Sinequa (using pagination parameters) and displays them on the fly.  This configuration involves various steps:  The ag-grid-angular component is configured with the following settings: &lt;ag-grid-angular ... [rowModelType]=&quot;'infinite'&quot; [cacheBlockSize]=&quot;appService.ccquery?.pageSize || 20&quot; [blockLoadDebounceMillis]=&quot;300&quot;&gt; This means that the data is downloaded from the server in blocks of 20 records (unless a different value is configured) and that to avoid flooding the server when scrolling fast, we wait for 300ms before downloading each block. Row data is not passed directly to the grid. Instead, a Datasource object is created: // Create a new datasource this.datasource = this.makeDatasource(); // Apply to the grid this.gridApi.setDatasource(this.datasource); This datasource is responsible for providing data asynchronously, taking into account the current state of the query as well as the pagination parameters, custom filters and sorting parameters that the ag-grid component provides. Our implementation of the IDatasource interface is available in the SqDatasource class. At the moment, most of the complexity comes from the management of the wide range of filter types supported by AG Grid (contains, equals, startsWith, etc.), which is translated into fielded search syntax (including regular expression for some of these filters). This class can be overriden or replaced to implement a different logic of data handling.  ","version":"Next","tagName":"h2"},{"title":"Global Query mode and Local Query mode​","type":1,"pageTitle":"AG Grid Module","url":"/dokku/docs/libraries/analytics/ag-grid#global-query-mode-and-local-query-mode","content":" You can configure the component in 2 different modes, depending on whether or not you provide the query input parameter to the component (see above):  Local Query mode: If you pass a Query to the component, that query will be used by the grid to fetch more data. When the users scrolls down, or uses the grid's filters and sorts, this query is modified (in SqDatasource) to fetch more results, but the state of the application is not modified (if you refresh the page, your filters and sorts will be lost). 1) The user acts on the grid (eg. by adding a filter) 2) The grid calls the getRows() method to get data 3) The server responds and the grid displays the results Global Query mode: If you do not pass a Query to the component, it will use SearchService.query and modify that query globally. This means that the filters and sorts defined in the grid are persisted in the URL, and therefore the state of the grid is preserved when the page is reloaded (as well as when using the back button). However, the pagination state is not persisted (or else it wouldn't really make sense to use the infinite row model). 1) The user acts on the grid (eg. by adding a filter) 2) The grid calls the getRows() method to get data 3) The global query is modified by the search service, the grid gets new results and a new datasource is created 4) The pagination is managed like in the local query mode ","version":"Next","tagName":"h2"},{"title":"Google Maps Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/analytics/googlemaps","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Google Maps Module","url":"/dokku/docs/libraries/analytics/googlemaps#features","content":" Angular Google Maps is an official Angular library that allows to integrate a Google Map component (with markers, info windows, zooming &amp; panning interactions, etc.) in Angular applications.  This Sinequa module wraps this component and uses it to display geolocated records from the Sinequa index. The component needs the records to have mono-valued latitude and longitude fields.    ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Google Maps Module","url":"/dokku/docs/libraries/analytics/googlemaps#import","content":" Import this module in your app.module.ts. Also import the Angular Google Maps module to include your Google Maps API key:  import { GoogleMapsModule, GOOGLE_MAPS_API_KEY } from '@sinequa/analytics/googlemaps'; @NgModule({ imports: [ ... GoogleMapsModule ], ..., providers: [ ..., {provide: GOOGLE_MAPS_API_KEY, useValue: &quot;&lt;YOUR GOOGLE MAPS API KEY HERE&gt;&quot;} ]   Note that the component will be displayed even if you don't provide an API key, but it cannot be used in production.  This module is internationalized: If not already the case, you need to import its messages for the language(s) of your application. For example, in your app's src/locales/en.ts:  ... import {enGooglemaps} from &quot;@sinequa/analytics/googlemaps&quot;; const messages = Utils.merge({}, ..., enGooglemaps, appMessages);   ","version":"Next","tagName":"h2"},{"title":"Map component​","type":1,"pageTitle":"Google Maps Module","url":"/dokku/docs/libraries/analytics/googlemaps#map-component","content":" The map component is a facet component (See Facet Module), which means it is best used when integrated in a facet card:  &lt;sq-facet-card [icon]=&quot;'fas fa-globe-americas'&quot; [title]=&quot;'Map'&quot;&gt; &lt;sq-googlemaps #facet [results]=&quot;results&quot; [width]=&quot;500&quot; [height]=&quot;300&quot;&gt;&lt;/sq-googlemaps&gt; &lt;/sq-facet-card&gt;   The component looks through the list of records (results.records), filtering geolocated documents. Such documents must have a &quot;latitude&quot; and &quot;longitude&quot; fields (ie. record['latitude']). The name of these fields can be customized by binding the latitudeField and longitudeField inputs. For example:  &lt;sq-googlemaps #facet [results]=&quot;results&quot; [latitudeField]=&quot;'sourcedouble1'&quot; [latitudeField]=&quot;'sourcedouble2'&quot;&gt;&lt;/sq-googlemaps&gt;   (Of course, it is rather recommended to define aliases for these columns in the Query Web Service configuration.)  The component displays each geolocated record as a pin on the map, and automatically tries to fit the viewport to these pins. When the user clicks on a pin, an info-window is displayed with the title of that document, and an event is emitted with the corresponding Record object.    This event can be captured by the parent:  &lt;sq-googlemaps #facet [results]=&quot;results&quot; (recordClicked)=&quot;onRecordClicked($event)&quot;&gt;&lt;/sq-googlemaps&gt;   Finally, the component displays a &quot;Filter&quot; action in the facet header. When clicked, a selection is created to filter documents falling inside the current bounds of the map.    The selection is expressed as a simple rectangle:  latitude &gt; minLat AND latitude &lt; maxLat AND longitude &gt; minLng AND longitude &lt; maxLng   This approach works fine for simple use cases, but has some limitations:  When the searched area is very large, the bounds of the map can be very different from a rectangle, due to the sphericity of Earth.When searching around the poles or over the anti-meridian, the equation above should be adapted.This only works for mono-valued coordinates. If a document had multiple geographic locations attached to it, a different approach is needed.  Sinequa does provide the capabilities to overcome these limitations and enable many more advanced geographical feature, using an engine plugin.  ","version":"Next","tagName":"h2"},{"title":"Additional Options​","type":1,"pageTitle":"Google Maps Module","url":"/dokku/docs/libraries/analytics/googlemaps#additional-options","content":" ","version":"Next","tagName":"h2"},{"title":"Customizing the info windows templates​","type":1,"pageTitle":"Google Maps Module","url":"/dokku/docs/libraries/analytics/googlemaps#customizing-the-info-windows-templates","content":" It is possible to pass a ng-template to the component (by transclusion), to customize the HTML displayed in the popups showed when clicking on a marker.  &lt;sq-googlemaps [results]=&quot;results&quot;&gt; &lt;ng-template let-record&gt; Hello world: {{record?.title}} &lt;/ng-template&gt; &lt;/sq-googlemaps&gt;   ","version":"Next","tagName":"h3"},{"title":"Minimum auto-fit size​","type":1,"pageTitle":"Google Maps Module","url":"/dokku/docs/libraries/analytics/googlemaps#minimum-auto-fit-size","content":" It is possible to customize the minimum distance down to which the component will zoom to fit the markers. In particular, when only a single marker is displayed, we want to avoid zooming on it with the maximum resolution supported by Google Maps.  In the example below, this minimum size is set to 10km.  &lt;sq-googlemaps [results]=&quot;results&quot; [minFit]=&quot;10000&quot;&gt; &lt;/sq-googlemaps&gt;   ","version":"Next","tagName":"h3"},{"title":"Going Further​","type":1,"pageTitle":"Google Maps Module","url":"/dokku/docs/libraries/analytics/googlemaps#going-further","content":" This component is a simple example of integration of Google Maps within a Sinequa SBA. It is very likely that additional functionalities will be needed for specific projects.  We recommend copying the component's source code into your project and adapting it to your precise needs. ","version":"Next","tagName":"h2"},{"title":"Heatmap Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/analytics/heatmap","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Heatmap Module","url":"/dokku/docs/libraries/analytics/heatmap#features","content":" This module includes a Heatmap visualization of 2-dimensional data based on the D3 library. This chart is available:  As a simple component taking data as an input and displaying it, unaware of Sinequa's API and data structures.As a facet component, managing the transformation of an aggregation into the heatmap data, and displaying actions to customize this aggregation, as well as a settings panel.As a results view component (mostly for compatibility), directly based on the facet component, but displayed in a slightly different way since the component is not meant to live in a sq-facet-card wrapper (See Facet module).    ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Heatmap Module","url":"/dokku/docs/libraries/analytics/heatmap#import","content":" Import this module in your app.module.ts.  import { BsHeatmapModule } from '@sinequa/analytics/heatmap'; @NgModule({ imports: [ ... BsHeatmapModule   This module is internationalized: If not already the case, you need to import its messages for the language(s) of your application. For example, in your app's src/locales/en.ts:  ... import {enHeatmap} from &quot;@sinequa/analytics/heatmap&quot;; const messages = Utils.merge({}, ..., enHeatmap, appMessages);   ","version":"Next","tagName":"h2"},{"title":"Server-side setup​","type":1,"pageTitle":"Heatmap Module","url":"/dokku/docs/libraries/analytics/heatmap#server-side-setup","content":" The heatmap can display two types of aggregations, configured on the server side (in the query web service):  Cross-distributions (or cross-correlations): By default the &quot;Heatmap&quot; aggregation configured in the default query web service is a cross-distribution. The engine dynamically computes the number of documents mentioning 2 values of metadata together. For example, we can compute the cross-distribution of the people and company columns which yields the following list: Bill Gates/Microsoft;15 (Bill Gates and Microsoft are mentioned together in 15 records) Elon Musk/Tesla;13 (Elon Musk and Tesla are mentioned together in 13 records) etc. ⚠️ Note that these computations may scale poorly with the number of records/documents in the case of multi-valued columns and long documents (if a document contains 100 entities of each type, that means already 10000 unique combinations for a single document). Cooccurrences: The Sinequa indexer can extract in a column the co-occurrences of two entities within a close neighborhood. In this case the aggregation is similar to any other 1-dimension distribution or correlation (used in list facets), except the data contains 2 values instead of one: (Bill Gates)#(Microsoft);15 (Bill Gates and Microsoft are closely mentioned together 15 times)(Elon Musk)#(Tesla);13 (...)  Note that in both cases, the computation can be computationally expensive (especially cross-distribution) and return a lot of data. Therefore, it is recommended to uncheck the Include in standard search option of the aggregation (unless the heatmap is really meant to be displayed all the time) and set a reasonable count option (which can result in some sparsity in the heatmap).  The heatmap facet and results view take care of querying the server if the heatmap aggregation is not included in the standard search.  ","version":"Next","tagName":"h2"},{"title":"Heatmap Facet​","type":1,"pageTitle":"Heatmap Module","url":"/dokku/docs/libraries/analytics/heatmap#heatmap-facet","content":" The heatmap facet (sq-facet-heatmap) looks as the image above. It can be displayed with:  &lt;sq-facet-card [icon]=&quot;'fas fa-th'&quot; [title]=&quot;'Awesome Heatmap'&quot;&gt; &lt;sq-facet-heatmap #facet [results]=&quot;results&quot; [fieldX]=&quot;'geo'&quot; [fieldY]=&quot;'company'&quot; [fieldsX]=&quot;['geo', 'company', 'person']&quot; [fieldsY]=&quot;['geo', 'company', 'person']&quot;&gt;&lt;/sq-facet-heatmap&gt; &lt;/sq-facet-card&gt;   This facet includes a settings template which lets the user tune some of the heatmap parameters:    The sq-facet-heatmap component accepts the following inputs:  results: The current resultsaggregation (default: 'Heatmap', the name of the default aggregation configured in the query web service): Name of the aggregation which contains the data.name: An optional name to identify the facet in the user preferences and breadcrumbs.fieldX (in cross-distribution mode): Default column to display on the X axis (parameter overriden in User Preferences).fieldY (in cross-distribution mode): Default column to display on the Y axis (parameter overriden in User Preferences).fieldsX (in cross-distribution mode): List of all columns available for the X axis.fieldsY (in cross-distribution mode): List of all columns available for the Y axis.fieldCooc (in co-occurrence mode): Name of the co-occurrence column.width (default: 600): Default width of the chart (parameter overriden in User Preferences if user checks rescale axes). In any case the chart is resized to fit the container's width (the aspect ratio is respected).height (default: 600): Default height of the chart (parameter overriden in User Preferences if user checks rescale axes).margin (default: {top: 100, bottom: 20, left: 100, right: 40}): Margins used to draw the chart while leaving space for the legend and axes.transition (default: 1000): Number of milliseconds in a transition (which animate the axes).buckets (default: 9): Number of quantiles used to split the data (= number of colors).colorScheme (default: 'schemeBlues): Color scheme used to display the heatmap color gradient. All the schemes available are available here (parameter overriden in User Preferences).maxX (default: 20): Maximum number of items on the X axis (parameter overriden in User Preferences).maxY (default: 20): Maximum number of items on the Y axis (parameter overriden in User Preferences).itemsClickable (default: true): Whether the heatmap's tiles are clickable or not (resulting in filtering the search).axisClickable (default: true): Whether the items on the heatmap axis are clickable (resulting in filtering the search).highlightSelected (default: true): Whether the heatmap tiles should be marked as &quot;selected&quot; when a record containing these tiles is selected (which alters the tile's opacity).  ","version":"Next","tagName":"h2"},{"title":"Heatmap results view​","type":1,"pageTitle":"Heatmap Module","url":"/dokku/docs/libraries/analytics/heatmap#heatmap-results-view","content":" The heatmap results view (sq-results-heatmap-view) is based directly on the sq-facet-heatmap component (by inheritance). The differences are the following:  To use this component it is required to import the BsResultsViewModule module in your app.module.ts and inject a list of results views and a default one via the forRoot() method.Since the view is not wrapped inside a sq-facet-card component, the list of actions is displayed above the view, including a button to toggle the settings panel.The sq-results-heatmap-view component accepts all the parameters of the sq-facet-heatmap component, plus an additional optional one: selectView which allows to change the current results view when an item is selected. For example, [selectView]=&quot;'List'&quot; will switch to the &quot;List&quot; results view when a tile is clicked.  ","version":"Next","tagName":"h2"},{"title":"Heatmap component​","type":1,"pageTitle":"Heatmap Module","url":"/dokku/docs/libraries/analytics/heatmap#heatmap-component","content":"   The heatmap component (sq-heatmap) only takes care of displaying the chart. It accepts as inputs most of the graphical settings defined above, but it does not take care of querying the server for data.  When used in isolation, this component needs the data input, which is a list of objects implementing the HeatmapItem interface:  export interface HeatmapItem { x: string; // eg. Bill Gates y: string; // eg. Microsoft count: number; // 15 value: string; // &quot;Bill Gates/Microsoft&quot; display: string; // &quot;Bill Gates works at Microsoft&quot; selected?: boolean; }  ","version":"Next","tagName":"h2"},{"title":"Ngx Charts Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/analytics/ngx-charts","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Ngx Charts Module","url":"/dokku/docs/libraries/analytics/ngx-charts#features","content":" This module is a wrapper of the open-source ngx-charts library. It allows to display simple charts plotting the data from aggregations (although the library may be used in different ways).  The module includes two components:  A chart component displaying given input data, unaware of Sinequa's API and data structures. It supports different chart types from the ngx-charts library.A &quot;facet&quot; component taking care of pre-processing the aggregation data available in the results, and passing it to the chart component. Its API is similar to that of the List Facet component.    ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Ngx Charts Module","url":"/dokku/docs/libraries/analytics/ngx-charts#import","content":" Import this module in your app.module.ts.  import { NgxChartsModule } from '@sinequa/analytics/ngx-charts'; @NgModule({ imports: [ ... NgxChartsModule   Note that if you need to use the ngx-charts library but do not want to use our wrapper module, you can also import the modules you require directly from @swimlane/ngx-charts. For example:  import { BarChartModule, PieChartModule } from &quot;@swimlane/ngx-charts&quot;; @NgModule({ imports: [ ... BarChartModule, PieChartModule   ","version":"Next","tagName":"h2"},{"title":"Chart Component​","type":1,"pageTitle":"Ngx Charts Module","url":"/dokku/docs/libraries/analytics/ngx-charts#chart-component","content":" The sq-ngx-chart component displays a chart (multiple types are supported), given some data as input, regardless of the data source (the component is unaware of Sinequa APIs and data structures).  Its basic usage is as follow:  &lt;sq-ngx-chart [options]=&quot;options&quot; [data]=&quot;dataPoints&quot; (item-click)=&quot;click($event)&quot;&gt; &lt;/sq-ngx-chart&gt;   The data input is a list of ChartDataPoint objects, a simple interface requiring only name and value properties:  this.data = [ {name: &quot;France&quot;, value: 123}, {name: &quot;Germany&quot;, value: 215}, {name: &quot;United States&quot;, value: 156}, {name: &quot;United Kingdom&quot;, value: 432} ]   The options input is an object of type ChartOptions, an interface requiring the following properties:  type (undefined defaults to a vertical bar chart): Defines the type of chart to display. Available options: 'horizontalbar', 'pie', 'advancedpie', 'piegrid', 'treemap', 'numbercard', 'gauge'.colorScheme (optional): Name of a color scheme used to plot the data (among the options: vivid, natural, cool, fire, solar, air,... see the source code)getItemColor (optional): Function taking as input the name of a data item (string) and returning a custom color.tickFormatter (optional): Function taking as input the value of a data item (number) and returning a formatted value.  ","version":"Next","tagName":"h2"},{"title":"Facet Chart Component​","type":1,"pageTitle":"Ngx Charts Module","url":"/dokku/docs/libraries/analytics/ngx-charts#facet-chart-component","content":" The sq-facet-ngx-chart component displays an aggregation from the results as a chart. The user can click on items in the chart to filter the results.    This component requires at least a Results input and the name of the aggregation to work properly.  &lt;sq-facet-card [title]=&quot;'Companies'&quot; [icon]=&quot;'fas fa-building'&quot;&gt; &lt;sq-facet-ngx-chart #facet [results]=&quot;results&quot; [aggregation]=&quot;'Company'&quot;&gt;&lt;/sq-facet-ngx-chart&gt; &lt;/sq-facet-card&gt;   ","version":"Next","tagName":"h2"},{"title":"List of inputs​","type":1,"pageTitle":"Ngx Charts Module","url":"/dokku/docs/libraries/analytics/ngx-charts#list-of-inputs","content":" The sq-facet-ngx-chart component accepts the following inputs:  results (required): The Results object containing the aggregation that must be displayed.aggregation (required): A string, containing the name of the aggregation (as defined in the query web service configuration) to plot in the chart.aggregations (optional): A list of string, containing the name of alternative aggregations. If provided, a dropdown menu will be automatically displayed in the facet frame to switch between these different aggregations.chartType (undefined defaults to a vertical bar chart): Defines the type of chart to display. Available options: 'horizontalbar', 'pie', 'advancedpie', 'piegrid', 'treemap', 'numbercard', 'gauge'.colorScheme or colors: By default a list of colors is provided, containing a single color, resulting in all the chart items being drawn with the same color. It is possible to provide a custom list of colors with multiple values instead. It is also possible to set colors to null or undefined and instead provide a colorScheme (among the options: vivid, natural, cool, fire, solar, air,... see the source code).filteredColor (default: #C3E6CB): If the colors input is provided, items which are filtered (have been clicked on to filter the results) will be displayed with this color.selectedColor (default: #7acce5): If the colors input is provided, items belonging to a selected document (managed by the SelectionService - see Selection Module) will be displayed with this color. ","version":"Next","tagName":"h3"},{"title":"FusionCharts Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/analytics/fusioncharts","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"FusionCharts Module","url":"/dokku/docs/libraries/analytics/fusioncharts#features","content":" FusionCharts is a charting library which usage is permitted within the scope of a Sinequa-based project.  This module includes few components which expose a limited sample of the FusionChart functionalities. The FusionCharts library includes many rich and configurable charts which are not covered (see advanced customization below).    ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"FusionCharts Module","url":"/dokku/docs/libraries/analytics/fusioncharts#import","content":" Import this module in your app.module.ts and load the charts and themes that you need via the forRoot() method. An example of these imports is available in the Pepper application's app.module.ts.  import { FusionChartsModule } from '@sinequa/analytics/fusioncharts'; // Import FusionCharts library and chart modules import * as FusionCharts from &quot;fusioncharts&quot;; import * as charts from &quot;fusioncharts/fusioncharts.charts&quot;; // Fusion is a light theme, Candy is a dark theme import * as FusionTheme from &quot;fusioncharts/themes/fusioncharts.theme.fusion&quot;; import * as CandyTheme from &quot;fusioncharts/themes/fusioncharts.theme.candy&quot;; @NgModule({ imports: [ ... FusionChartsModule.forRoot(FusionCharts, charts, FusionTheme, CandyTheme),   ","version":"Next","tagName":"h2"},{"title":"FusionChart Component​","type":1,"pageTitle":"FusionCharts Module","url":"/dokku/docs/libraries/analytics/fusioncharts#fusionchart-component","content":"   The sq-fusion-chart component displays a chart (multiple types are supported), given at least a Results input and the name of an aggregation (as configured in the query web service).  ","version":"Next","tagName":"h2"},{"title":"Chart type​","type":1,"pageTitle":"FusionCharts Module","url":"/dokku/docs/libraries/analytics/fusioncharts#chart-type","content":" Additionally, an input type can be specified to change the type of chart. Currently, only column2d, bar2d, pie2d and doughnut2d have been tested (and their &quot;3d&quot; equivalents). Other types listed in the FusionCharts documentation might work as well but could expect different types of input or options.  For example:  &lt;sq-facet-card [icon]=&quot;'fas fa-chart-line'&quot; [title]=&quot;'FusionCharts'&quot;&gt; &lt;sq-fusion-chart #facet [type]=&quot;'doughnut3d'&quot; [results]=&quot;results&quot; [aggregation]=&quot;'Company'&quot;&gt;&lt;/sq-fusion-chart&gt; &lt;/sq-facet-card&gt;   Displays the following:    ⚠️ We actually do not recommend using Pie or Doughtnut charts to display long-tail aggregations as in the example, since it can be misleading: Only the top ten values are displayed here, but the chart looks as if all these values make up 100% of the data.  ","version":"Next","tagName":"h3"},{"title":"Multiple aggregations​","type":1,"pageTitle":"FusionCharts Module","url":"/dokku/docs/libraries/analytics/fusioncharts#multiple-aggregations","content":" The component also accepts an input aggregations, which is the list of names of alternative aggregations that can be plotted instead of the primary aggregation. If provided, the facet header includes a drop-down menu allowing the user to select which aggregation he wants to plot.  &lt;sq-facet-card [icon]=&quot;'fas fa-chart-line'&quot; [title]=&quot;'FusionCharts'&quot;&gt; &lt;sq-fusion-chart #facet [results]=&quot;results&quot; [aggregation]=&quot;'Company'&quot; [aggregations]=&quot;['Company','Person','Geo']&quot;&gt;&lt;/sq-fusion-chart&gt; &lt;/sq-facet-card&gt;     ","version":"Next","tagName":"h3"},{"title":"Width and Height​","type":1,"pageTitle":"FusionCharts Module","url":"/dokku/docs/libraries/analytics/fusioncharts#width-and-height","content":" The component accepts width and height parameters with the following defaults:  width = '100%'height = '350' (Note that the input is expected as a string and it should NOT contain a suffix like px, although % works fine)  ","version":"Next","tagName":"h3"},{"title":"Chart options​","type":1,"pageTitle":"FusionCharts Module","url":"/dokku/docs/libraries/analytics/fusioncharts#chart-options","content":" A chart input can be provided to the component. It must have the same structure as in the FusionCharts documentation (this object is always nested within the dataSource object).  The default is:  export const defaultChart = { &quot;theme&quot;: &quot;fusion&quot;, &quot;labelDisplay&quot;: &quot;rotate&quot;, &quot;slantLabel&quot;: &quot;1&quot; }   (Note that these default values have the effect of tilting the x axis labels in the default Column2D chart)  ","version":"Next","tagName":"h3"},{"title":"Colors​","type":1,"pageTitle":"FusionCharts Module","url":"/dokku/docs/libraries/analytics/fusioncharts#colors","content":" By default, a FusionCharts theme is used (it can be modified using the above chart options). However it is possible to specify your own color for displaying the data items:  defaultColor: When specified, will be used as the background color for the data items (eg. the bars of a bar chart).filteredColor (default: #C3E6CB): Displays the filtered items (items that have been clicked on to filter the results) in a distinctive color.selectedColor (default: #8186d4): Displays the items that belong to a selected document (managed by the SelectionService - see Selection Module) in a distinctive color.    ","version":"Next","tagName":"h3"},{"title":"MultiLevelPieChart Component​","type":1,"pageTitle":"FusionCharts Module","url":"/dokku/docs/libraries/analytics/fusioncharts#multilevelpiechart-component","content":" The sq-multi-level-pie-chart component displays a special type of chart that allows you to show symmetrical and asymmetrical tree structures in a consolidated pie-like structure. It presents the entire hierarchical data in a single-screen snapshot, which makes it a preferred choice over a tree view.  This chart type belongs to PowerCharts XT. Thus, it requires an additional import :  import { FusionChartsModule } from '@sinequa/analytics/fusioncharts'; // Import FusionCharts library and chart modules import * as FusionCharts from &quot;fusioncharts&quot;; import * as charts from &quot;fusioncharts/fusioncharts.charts&quot;; import * as powerCharts from &quot;fusioncharts/fusioncharts.powercharts&quot;; // Fusion is a light theme, Candy is a dark theme import * as FusionTheme from &quot;fusioncharts/themes/fusioncharts.theme.fusion&quot;; import * as CandyTheme from &quot;fusioncharts/themes/fusioncharts.theme.candy&quot;; @NgModule({ imports: [ ... FusionChartsModule.forRoot(FusionCharts, charts, powerCharts, FusionTheme, CandyTheme),   Its most basic usage is as follow:  &lt;sq-facet-card [icon]=&quot;'fas fa-chart-pie'&quot; [title]=&quot;'Multi level pie'&quot;&gt; &lt;sq-multi-level-pie-chart #facet [results]=&quot;results&quot; [aggregation]=&quot;'Treepath'&quot;&gt;&lt;/sq-multi-level-pie-chart&gt; &lt;/sq-facet-card&gt;   Which displays the following    ","version":"Next","tagName":"h2"},{"title":"Custom data​","type":1,"pageTitle":"FusionCharts Module","url":"/dokku/docs/libraries/analytics/fusioncharts#custom-data","content":" This component has an input data, which implements the following interface Category :  export interface Category extends AggregationItem, TreeAggregationNode { label: string; originalLabel: string; value: number | string; tooltext?: string; color?: string; showLabel?: boolean; showValue?: boolean; category?: Category[]; }   ⚠️ If provided, the component will plot this custom data and ignore the input aggregation even if it is defined.  &lt;sq-facet-card [icon]=&quot;'fas fa-chart-pie'&quot; [title]=&quot;'Multi level pie'&quot;&gt; &lt;sq-multi-level-pie-chart #facet [results]=&quot;results&quot; [data]=&quot;data&quot;&gt;&lt;/sq-multi-level-pie-chart&gt; &lt;/sq-facet-card&gt;   Since custom data can require some specific processes different than default methods, it is possible to override the following inputs :   /** * A function that returns true this component is already filtering the query */ @Input() hasFiltered = () =&gt; { return this.facetService.hasFiltered(this.getName()); } /** * A function that returns true the aggregationItem match a selected document */ @Input() isSelected = &lt;T extends AggregationItem | TreeAggregationNode&gt;(item: T) =&gt; { if (this.isTree()) { return this.selectedValues.has((item as TreeAggregationNode).$path!.toLowerCase()) &amp;&amp; this.selectedColor; } return this.selectedValues.has(Utils.toSqlValue(item.value).toLowerCase()) &amp;&amp; this.selectedColor; } /** * Callback used to apply custom operations (sort, filter ...) on a tree nodes */ @Input() initNodes = (nodes: TreeAggregationNode[], level: number, node: TreeAggregationNode) =&gt; {}   ","version":"Next","tagName":"h3"},{"title":"Width and Height​","type":1,"pageTitle":"FusionCharts Module","url":"/dokku/docs/libraries/analytics/fusioncharts#width-and-height-1","content":" Same as the sq-fusion-chart component, it accepts width and height parameters with the following defaults:  width = '100%'height = '350' (Note that the input is expected as a string and it should NOT contain a suffix like px, although % works fine).  ","version":"Next","tagName":"h3"},{"title":"Chart options​","type":1,"pageTitle":"FusionCharts Module","url":"/dokku/docs/libraries/analytics/fusioncharts#chart-options-1","content":" A chart input can also be provided to this component. It must have the same structure as in the FusionCharts documentation (this object is always nested within the dataSource object).  The default is:  export const defaultMultiLevelChart = { &quot;theme&quot;: &quot;fusion&quot;, &quot;highlightParentPieSlices&quot;: true, // automatically highlight parent slices when you hover over the child pie slices &quot;highlightChildPieSlices&quot;: false, // prevent child pie slices from getting highlighted, when you hover over the parent slices &quot;showPlotBorder&quot;: true, &quot;piefillalpha&quot;: 60, &quot;pieborderthickness&quot;: 3 }   Additional useful inputs can be used to customize the component's display :  showLabels: (false by default) Show/hide ALL plots' label.showValues: (false by default) Show/hide ALL plots' value next to labels.showPercentValues: (false by default) f enabled along with showValues, values of ALL plots will be shown as percentages.showToolTip: (true by default).plottooltext: (&quot;$label, $value, $percentValue&quot; by default) Configure the tooltip text of plots.  ","version":"Next","tagName":"h3"},{"title":"Colors​","type":1,"pageTitle":"FusionCharts Module","url":"/dokku/docs/libraries/analytics/fusioncharts#colors-1","content":" The same colors' choice is used, by default, in both FusionChart and MultiLevelPieChart components.  ","version":"Next","tagName":"h3"},{"title":"Advanced Customization​","type":1,"pageTitle":"FusionCharts Module","url":"/dokku/docs/libraries/analytics/fusioncharts#advanced-customization","content":" The sq-fusion-chart component is a wrapper of the fusioncharts directive. It takes the Sinequa data structures (aggregations), and converts them into a &quot;datasource&quot; object, which is the structure that the Fusion Charts library expects.  When advanced customizations are needed (custom types of charts or data structures), it is possible to use the fusioncharts directive directly. This directive is included in the FusionChartsModule, so the sample imports shown above work just the same.  &lt;fusioncharts [width]=&quot;width&quot; [height]=&quot;height&quot; [type]=&quot;type&quot; [dataSource]=&quot;dataSource&quot; (initialized)=&quot;onInitialized($event)&quot; (dataplotClick)=&quot;dataplotClick($event)&quot; &gt; &lt;/fusioncharts&gt;   This approach gives access to the full range of chart types and events supported by Fusion Charts, but requires you to generate the dataSource object and manage its lifecycle manually. ","version":"Next","tagName":"h2"},{"title":"Vis Timeline Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/analytics/vis-timeline","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Vis Timeline Module","url":"/dokku/docs/libraries/analytics/vis-timeline#features","content":" This module includes a sample Timeline visualization for dates and events, based on the Vis library. The timeline can display punctual dates (generic events) or events (dates associated to an event name).  The module only includes one component, which can be used as is, or more probably taken as a starting point for further development using the Vis library API.    ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Vis Timeline Module","url":"/dokku/docs/libraries/analytics/vis-timeline#import","content":" Import this module in your app.module.ts.  import { VisTimelineModule } from '@sinequa/analytics/vis-timeline'; @NgModule({ imports: [ ... VisTimelineModule   Note that if you need to use the Vis Timeline library directly (without using our wrapper module), you can simply import the VisModule as follow:  import {VisModule} from &quot;ngx-vis&quot;; @NgModule({ imports: [ ... VisModule   In any case you will also need to import the following stylesheet in your app's global stylesheet:  // Vis.js styles @import &quot;~vis-timeline/dist/vis-timeline-graph2d.min.css&quot;;   ","version":"Next","tagName":"h2"},{"title":"Timeline Component​","type":1,"pageTitle":"Vis Timeline Module","url":"/dokku/docs/libraries/analytics/vis-timeline#timeline-component","content":" ","version":"Next","tagName":"h2"},{"title":"Basic usage​","type":1,"pageTitle":"Vis Timeline Module","url":"/dokku/docs/libraries/analytics/vis-timeline#basic-usage","content":" The sq-result-timeline component displays a timeline associated to a specific Record object. This record must have at least one column storing a list of &quot;dates&quot; or &quot;events&quot;.  If this column is named 'dates', a sample usage could be as follow:  &lt;sq-result-timeline [record]=&quot;record&quot; [dates]=&quot;record['dates']&quot;&gt;&lt;/sq-result-timeline&gt;   ","version":"Next","tagName":"h3"},{"title":"Dates and Events​","type":1,"pageTitle":"Vis Timeline Module","url":"/dokku/docs/libraries/analytics/vis-timeline#dates-and-events","content":" A date can be a JavaScript Date object, or a formatted string which can be parsed automatically by the date-fns library (which is used internally). For example &quot;2020-12-03&quot; or &quot;2020-12&quot; qualify as dates. A Sinequa index can store such a list of dates within a CSV or Entity column.  An event is a date associated to an event name. The association is done by formatting the field as (Event name)#(Date), which is the standard format of cooccurrence normalization in the Sinequa platform. For example, the event (Birthday)#(2021-04-24) can be extracted from documents with a cooccurrence associating two entities: One for the event names (eg. a whitelist entity) and one for the dates (eg. a TMA entity).  ⚠️ Note that you may have other type of data to display on this timeline. Rather than trying to awkwardly coax your data into the data structures that this component expect, we recommend you to create your own component using the Vis and ngx-vis APIs. In particular the [visTimeline] directive and VisTimelineService to listen to user events, like clicks on the dates and events. Both the directive and service are packaged in the Sinequa library and can be imported with: import {VisTimelineDirective, VisTimelineService} from '@sinequa/analytics/vis-timeline';  ","version":"Next","tagName":"h3"},{"title":"List of Inputs​","type":1,"pageTitle":"Vis Timeline Module","url":"/dokku/docs/libraries/analytics/vis-timeline#list-of-inputs","content":" The sq-result-timeline component accepts the following inputs:  record (required): The object of type Record which contains the dates to display. dates (optional): The column of the record object which contains the dates to display (eg. record['dates']). events (optional): The column of the record object which contains the events to display (eg. record['events']). min_year and max_year (defaults: 0 and 10000): Min and max years to filter out the date and event outliers. min_dates and max_dates (defaults: 1 and 100): Min and max number of dates or events to display. options: an object of type TimelineOptions containing the configuration of the Vis Timeline. The default options are as follow: export const defaultOptions : TimelineOptions = { minHeight : '150px', margin: { axis: 5, item: 5 } };  ","version":"Next","tagName":"h3"},{"title":"Components library","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/components","content":"","keywords":"","version":"Next"},{"title":"Building the library​","type":1,"pageTitle":"Components library","url":"/dokku/docs/libraries/components#building-the-library","content":" At the root of the workspace, run the following command:  npm run buildcomponents   The build takes a few minutes to complete and produces a folder dist/components/. Note that this folder is aliased as @sinequa/components, in the tsconfig.json file. This means that all the imports of code of this library from the applications look like:  import { ... } from '@sinequa/components/....';   ","version":"Next","tagName":"h2"},{"title":"Modules​","type":1,"pageTitle":"Components library","url":"/dokku/docs/libraries/components#modules","content":" This library contains several sub-libraries (or &quot;secondary endpoints&quot;). Each sub-library generally includes:  One or more Angular modules. Generally, only one module is used. If the library depends on the Bootstrap library, the module is packaged within a bootstrap/ subfolder and the module is prefixed by Bs (eg. BsSearchModule). Zero or one Angular service. Services are where the intelligence of the application is concentrated. Components generally use a service for the complex data processing tasks and the interactions with @sinequa/core and the web services (eg. SearchService). Services are always designed to be component-agnostic, and therefore do not depend on the Bootstrap or Material Design libraries. When a service depends on a component type, it is actually injected by dependency injection. Various Angular components, directives and pipes exported by the Angular module, and tied together by the service. Zero or one stylesheet, to be imported in your application's global stylesheet. Internationalization &quot;messages&quot;, which are simple Typescript files exporting key/value pairs of text allowing to switch between various languages in your app (See Internationalization).  See the tutorial introduction for additional information on the modules' structure and how to get started with them.  Below is list of documented modules. ","version":"Next","tagName":"h2"},{"title":"Advanced Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/components/advanced","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Advanced Module","url":"/dokku/docs/libraries/components/advanced#features","content":" This module provides a bench of advanced-search functionalities, as well as components to build custom advanced-search forms:  AdvancedService: manages the different operations that can be used to perform an advanced-search in Sinequa.A list of components seen as basic bricks to build a custom advanced-search form . These components are styled with the Bootstrap library, and their class names start with Bs.  ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Advanced Module","url":"/dokku/docs/libraries/components/advanced#import","content":" import { BsAdvancedModule } from '@sinequa/components/advanced'; @NgModule({ imports: [ /*....*/ BsAdvancedModule, /*....*/ ], /*....*/ })   This module is internationalized: If not already the case, you need to import its messages for the language(s) of your application. For example, in your app's src/locales/en.ts:  ... import {enAdvanced} from &quot;@sinequa/components/advanced&quot;; const messages = Utils.merge({}, ..., enAdvanced, appMessages);   ","version":"Next","tagName":"h2"},{"title":"Advanced Service​","type":1,"pageTitle":"Advanced Module","url":"/dokku/docs/libraries/components/advanced#advanced-service","content":" The AdvancedService exposes a variety of methods and interfaces.  If you want to create your own advanced-search form, you will need to define a list of FormControl. Here, a set of dedicated methods is provided :  createSelectControl(field: string, validators?: ValidatorFn[], asyncValidators?: AsyncValidatorFn[]): FormControl This method creates a FormControl dedicated to a standard select. Behind the scenes, this method uses getValue(...) to initialize the value of the returned FormControl. createInputControl(field: string, validators?: ValidatorFn[], asyncValidators?: AsyncValidatorFn[]): FormControl This method creates a FormControl dedicated to a standard input. Behind the scenes, this method uses getValue(...) to initialize the value of the returned FormControl. createCheckboxControl(field: string, validators?: ValidatorFn[], asyncValidators?: AsyncValidatorFn[]): FormControl This method creates a FormControl dedicated to a standard checkbox. Behind the scenes, this method uses getBooleanValue(...) to initialize the value of the returned FormControl. createMultiInputControl(field: string, validators?: ValidatorFn[], asyncValidators?: AsyncValidatorFn[]): FormControl This method creates a FormControl dedicated to an input supporting multi values. Behind the scenes, this method uses getValue(...) to initialize the value of the returned FormControl. createRangeControl(field: string, validators?: ValidatorFn[], asyncValidators?: AsyncValidatorFn[]): FormControl This method creates a FormControl dedicated to a custom element supporting a range definition (a coupled elements used as from .. to ). Behind the scenes, this method uses getRangeValue(...) to initialize the value of the returned FormControl.  Notice that the field parameter represents the column / alias to which we are applying our filter.  All above methods invokes the generic helper :  createControl(value: AdvancedValue | ValueItem | ValueItem[], validators?: ValidatorFn[], asyncValidators?: AsyncValidatorFn[]): FormControl This method creates a generic FormControl.  ","version":"Next","tagName":"h2"},{"title":"Form Validation​","type":1,"pageTitle":"Advanced Module","url":"/dokku/docs/libraries/components/advanced#form-validation","content":" The AdvancedService also enhance the FormControl creation experience with some packaged Validators which can be optionally passed to each one of the above methods.  Those validators are accessible via the readonly attribute advancedFormValidators implementing AdvancedFormValidators interface :  { min: (min: string | number | Date, field: string) =&gt; ValidatorFn; max: (max: string | number | Date, field: string) =&gt; ValidatorFn; required: ValidatorFn; email: ValidatorFn; pattern: (pattern: string | RegExp) =&gt; ValidatorFn; integer: (field: string) =&gt; ValidatorFn; number: (field: string) =&gt; ValidatorFn; date: (field: string) =&gt; ValidatorFn; range: (field: string) =&gt; ValidatorFn; }   ","version":"Next","tagName":"h3"},{"title":"Extras​","type":1,"pageTitle":"Advanced Module","url":"/dokku/docs/libraries/components/advanced#extras","content":" Actually, each created FormControl is not useful unless it is able to perform some related advanced-search lifecycle actions. For this, AdvancedService comes with several methods :  getValue(field: string, query?: Query | undefined): ValueItem | ValueItem[] | undefined This method retrieves the value to be set to a specific FormControl (select, input, multi-input ...) from the query. getBooleanValue(field: string, query?: Query | undefined): boolean | undefined This method retrieves the value to be set to a specific FormControl (checkbox ...) from the query. getRangeValue(field: string, query?: Query | undefined): AdvancedValue This method retrieves the value to be set to a specific FormControl (range ...) from the query. getAdvancedExpr(field: string, query?: Query | undefined): Expr | undefined This method returns the expression of an advanced filter from the query. getValueFromExpr(expr: Expr): ValueItem | ValueItem[] This method extracts the value from the expression. setSelect(field: string, value: ValueItem | ValueItem[] | undefined, query?: Query | undefined, combineWithAnd?: boolean): void This method updates the query with a value of a specific FormControl (select, input, multi-input ...). setBooleanSelect(field: string, value: boolean | undefined, allowFalsy?: boolean, query?: Query | undefined): void This method updates the query with a value of a specific FormControl (checkbox ...). setNumericalSelect(field: string, value: string | Date | number | ValueItem | undefined, operator: &quot;&gt;&quot; | &quot;&gt;=&quot; | &quot;&lt;&quot; | &quot;&lt;=&quot; | &quot;=&quot; | &quot;&lt;&gt;&quot;, query?: Query | undefined): void This method updates the query with a value of a specific FormControl (numeric-input ...). setRangeSelect(field: string, range: (string | Date | number)[] | undefined, query?: Query | undefined): void This method updates the query with a value of a specific FormControl (range ...). setAdvancedSelect(field: string, expr: string | undefined, query?: Query | undefined): void This is the helper method which update the select attribute of the query. If no expression provided, the filter of the corresponding field will be entirely removed. removeAdvancedValue(field: string, search: boolean, query?: Query | undefined): void This method removes a specific advanced value by its field name from a given query and then can trigger a new search event. resetAdvancedValues(search: boolean, query?: Query | undefined): void This method removes all advanced values from a given query and then can trigger a new search event. getAdvancedValues(query?: Query | undefined): Object This method returns an object containing all the filled (field, value) in the advanced-search form.  All above methods use the parameter query as optional. If it is not provided, searchService.query will be used by default.  Other helpers methods are provided within AdvancedService to facilitate custom manipulations of advanced-search feature :  asValueItems(value: ValueItem | ValueItem[], field: string): ValueItem[] This method transforms a given value to a parsed ValueItem[]. formatValueItems(field: string, value: ValueItem | ValueItem[]): ValueItem | ValueItem[] This method returns a formatted copy of the given value. formatAdvancedValue(field: string, value: AdvancedValue): AdvancedValue This method returns a formatted copy of the given value. castAdvancedValue(value: BaseAdvancedValue, column: CCColumn | undefined): BaseAdvancedValue This method cast a given advanced value as per its column definition.  If you want create a new custom component for your advanced-search form, you can, for sure, do it and still be able to benefit of all built-in methods.  ","version":"Next","tagName":"h3"},{"title":"Components​","type":1,"pageTitle":"Advanced Module","url":"/dokku/docs/libraries/components/advanced#components","content":" The AdvancedModule has a set of packaged components which serve as a basic bricks of an advanced-search form :  The BsAdvancedFormSelect component is used to display a select element compatible with any advanced-search form. The inputs of the component are : form: The advanced-search form.field: The column / alias of the applied filter.label: Optional input used to override the default label in the column definition.multiple: Whether the multiple selection is allowed or not.aggregation: Optional input that defines the aggregation name used to fill the select options.    The BsAdvancedFormInput component is used to display an input element compatible with any advanced-search form. The inputs of the component are : form: The advanced-search form.field: The column / alias of the applied filter.label: Optional input used to override the default label in the column definition.suggestQuery: The string value of the suggest query to be used for the autocomplete.    The BsAdvancedFormMultiInput component is used to display a multi-value input element compatible with any advanced-search form. The inputs of the component are : form: The advanced-search form.field: The column / alias of the applied filter.label: Optional input used to override the default label in the column definition.suggestQuery: The string value of the suggest query to be used for the autocomplete.    The BsAdvancedFormRange component is used to display a range input element compatible with any advanced-search form. The inputs of the component are : form: The advanced-search form.field: The column / alias of the applied filter.label: Optional input used to override the default label in the column definition.min: The lowest possible limit.max: The highest possible limit.    The BsAdvancedFormCheckbox component is used to display a checkbox element compatible with any advanced-search form. The inputs of the component are : form: The advanced-search form.field: The column / alias of the applied filter.label: Optional input used to override the default label in the column definition.    ","version":"Next","tagName":"h2"},{"title":"Directives​","type":1,"pageTitle":"Advanced Module","url":"/dokku/docs/libraries/components/advanced#directives","content":" The AdvancedModule embeds its own directives to handle custom features of the advanced-search :  The BsAdvancedFormAutocomplete provides the sqAdvancedFormAutocomplete directive. It extends and overrides the main sqAutocomplete directive. The inputs of the directive are quiet simple : field: The column / alias of the applied filter. This directive also emits an UpdateItem event which is needed to synchronize the search item in the parent component. The BsAdvancedFormAutocompleteMultiInput provides the sqAdvancedFormAutocompleteMultiInput directive. It extends and overrides sqAdvancedFormAutocomplete directive. The inputs of the directive are : items: Initial list of search terms already existing in the advanced search. This directive also emits an itemsUpdate event which is needed to synchronize the search terms in the parent component. The BsAdvancedFormValidation provides the sqAdvancedFormValidation directive. It extends and overrides the main sqValidation directive. The inputs of the directive are : field: The column / alias of the applied filter.validationForm: The advanced-search form.  ","version":"Next","tagName":"h2"},{"title":"Sample use case​","type":1,"pageTitle":"Advanced Module","url":"/dokku/docs/libraries/components/advanced#sample-use-case","content":" A working example could be the integration of an advanced search form in the search form used in Pepper application.  In this section, we will go through the main keys of how to easily instantiate an advanced search form :  First of all, we need to build the form. The best practice is to create a new component containing all the business logic.    The main idea is to start by adding your controls to the form object. Here, you can easily apply validators as much as you want :   this.form.addControl('treepath', this.advancedService.createSelectControl('treepath')); this.form.addControl('modified', this.advancedService.createRangeControl('modified', [ this.advancedService.validators.range('modified'), this.advancedService.validators.date('modified') ] )); this.form.addControl('person', this.advancedService.createMultiInputControl('person')); this.form.addControl('docformat', this.advancedService.createInputControl('docformat'));   In this example, we add several FormControl such as modified, to which we apply 2 validators; range() and date(). You can also note that the build process of the form is set in the callback of this.firstPageService.getFirstPage(). Its role is to load autocompletion suggestions and whatever data needed in the initialization of advanced-search components. You should carefully notice that the name of each formControl is exactly the same as its field property.  Next step is to mutually update of the form and the query according to users interactions. This is the role of both methods updateFormOnQueryChange() and updateQuery(). Then, feel free to design the look &amp; feel of your advanced search form as you want. Once the component is ready, you can integrate it in the search form :  &lt;sq-search-form #searchForm [query]=&quot;searchService.query&quot; [showFilterCount]=&quot;true&quot; [autoSubmit]=&quot;false&quot;&gt; &lt;ng-template let-query&gt; &lt;div class=&quot;search-dropdown border-top m-2&quot;&gt; ... &lt;hr/&gt; &lt;div class=&quot;small fw-bold mb-1 ms-3 me-auto&quot;&gt;Advanced Search Form:&lt;/div&gt; &lt;!-- The new advanced search form you have just created ! --&gt; &lt;sq-advanced-form [query]=&quot;query&quot; (filterEdit)=&quot;onFiltersChange()&quot;&gt; &lt;/sq-advanced-form&gt; ... &lt;/div&gt; &lt;/ng-template&gt; &lt;/sq-search-form&gt;  ","version":"Next","tagName":"h2"},{"title":"Network Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/analytics/network","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Network Module","url":"/dokku/docs/libraries/analytics/network#features","content":" Sinequa is not a graph database, such as Neo4J or Janus Graph. However, data stored in Sinequa indexes can be visualized and explored in a graphical way. The graph structure is not defined at the database level (and it is therefore impossible to compute complex queries involving graph traversal), it is defined at the User Interface level, where data fetched from the server dynamically can be formatted and assembled into a graph.  This module includes a component which displays a network view (based on the Vis.js network library). This view displays nodes and edges generated by one or several providers (NetworkProvider). Each provider generates a dataset (NetworkDataset) of nodes and edges, which are then merged into a single one before displaying the network.    ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Network Module","url":"/dokku/docs/libraries/analytics/network#import","content":" Import this module in your app.module.ts.  import { NetworkModule } from '@sinequa/analytics/network'; @NgModule({ imports: [ ... NetworkModule   For some functionalities of the module, you will also need to import the following stylesheet in your app’s global stylesheet:  // Vis.js styles @import &quot;~vis-network/dist/vis-network.min.css&quot;;   This module is internationalized: If not already the case, you need to import its messages for the language(s) of your application. For example, in your app's src/locales/en.ts:  ... import {enNetwork} from &quot;@sinequa/analytics/network&quot;; const messages = Utils.merge({}, ..., enNetwork, appMessages);   ","version":"Next","tagName":"h2"},{"title":"Quick start​","type":1,"pageTitle":"Network Module","url":"/dokku/docs/libraries/analytics/network#quick-start","content":" If you are in a hurry, and just want to try out the network with a configuration that works regardless of the specifics of your project, try the following:  Import the NetworkModule in your project, as shown above. In the template of one of your components, insert the sq-network component: &lt;sq-facet-card [title]=&quot;'Network'&quot; [icon]=&quot;'fas fa-project-diagram'&quot;&gt; &lt;sq-network #facet [results]=&quot;results&quot; [providers]=&quot;providers&quot;&gt;&lt;/sq-network&gt; &lt;/sq-facet-card&gt; In the controller of that component, import an Out-of-the-box sample and import the ProviderFactory. Then initialize the providers variable: import { NetworkProvider, ProviderFactory, oOTBConfig } from '@sinequa/analytics/network'; @Component({ ... }) export class MyComponent { providers: NetworkProvider[] = []; constructor( ..., public providerFactory: ProviderFactory ) { this.providers = oOTBConfig(providerFactory); }   At this point, you should have a network component displaying standard entities (people, companies, geos), and their relations with selected documents. Other samples are available (most of them documented below). To explore them, look in the network-sample-config.ts file.  A natural next step is to customize these samples by copying and modifying their code into your component.  At some point, you may feel restricted by what is shown in these samples. We recommend looking into the code of the factory itself (provider-factory.ts), to learn how to further customize node types, edge types and providers.  Finally, keep in mind that nothing prevents you from programming your own providers. Have a look at the existing ones, and try using inheritance when possible (at the very least, extending the BaseProvider).  ","version":"Next","tagName":"h2"},{"title":"Network Component​","type":1,"pageTitle":"Network Module","url":"/dokku/docs/libraries/analytics/network#network-component","content":" The sq-network component is a facet component (See Facet module), which is best used within a facet card:  &lt;sq-facet-card [title]=&quot;'Network'&quot; [icon]=&quot;'fas fa-project-diagram'&quot;&gt; &lt;sq-network #facet [results]=&quot;results&quot; [providers]=&quot;providers&quot;&gt;&lt;/sq-network&gt; &lt;/sq-facet-card&gt;   The component primarily requires a list of providers as input (NetworkProvider objects), which generate the data displayed in the network. The results input is essentially used to refresh the providers when new results come in.  ","version":"Next","tagName":"h2"},{"title":"Architecture​","type":1,"pageTitle":"Network Module","url":"/dokku/docs/libraries/analytics/network#architecture","content":" The goal of the network component is to display data in the form of nodes (Node objects) and edges (Edge objects).  These node and edge objects are generated by providers (NetworkProvider objects). The sq-network component constantly listens to its input providers, and combines all their nodes and edges into a single graph.  Nodes and edges are bundled in a container called a dataset (NetworkDataset class). So providers essentially emit a dataset (whenever the data needs to be refreshed), and the component just merges the latest version of the datasets emitted by each provider.    The purpose of this architecture is to break down the vast space of network configurations into small composable bricks. For example, it is very easy to combine data coming from aggregations with data coming from records.  ","version":"Next","tagName":"h2"},{"title":"Interface​","type":1,"pageTitle":"Network Module","url":"/dokku/docs/libraries/analytics/network#interface","content":" The NetworkProvider interface contains the following fields and methods:  active: boolean: Whether or not the provider is active (if inactive, it will provide empty datasets of nodes and edges)name: string: A name for this provider (for displays in menus)dataset: NetworkDataset: A dataset object which is filled by this providercontext: NetworkContext: A convenience wrapper containing some globally accessible parametersgetProvider(): Subject&lt;NetworkDataset&gt;: Returns the Subject of this provider. The subject is an event emitter which can provide a new dataset at any time.getData(context: NetworkContext): Typically called on initialization, or when new results come in, to trigger a new Dataset to be emitted by the provider (synchronously or not).onDatasetsMerged(dataset: NetworkDataset): A method called after the datasets provided by all providers have been merged into a single datasetonNodesInserted(nodes: Node[]): A method called after the dataset is filtered (to keep only visible nodes) and passed to Vis for renderingonNodeClicked(node: Node | undefined): A method called when ANY node is cliked in the rendered view of the networkonEdgeClicked(edge: Edge | undefined): A method called when ANY edge is cliked in the rendered view of the networkgetProviderActions(): Action[]: A method called to retrieve the list of action for this providergetNodeActions(node: Node): Action[]: A method called to retrieve the list of actions for a given node, and this provider.getEdgeActions(edge: Edge): Action[]: A method called to retrieve the list of actions for a given edge, and this provider.onDestroy(): A method called when the providers are discarded. Can be use to cancel subscriptions.  This interface is implemented by a number of pre-packaged providers documented below. Developers are of course welcome to develop their own providers to customize how the network component works. Note that a BaseProvider is available, with convenience methods to create nodes and edges, and a default implementation of the NetworkProvider interface.  ","version":"Next","tagName":"h2"},{"title":"Node and Edge types​","type":1,"pageTitle":"Network Module","url":"/dokku/docs/libraries/analytics/network#node-and-edge-types","content":" Providers require as inputs some types for the nodes and edges. These types are respectively NodeType and EdgeType objects. These types determine the visual appearances (color, size, etc.) of the nodes and edges, thanks to a wide range of options available in the Vis.js library.  The NodeType interface contains the following fields and options:  name: string: An identifier for this node typenodeOptions: Node options define the appearance of a node. The full list of available node options is available in the Vis.js documentation. nodeOptions can be a static object (all the nodes with this type will look the same) or a function returning an object (which allows to customize the appearance for each node).field?: string: An optional field name for this node type. If provided, the node will have the ability to filter the search (for example clicking on the node &quot;Paris&quot;, will let the user filter the search with a selection of the form geo:=Paris).  Examples:  A node type with static options:  const type = { name: &quot;geo&quot;, nodeOptions: { shape: &quot;icon&quot;, icon: { face: &quot;'FontAwesome'&quot;, code: &quot;\\uf007&quot;, size: 50, color: &quot;#aa00ff&quot;, }, } }   A node type with dynamic options (the size is determined in function of the node's label):  const type = { name: &quot;geo&quot;, nodeOptions: (node: Node, type: NodeType) =&gt; { const size = node.label === &quot;Paris&quot;? 100 : 50; return { shape: &quot;icon&quot;, icon: { face: &quot;'FontAwesome'&quot;, code: &quot;\\uf007&quot;, size: size, color: &quot;#aa00ff&quot;, }, } } }   The EdgeType interface contains the following fields and options:  nodeTypes: NodeType[]: The node types for each side of the edge. Normally two node types must be provided (except in some special cases).edgeOptions: Edge options define the appearance of an edge. The full list of available edge options is available in the Vis.js documentation. edgeOptions can be a static object (all the edges with this type will look the same) or a function returning an object (which allows to customize the appearance for each edge).field?: string: An optional field name for this edge type. If provided, the edge will have the ability to filter the search (the provider generating this edge must include the fieldValue for the edge). Alternatively, an edge can let the user filter both its adjacent nodes (if both of them have a field).  ","version":"Next","tagName":"h2"},{"title":"Provider Factory​","type":1,"pageTitle":"Network Module","url":"/dokku/docs/libraries/analytics/network#provider-factory","content":" Rather than creating providers and node types manually, the ProviderFactory can be injected into an app in order to easily generate the objects and configuration needed in a specific project:  import { ProviderFactory } from '@sinequa/analytics/network'; @Component({ ... }) export class MyComponent { constructor( ... public providerFactory: ProviderFactory )   The factory includes convenience methods for creating all built-in types of nodes, edges and providers.  ","version":"Next","tagName":"h2"},{"title":"Samples​","type":1,"pageTitle":"Network Module","url":"/dokku/docs/libraries/analytics/network#samples","content":" On top of the factory, we provide samples of provider configurations (generated via the factory) in network-sample-config.ts.    The following providers are all illustrated by multiple samples. Samples are convenient to quickly start displaying data, but they must be modified for any customized project. We recommand copying the code of the sample(s) closest to your needs into your project, and modifying it from there.  ","version":"Next","tagName":"h2"},{"title":"List of providers​","type":1,"pageTitle":"Network Module","url":"/dokku/docs/libraries/analytics/network#list-of-providers","content":" ","version":"Next","tagName":"h2"},{"title":"Records Provider​","type":1,"pageTitle":"Network Module","url":"/dokku/docs/libraries/analytics/network#records-provider","content":" The class RecordsProvider provides nodes that are generated from a list of Record objects (&quot;record&quot; is a generic term for the content of a Sinequa index, returned in the form of Record objects by the QueryWebService).  Additionally, the provider can generate nodes and edges for the properties contained in that record. For example, if a record has &quot;person&quot; entities as a property, each of these &quot;person&quot; entity can be displayed as a property linked to the record:  // Create a standard &quot;document&quot; node type const doc = providerFactory.createRecordNodeType(); // Create a standard &quot;person&quot; node type const person = providerFactory.createPersonNodeType(); // Create an edge type for the &quot;person&quot; property of the &quot;document&quot; node const struct = providerFactory.createStructuralEdgeTypes(doc, [person], &quot;oninsert&quot;, &quot;all&quot;); // Create a provider that provides document nodes with their structural neighbors, given a list of record objects const provider = providerFactory.createRecordsProvider(doc, struct, records);     The sample code above demonstrate the usage of the factory's createStructuralEdgeTypes() method. Additional methods exist to create advanced types of structural edges:  createCoocStructuralEdgeTypes() creates edges for cooccurrence entities (proximity relations).createTypedCoocStructuralEdgeTypes() creates edges for typed cooccurrence entities (semantic relations).  For example:  const doc = providerFactory.createRecordNodeType(); const person = providerFactory.createPersonNodeType(); const company = providerFactory.createCompanyNodeType(); const struct = providerFactory.createTypedCoocStructuralEdgeTypes(doc, [person, company], &quot;person_job_company&quot;, &quot;oninsert&quot;, &quot;all&quot;); const provider = providerFactory.createRecordsProvider(doc, [struct], records);     Note that it is possible to hide the underlying record node, if we are only interested in the metadata:  // Note the fourth argument (true) const provider = providerFactory.createRecordsProvider(doc, [struct], records, true);     ","version":"Next","tagName":"h3"},{"title":"Selected Records Providers​","type":1,"pageTitle":"Network Module","url":"/dokku/docs/libraries/analytics/network#selected-records-providers","content":" The SelectedRecordsProvider class is a direct extension of RecordsProvider. The difference is that the provider listens to the SelectionService and provides record nodes from the list of selected records.  ⚠️ The SelectionService must be set-up to store records instead of just record ids (See Selection module).  This provider lets you easily see the common properties of two or more selected records.  // Create a standard &quot;document&quot; node type const doc = providerFactory.createRecordNodeType(); // Create a standard &quot;person&quot; node type const person = providerFactory.createPersonNodeType(); // Create an edge type for the &quot;person&quot; property of the &quot;document&quot; node const struct = providerFactory.createStructuralEdgeTypes(doc, [person], &quot;oninsert&quot;, &quot;all&quot;); // Create a provider that provides document nodes with their structural neighbors, from the list of selected records const provider = providerFactory.createSelectedRecordsProvider(doc, struct);     ","version":"Next","tagName":"h3"},{"title":"Async Records Providers​","type":1,"pageTitle":"Network Module","url":"/dokku/docs/libraries/analytics/network#async-records-providers","content":" The AsyncRecordsProvider class is a direct extension of RecordsProvider. The difference is that the provider requires a Query object, which is used to fetch a list of records, and these records are then transformed into nodes (as described above).  // Create a custom &quot;document&quot; node type that displays an image (which URL is stored in the `sourcevarchar4` column) const doc = providerFactory.createNodeType(&quot;doc&quot;, providerFactory.createDynamicImageNodeOptions( (node: Node) =&gt; (node as RecordNode).record['sourcevarchar4'] ) ); // Build a query to retrieve articles about humans from a wikipedia index const query = searchService.makeQuery(); query.text = &quot;google&quot;; query.addSelect(&quot;treepath:=/Web/Wiki/&quot;); query.addSelect(&quot;category:=human&quot;); // Special column from the wikipedia index query.pageSize = 5; // Create a provider that provides document nodes obtained from a query const provider = providerFactory.createAsyncRecordsProvider(doc, [], query);     Notice here that we did not use the factory's built-in method for generating a node type for records/documents (createRecordNodeType()). Instead we used the generic createNodeType() method, and used the factory to generate dynamic node options. The options are &quot;dynamic&quot;, because each node will look different from the others (indeed, we want each node to show the picture of a person). The createDynamicImageNodeOptions() requires a function taking the node as an input, and returning the URL of the image (in this case stored in the record's sourcevarchar4 column). See Node and Edge types.  ","version":"Next","tagName":"h3"},{"title":"Aggregation Provider​","type":1,"pageTitle":"Network Module","url":"/dokku/docs/libraries/analytics/network#aggregation-provider","content":" The AggregationProvider class provides nodes and edges generated from an aggregation. Aggregations are computed by the Sinequa engine based on the content of one column (or more) of an index. Aggregation are typically used to compute the content of facets (See Facet Module).  The aggregation provider can be used to generate different types of relations between metadata:  Statistical relations: In this case, we use cross-aggregations to count the number of records which contain two values of metadata. For example, we can count how many documents both have docformat=pdf and author=John Doe. The most frequent pairs of metadata are translated into edges between these metadata.Proximity relations: In this case, we use aggregations to count the number of cooccurence entities stored within a specific column. A cooccurrence entity stores the occurrence of two other entities within a short range of text, like in the sentence &quot;Larry Page works at Google&quot;, which could be normalized as (LARRY PAGE)#(GOOGLE). The cooccurrences are then translated as edges between each entity.Semantic relations: In this case, we use aggregations to count the number of semantic entities stored within a specific column. A semantic entity stores the typed relation between two entities, like in the sentence &quot;Larry Page is an engineer who works at the company Google&quot; (unlike in the previous example, &quot;work at&quot; can be normalized as a type of relation between the two entities, so that this sentence could be stored as (GOOGLE)#(EMPLOYS)#(LARRY PAGE)). Then this relation between the two entities can be visualized as a directed typed edge.  Assuming the entities are properly extracted from documents, normalized and stored in columns of the index, the following example describe how to use the AggregationProvider to produce different types of network visualizations.  Note that in all cases, aggregations are computed in the context of the current query of the SearchService, unless a different Query is passed to the provider as an optional input. This means if you search for &quot;Google&quot;, the top relations built by this provider should normally include companies like Google, and people like Larry Page.  Statistical relations​  First we need to configure the cross-aggregation calculation on the server in the Query web service (see Server configuration).  Configuration for a cross-aggregation between the company and person columns  // Create two standard node types for persons and companies const person = providerFactory.createPersonNodeType(); const company = providerFactory.createCompanyNodeType(); // Create an edge type between these two node types const edge = providerFactory.createAggregationEdgeType([company, person], &quot;Company_Person&quot;) // Create the provider, given the edge type const provider = providerFactory.createAggregationProvider([edge]);     Note that the size of each node is proportional to the width of adjacent edges, which itself reflects the &quot;count&quot; of each pair in the distribution (which is equal to the number of documents containing both metadata).  Proximity relations​  First we need to configure the aggregation calculation on the server in the Query web service (see Server configuration).  The aggregation must be computed for a column where co-occurrences are stored in the format (VALUE 1)#(VALUE 2).  The code below is almost identical to the one above for statistical relations. The difference is that we are calling the createCoocAggregationEdgeType() method instead of createAggregationEdgeType().  // Create two standard node types for persons and companies const person = providerFactory.createPersonNodeType(); const company = providerFactory.createCompanyNodeType(); // Create an cooccurrence aggregation edge type between these two node types const edge = providerFactory.createCoocAggregationEdgeType([company, person], &quot;Company_Person_Cooc&quot;) // Create the provider, given the edge type const provider = providerFactory.createAggregationProvider([edge]);     Semantic relations​  First we need to configure the aggregation calculation on the server in the Query web service (see Server configuration).  The aggregation must be computed for a column where co-occurrences are stored in the format (VALUE 1)#(TYPE)#(VALUE 2).  The code below is almost identical to the one above for statistical relations. The difference is that we are calling the createTypedCoocAggregationEdgeType() method instead of createAggregationEdgeType().  // Create two standard node types for persons and companies const person = providerFactory.createPersonNodeType(); const company = providerFactory.createCompanyNodeType(); // Create a typed cooccurrence aggregation edge type between these two node types const edge = providerFactory.createTypedCoocAggregationEdgeType([person, company], &quot;Person_Job_Company_Cooc&quot;) // Create the provider, given the edge type const provider = providerFactory.createAggregationProvider([edge]);     Expanding nodes​  In the example aboves, the aggregation edges are created with trigger=&quot;source&quot;, which means the data is fetched right away and inserted in the network.  But, it is also possible to use aggregations to attach new nodes to existing nodes (&quot;expanding&quot; them). In this case, instead of using cross-distributions or cooccurrence, a regular 1-dimension aggregation must be provided.  The provider will query the server for this distribution, and adding a WHERE clause to &quot;fix&quot; the source node. For example, if we want to expand the node Paris of type geo, with say, companies, the distribution queried to the server will be computed with:  SELECT DISTRIBUTION('company') as companies FROM ... WHERE ... AND geo = 'Paris' ...   Note that the SKIP and COUNT parameter of the distribution are automatically adjusted by the provider, so that expanding the node multiple times will yield more data (until exhaustion).  This computation is equivalent to a cross distribution of geo and company (where one half is fixed). Therefore combining &quot;source&quot; cross-distribution edges with &quot;onclick&quot; or &quot;manual&quot; will be consistent.  // Create two standard node types for persons and companies const person = providerFactory.createPersonNodeType(); const company = providerFactory.createCompanyNodeType(); // Create an edge type between these two node types const edge = providerFactory.createAggregationEdgeType([company, person], &quot;Company_Person&quot;) // Create an edge type to expand &quot;company&quot; with the &quot;person&quot; distribution. &quot;manual&quot; means a button is displayed when clicking on a company node to create the expansion. const expandCompany = providerFactory.createAggregationEdgeType([company, person], &quot;person&quot;, undefined, &quot;manual&quot;); // Create the provider, given the edge type const provider = providerFactory.createAggregationProvider([edge, expandCompany]);     ","version":"Next","tagName":"h3"},{"title":"Dynamic providers​","type":1,"pageTitle":"Network Module","url":"/dokku/docs/libraries/analytics/network#dynamic-providers","content":" Dynamic providers are extensions of RecordsProvider. The list of records is fetched dynamically from the server, given a query. There are two types of dynamic providers:  Dynamic edge provider: Provides record nodes (and optionally their structural edges) that will be attached to existing nodes via &quot;dynamic edges&quot;.Dynamic node provider: Transforms an existing node into a record node (and its structural edges)  ⚠️ Dynamic providers can potentially generate multiple parallel queries to the engine, depending on the settings you choose. Be careful not overflowing the engine and optimizing your queries as much as possible.  Dynamic edge provider​  A dynamic edge provider (DynamicEdgeProvider) attaches record nodes to an existing node. For example, we can create a first record provider that generates nodes for documents, and when these nodes are inserted, we query the engine for people nodes related to these documents.  // Create a standard document node type const doc = providerFactory.createRecordNodeType(); // Create a standard provider for records const recordProvider = providerFactory.createRecordsProvider(doc, [], records); // Create a node type of people, displaying the image of that person instead of a generic icon const people = providerFactory.createNodeType(&quot;person&quot;, providerFactory.createDynamicImageNodeOptions( (node: Node) =&gt; (node as RecordNode).record['sourcevarchar4'] || &quot;&quot; ) ); // Create a dynamic edge type, that creates a query to fetch people related to that document const dynamicEdgeType = providerFactory.createDynamicEdgeType([doc, people], &quot;oninsert&quot;, (node: Node, type: DynamicEdgeType) =&gt; { const query = searchService.makeQuery(); query.text = node.label; query.addSelect(&quot;treepath:=/Web/Wiki/&quot;); query.addSelect(&quot;category:=human&quot;); // Special column from the wikipedia index query.pageSize = 5; return query; }); // Create a dynamic edge provider to create the dynamic edges whose type we just defined const peopleProvider = providerFactory.createDynamicEdgeProvider(dynamicEdgeType, [], true, &quot;People&quot;, [recordProvider]);     Note that the dynamic edge provider creates record nodes which can themselves have structural edges:  const company = providerFactory.createCompanyNodeType(); const struct = providerFactory.createStructuralEdgeTypes(people, [company]); const peopleProvider = providerFactory.createDynamicEdgeProvider(dynamicEdgeType, struct, true, [recordProvider]);     Dynamic node provider​  A dynamic node provider (DynamicNodeProvider) transforms (&quot;mutates&quot;) an existing node into a record node. For example, a metadata node for the person &quot;Bill Gates&quot; can be enriched with the wikipedia article about Bill Gates.  In the following example, we start by creating an aggregation provider, displaying people and company relations. But the second provider enriches people nodes (when clicked on) with their wikipedia page (which allows to transform the appearance of the node and display their wikipedia pictures instead of an icon).  // Create the node types for the company and person entities const company = providerFactory.createCompanyNodeType(); const person = providerFactory.makeNodeTypeDynamic( // By default, the node is a standard person node providerFactory.createPersonNodeType(), // This function returns the query necessary to transform the node (node: Node) =&gt; { let query = searchService.makeQuery(); query.text = node.label; query.addSelect(&quot;treepath:=/Web/Wiki/&quot;); query.addSelect(&quot;category:=human&quot;); // Special column from the wikipedia index query.pageSize = 1; return query }, // The node options to use after the node has been transformed (displaying an image instead of an icon) providerFactory.createDynamicImageNodeOptions( (node: Node) =&gt; (node as RecordNode).record['sourcevarchar4'] || &quot;&quot; ) ); // Create structural edges from the document nodes to the person and company entities const structEdges = providerFactory.createStructuralEdgeTypes(person, [company, person], &quot;oninsert&quot;, &quot;paginate&quot;); // Create aggregation edges to link companies and people const company_person = providerFactory.createAggregationEdgeType([company, person], &quot;Company_Person&quot;); // Create the aggregation provider const aggProvider = providerFactory.createAggregationProvider([company_person]); // Create the dynamic node provider const personProvider = providerFactory.createDynamicNodeProvider(person, structEdges, false, &quot;People&quot;, [aggProvider]);     ","version":"Next","tagName":"h3"},{"title":"Interactions​","type":1,"pageTitle":"Network Module","url":"/dokku/docs/libraries/analytics/network#interactions","content":" When clicking on a node or edge, it is possible to display info cards, which display information, and actions, which display buttons or menus associated with the given node or edge.  ","version":"Next","tagName":"h2"},{"title":"Info cards​","type":1,"pageTitle":"Network Module","url":"/dokku/docs/libraries/analytics/network#info-cards","content":" Info cards templates can be provided to the sq-network component by transclusion:  &lt;sq-network #facet [results]=&quot;results&quot; [providers]=&quot;providers&quot;&gt; &lt;ng-template #nodeTpl let-node&gt; &lt;h1&gt;This node is named: {{ node.label }}&lt;/h1&gt; &lt;/ng-template&gt; &lt;/sq-network&gt;   And similarly for the edge info card:  &lt;sq-network #facet [results]=&quot;results&quot; [providers]=&quot;providers&quot;&gt; &lt;ng-template #edgeTpl let-edge&gt; &lt;h1&gt;This edge goes from {{ edge.from }} to {{ edge.to }}&lt;/h1&gt; &lt;/ng-template&gt; &lt;/sq-network&gt;   Two components are provided as samples for node and edge info cards, but these should be typically modified and adapted to the specifics of the project.  Node and edge info cards:  &lt;sq-network #facet [results]=&quot;results&quot; [providers]=&quot;providers&quot;&gt; &lt;ng-template #nodeTpl let-node&gt; &lt;sq-node-info-card [node]=&quot;node&quot;&gt;&lt;/sq-node-info-card&gt; &lt;/ng-template&gt; &lt;ng-template #edgeTpl let-edge&gt; &lt;sq-edge-info-card [edge]=&quot;edge&quot;&gt;&lt;/sq-edge-info-card&gt; &lt;/ng-template&gt; &lt;/sq-network&gt;       ","version":"Next","tagName":"h3"},{"title":"Actions​","type":1,"pageTitle":"Network Module","url":"/dokku/docs/libraries/analytics/network#actions","content":" Actions associated to a node, edge or provider are displayed as buttons or menus in the facet card header:    These &quot;actions&quot; (see Action module) come from the providers (NetworkProvider) and can be customized by overriding an existing provider or implementing your own provider from scratch (in fact a provider can be created for the sole purpose of displaying actions for some categories of nodes or edges).  The providers have three methods that can be implemented to provide actions:  getProviderActions(): Action[]: Return a list of Action objects associated to the provider. These actions are displayed regardless of the node or edge currently focused. The actions are nested in a menu displaying the actions for all providers:  List of actions for the provider &quot;Aggregations&quot;  getNodeActions(node: Node): Action[]: Returns a list of Action objects specific to a given node. These actions are displayed when the node is clicked or focused. ⚠️ This method is called when ANY node is clicked, not just nodes from this provider.  List of actions for the node &quot;Google&quot;  getEdgeActions(edge: Edge): Action[]: Returns a list of Action objects specific to a given edge. These actions are displayed when the edge is clicked or focused. ⚠️ This method is called when ANY edge is clicked, not just edges from this provider.  Note that the BaseProvider implementation already provides basic actions common to all providers, and all the providers documented above also provide actions when possible and relevant.  Below is a sample implementation (from the DynamicNodeProvider class) to display an action specific to a given node. Notice that we call the parent method (super.getNodeActions(node)) to also display the built-in actions from the parent. Also note that we preprend the list (with unshift()) to display this custom action before the built-in actions.  /** * Creates an action to process a clicked node, for dynamic node types * with a &quot;manual&quot; trigger. * @param node The clicked node */ getNodeActions(node: RecordNode): Action[] { const actions = super.getNodeActions(node); if(this.active &amp;&amp; this.nodeType.trigger === &quot;manual&quot; &amp;&amp; node &amp;&amp; node.type === this.nodeType &amp;&amp; this.processedNodes.indexOf(node.id) === -1) { actions.unshift(new Action({ icon: &quot;fas fa-star-of-life&quot;, title: this.context.intlService.formatMessage(&quot;msg#network.actions.expandNode&quot;, {label: node.label}), action: () =&gt; { this.processNode(node); } })); } return actions; }  ","version":"Next","tagName":"h3"},{"title":"Autocomplete Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/components/autocomplete","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Autocomplete Module","url":"/dokku/docs/libraries/components/autocomplete#features","content":" ","version":"Next","tagName":"h2"},{"title":"Standard features​","type":1,"pageTitle":"Autocomplete Module","url":"/dokku/docs/libraries/components/autocomplete#standard-features","content":" This module provides functionality to display an autocomplete dropdown panel under a search form:  A directive applied to the form's &lt;input&gt; to listen to user inputs, send autocomplete queries and process the results.A service that sends the autocomplete queries to the backend server and provides additional services.A component that displays these results (styled with the Bootstrap library).  Both the directive and the component are largely extensible and customizable (See Vanilla Search).    Schematically, the code looks as follow:  &lt;form&gt; &lt;input type=&quot;text&quot; sqAutocomplete [dropdown]=&quot;mydropdown&quot;&gt; &lt;button type=&quot;submit&quot;&gt;Search&lt;/button&gt; &lt;sq-autocomplete-list #mydropdown&gt; &lt;ng-template #itemTpl let-item&gt; {{ item.display }} &lt;/ng-template&gt; &lt;/sq-autocomplete-list&gt; &lt;/form&gt;   ","version":"Next","tagName":"h3"},{"title":"Import​","type":1,"pageTitle":"Autocomplete Module","url":"/dokku/docs/libraries/components/autocomplete#import","content":" Import this module in your app.module.ts.  import { BsAutocompleteModule } from '@sinequa/components/autocomplete'; @NgModule({ imports: [ ... BsAutocompleteModule   ","version":"Next","tagName":"h2"},{"title":"Standard Autocomplete​","type":1,"pageTitle":"Autocomplete Module","url":"/dokku/docs/libraries/components/autocomplete#standard-autocomplete","content":" ","version":"Next","tagName":"h2"},{"title":"Autocomplete Directive​","type":1,"pageTitle":"Autocomplete Module","url":"/dokku/docs/libraries/components/autocomplete#autocomplete-directive","content":" The sqAutocomplete directive (applied to the &lt;input&gt; element) listens to user interactions (keyboard inputs, mouse inputs, blur and focus events), sends autocomplete queries to the backend (via the SuggestService) and controls the dropdown component (what to display, when to display it and what to do when an item is selected).  The directive has several inputs:  dropdown: A reference to the dropdown component. This component is not necessarily sq-autocomplete-list, but it needs to implement the AutocompleteComponent interface.suggestQuery: The name of the &quot;Suggest Query&quot; configured on the server. This value can be hard-coded, or provided by via the AppService.suggestQueries list (post-login).off (default: false): Whether the directive is turned off or not.suggestDelay (default: 200): Number of milliseconds between queries sent to the server.placeholder (default: ''): Placeholder to display when no text is written in the input.  It also provides the following outputs (Event emitters):  stateChange: Emits the state of the autocomplete (OFF, INIT, START, ACTIVE, OPENED, SELECTED)submit: Fires when the users &quot;submits&quot; the query (by typing Enter)  Of course, other attributes and directives may be applied along with the sqAutocomplete directive. For example we may have the following:  &lt;input type=&quot;text&quot; formControlName=&quot;search&quot; class=&quot;form-control&quot; spellcheck=&quot;false&quot; autocomplete=&quot;off&quot; [sqAutofocus]=&quot;autofocus&quot; sqAutocomplete [placeholder]=&quot;'msg#searchForm.searchFor' | sqMessage&quot; [dropdown]=&quot;dropdown&quot; [off]=&quot;!loginService.complete || !appService.suggestQueries&quot; [suggestQuery]=&quot;appService.suggestQueries? appService.suggestQueries[0] : ''&quot; (submit)=&quot;search()&quot;&gt;   You can customize the behavior of the directive by extending it and enriching it. The following methods can be overridden:  getSuggests(): Takes the text typed by the user to get suggestions (via getSuggestsObs()) and pass them to processSuggests(). This method can be overridden to modify the text read in the input element and passed to getSuggestObs().getSuggestsObs(): Makes a call to the SuggestService to obtain suggestions (which are then passed to processSuggests()). It can be overridden to obtain suggestions in a different way (this is the case in Vanilla Search).processSuggests(items): Update the dropdown component with the suggestions. This method can be overridden to post process or filters the suggestions before they are displayed.select(item) or setAutocompleteItem(item): Methods called when an item is selected from the dropdown panel (either with the mouse or keyboard navigation). By default, the &lt;input&gt; text is set to the value of the autocomplete item, but other behavior can be implemented (opening a document, searching a custom query, etc.; this is the case in Vanilla Search)State change methods: init(), start(), active(), open(), select(). They can be overridden to insert new states or execute some custom code in specific states.  The transition between the different states is depicted below:    ","version":"Next","tagName":"h3"},{"title":"Suggest Service​","type":1,"pageTitle":"Autocomplete Module","url":"/dokku/docs/libraries/components/autocomplete#suggest-service","content":" The SuggestService provides the following methods:  get(suggestQuery: string, text: string, fields?: string | string[], query?: Query, maxCount = 10): Observable&lt;ScoredAutocompleteItem&lt;undefined,string&gt;[]&gt;: This method uses both SuggestQueryWebService and SuggestFieldWebService to obtain suggestions from the server. It combines actual suggestions from suggest queries with suggestions of fields (when fielded search is active). async searchData&lt;T, Tcat extends string&gt;(category: Tcat, query: string, data: T[], primaryText: (obj:T) =&gt; string, secondaryText?: (obj:T) =&gt; string[], label?: string) : Promise&lt;ScoredAutocompleteItem&lt;T, Tcat&gt;[]&gt;: This method allows to search within a list of objects of any type (T). It is useful to search within a small number of user objects on the client side. For example, in Vanilla Search, it is used to search within the recent queries, recent documents, saved queries and baskets. It expects the following inputs: category: The name of the AutocompleteItem category to be created as a result of this search.query: The text you want to search for.data: The list of objects you want to search in.primaryText: A function that takes in an object and outputs the primary text field to search in (eg. if objects are records, the primary field could be the title).secondaryText (optional): A function that takes in an object and outputs a list of secondary text fields to search in.label (optional): The label of the AutocompleteItem category to be created as a result of this search.  ","version":"Next","tagName":"h3"},{"title":"Autocomplete List Component​","type":1,"pageTitle":"Autocomplete Module","url":"/dokku/docs/libraries/components/autocomplete#autocomplete-list-component","content":" The sq-autocomplete-list component is a fairly simple component that displays the list of suggestions from the directive. This component expects a ng-template named #itemTpl to be passed by transclusion, to actually display the items:  &lt;sq-autocomplete-list #mydropdown&gt; &lt;ng-template #itemTpl let-item&gt; {{ item.display }} &lt;/ng-template&gt; &lt;/sq-autocomplete-list&gt;   In the Vanilla Search application, the template (in search-form.component.html) looks like this:  &lt;ng-template #itemTpl let-item&gt; &lt;div class=&quot;autocomplete-item p-2&quot;&gt; &lt;i class=&quot;{{autocompleteIcon(item.category)}}&quot;&gt;&lt;/i&gt;&lt;!-- --&gt;&lt;span class=&quot;mx-2&quot; [innerHTML]=&quot;item.displayHtml || item.display&quot;&gt;&lt;/span&gt;&lt;!-- --&gt;&lt;small *ngIf=&quot;item.category&quot; class=&quot;autocomplete-category ml-2&quot;&gt;{{(item.label || item.category) | sqMessage}}&lt;/small&gt; &lt;/div&gt; &lt;/ng-template&gt;   You can customize the component by customizing the content of#itemTpl. Note that item is an AutocompleteItem passed by the directive.  You can also write you own component entirely, as long as:  You tag it and pass it to the directive (#mydropdown in the example above).Your component implements the AutocompleteComponent interface. This interface requires you to implement the following methods: hasItems(boolean): Whether there are any item to displayclicked(EventEmitter&lt;AutocompleteItem&gt;): Event emitter for clicks on an autocomplete itemselectedValue(AutocompleteItem): The currently selected item, if anyupdate(active: boolean, items?: AutocompleteItem[]): Method called to pass data to this component. If active==false, the component should be closed.selectNext(): Select and return the next AutocompleteItem in the list.selectPrevious(): Select and return the previous AutocompleteItem in the list.  ","version":"Next","tagName":"h3"},{"title":"Server-side configuration​","type":1,"pageTitle":"Autocomplete Module","url":"/dokku/docs/libraries/components/autocomplete#server-side-configuration","content":" The autocomplete functionality is built on top of two web services of the Sinequa REST API:  Suggest Query Web Service (api/v1/suggestquery)Suggest Field Web Service (api/v1/suggestfield)  ","version":"Next","tagName":"h2"},{"title":"Suggest Query Web Service​","type":1,"pageTitle":"Autocomplete Module","url":"/dokku/docs/libraries/components/autocomplete#suggest-query-web-service","content":" The Suggest Query web service uses a Suggestion Query configured on the Sinequa server to generate suggestions. These queries can be created and managed in the Sinequa administration, under Search-Based Applications &gt; App Dependencies &gt; Suggestion Queries.  Standard configuration of a Suggestion Query  A suggestion query is associated to a Suggestion Lexicon. The lexicon contains all the terms which can be used as suggestions. These terms are generated from the index content, and each one belongs in a &quot;kind&quot; (by default the kind just corresponds to the name of the column from which the term is extracted).  Configuration of a suggestion lexicon  The &quot;kind&quot; (or &quot;category&quot;) is important, as it is used in fielded search to request suggestions for a specific field. For example, when autocompleting the field company, we do not want any kind of suggestion: We want only suggestions belonging to the &quot;company&quot; kind / category.  ⚠️ Be careful, as there are typically some differences the between the column names defined in the suggest lexicon and the field names used in your SBA, because of aliases. If you define an alias for the field &quot;company&quot; (and you want this field to be autocompleted), it might be a good idea to use the same alias for the &quot;kind&quot; of this column in the lexicon.  ","version":"Next","tagName":"h3"},{"title":"Suggest Field Web Service​","type":1,"pageTitle":"Autocomplete Module","url":"/dokku/docs/libraries/components/autocomplete#suggest-field-web-service","content":" When we request the Suggest Query web service for a specific &quot;kind&quot;, but no results are returned, the Suggest Field Web Service is used as a fallback.  The Suggest Field web service does not use a lexicon to create suggestions. Instead, it directly queries the engine for data, using a distribution, and using the prefixes option to filter the searched text. If you search suggestions for the field person, the requests look as follow:  SELECT DISTRIBUTION('person,count=100,basicforms=true,order2=labelasc,labels=true,prefixes=&quot;Barack Oba&quot;,caseinsensitive=true') AS dist FROM index WHERE &lt;security clause&gt; AND entity17 CONTAINS 'Barack Oba*' COUNT 1   There are various benefits to this approach:  The data is always up-to-date. No need to refresh a lexicon.This service is built-in and has no configuration attached.We can search in the context of a query (adding to the WHERE clause), which means the data is more relevant and secured.Also note that unlike the Suggest Query web service, this service resolves SBA aliases. (So if you defined an alias for the field person, the service knows it should actually request the engine for the person column).  However, this approach means more requests are sent to the engine, which can hinder performance. Also, the completion is limited to a simple prefix approach, unlike the Suggest queries and lexicons which have many options to manage more complex completion strategies. ","version":"Next","tagName":"h3"},{"title":"Action Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/components/action","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Action Module","url":"/dokku/docs/libraries/components/action#features","content":" This module provides the classes and directives to create menus and buttons. For example, all the menus in the navigation bar of Vanilla search are implemented using menu and action objects.  User menu in navigation bar  ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Action Module","url":"/dokku/docs/libraries/components/action#import","content":" Add import { BsActionModule } from '@sinequa/components/action'; into your app.module.ts.  Include BsActionModule in Angular import declaration of app.module.ts.  @NgModule({ imports: [ /*....*/ BsActionModule, /*....*/ ], /*....*/ })   ","version":"Next","tagName":"h2"},{"title":"API usage​","type":1,"pageTitle":"Action Module","url":"/dokku/docs/libraries/components/action#api-usage","content":" The most important declaration of this module is the Action class.  ","version":"Next","tagName":"h2"},{"title":"Action class​","type":1,"pageTitle":"Action Module","url":"/dokku/docs/libraries/components/action#action-class","content":" The Action class represents an element in a dropdown menu, take for example the User menu in the above screenshot, the button with the user icon and the two elements of the dropdown are Action object.  An Action can have zero or some children, the latter represents a dropdown menu whereas the former an action in a menu or a button.  Here are the list of commonly used properties of the Action class:  name: The name of the action, can be used as id to distinguish different actions of the same Action parent,text: The display text of the Action,title: The tooltip to show when hovering the Action,icon or iconAfter: The icon (css class) of the Action, if the name property is defined, the icon defined by icon will be displayed before the text while that by iconAfter is shown after the action text,separator: whether the Action is used as a separator in its parent Action,selected: if true, the display of the Action will start with a check icon (✔).disabled: if true, the Action is grayed out when it is displayed.hidden: if true, the Action is not shown.action: A function to execute when the button is clicked,updater: A function to execute before the button display is refreshed,update: When this method is called, updater function is called first.headerGroup: if true, the title property of the Action is used as a dropdown header displayed before children actions.  How to create a menu action or a button​  Example 1: A simple menu action that performs the logout procedure with display text  const logoutAction = new Action({ text: &quot;msg#userMenu.logout&quot;, title: &quot;msg#userMenu.logout&quot;, action: () =&gt; doLogout() });   Example 2: A simple menu action with an icon the universal-icon from fontawesome  const logoutAction = new Action({ icon: &quot;fas fa-universal-access&quot;, title: &quot;msg#action.tooltip&quot;, action: () =&gt; doSth() });   Example 3: A menu action that is shown once a condition is satisfied  const hiddenAction = new Action({ text: &quot;msg#action.name&quot;, // The text to display on the action button title: &quot;msg#action.tooltip&quot;,// The tooltip of the action hidden: true, action: (action) =&gt; { doSomething(); // The logout procedure to execute when the action is clicked, action.update(); // needed to call the `updater` callback updater: (action: Action) =&gt; { action.hidden = someConditionToCheck; } });   Example 4: A menu action whose text is changed depending on the value of an outside variable  someCounter = 0; const action = new Action({ text: &quot;msg#action.evenName&quot;, // The text to display on the action button title: &quot;msg#action.evenTooltip&quot;,// The tooltip of the action action: () =&gt; doSth(), updater: (item: Action) =&gt; { item.text = someCounter / 2 === 0 ? &quot;msg#action.evenName&quot; : &quot;msg#action.oddName&quot;; item.title = someCounter / 2 === 0 ? &quot;msg#action.evenTooltip&quot; : &quot;msg#action.oddTooltip&quot;; } }); /* *Some functions that may change the value of someCounter */ ... action.update(); // needed to call the `updater` callback   Example 5: A separator for the parent dropdown menu  const menu = new Action({ icon: 'some-icon-class', title: 'msg#menu.tooltip', children: [ new Action({ text: 'msg#menu.action1.text', title: 'msg#menu.action1.tooltip', action: () =&gt; fn1() }), new Action({ separator: true }), new Action({ text: 'msg#menu.action2.text', title: 'msg#menu.action2.tooltip', action: () =&gt; fn2() }), ] });   Example 5: A dropdown header for the children dropdown menu items  const menu = new Action({ icon: 'some-icon-class', title: 'msg#menu.tooltip', headerGroup: true, // `title` will be used as dropdown header children: [ new Action({ text: 'msg#menu.action1.text', title: 'msg#menu.action1.tooltip', action: () =&gt; fn1() }), new Action({ separator: true }), new Action({ text: 'msg#menu.action2.text', title: 'msg#menu.action2.tooltip', action: () =&gt; fn2() }), ] });   How to create a dropdown menu​  A dropdown menu is simply an Action object who has children but no action to execute (i.e. action property is undefined)  Take for example the dropdown menu to manage user alert in the navigation bar, the following code snippet shows how it is defined in the navigation bar.  Alert menu in navigation bar  Example 1: Alert dropdown menu in the navigation bar  const alertsActions: Action[] = []; const createAction = new Action({ text: &quot;msg#alerts.createAlert&quot;, title: &quot;msg#alerts.createAlert&quot;, action: () =&gt; createAlert(); }); const manageAction = new Action({ text: &quot;msg#alerts.manageAlerts&quot;, title: &quot;msg#alerts.manageAlerts&quot;, action: () =&gt; manageAlert(); }); alertsActions.push(createAction); alertsActions.push(manageAction); const alertMenu = new Action({ icon: &quot;some-icon-class&quot;, text: &quot;msg#alerts.alerts&quot;, children: alertsActions });   ","version":"Next","tagName":"h3"},{"title":"Directives and components​","type":1,"pageTitle":"Action Module","url":"/dokku/docs/libraries/components/action#directives-and-components","content":" Once you have defined your menus and buttons, you need to use one of the following directives or components to display them in the HTML template of your components  you can use the sq-action-buttons component that creates a menu of buttons.  Its input is an ActionButtonsOptions object:  items: the children Action elements of the menu,size: the size of the menu, the valid values are (in ascending order): &quot;xs&quot;, &quot;sm&quot;, &quot;md&quot;, &quot;lg&quot;, &quot;xl&quot;, &quot;xxl&quot;,style: extra css classes to apply.autoAdjust: whether to automatically change the visualisation of the menu and its children when resizing the browser window,autoAdjustBreakpoint: if autoAdjust is activated, this property defines the size of the browser window, at which the menu size can be adjusted instead of always adjusting the menu each time a resizing happens,rightAligned: whether the menu elements are right-aligned.  Example:  &lt;sq-action-buttons [sq-action-buttons]=&quot;{ items: [action1, action2], autoAdjust: true, rightAligned: rightAligned }&quot; &gt;&lt;/sq-action-buttons&gt;   Alternatively, you can use the sq-action-item component.  This component expects an ActionItemOptions object as input:  item: the Action object representing the menu,size: the size of the menu, the valid values are (in ascending order): &quot;xs&quot;, &quot;sm&quot;, &quot;md&quot;, &quot;lg&quot;, &quot;xl&quot;, &quot;xxl&quot;,style: the CSS class of the menu,autoAdjust: whether to automatically change the visualisation of the menu and its children when resizing the browser window,autoAdjustBreakpoint: if autoAdjust is activated, this property defines the size of the browser window, at which the menu size can be adjusted instead of always adjusting the menu each time a resizing happens,inMenu: if true, the menu element will have nav-link CSS class. Otherwise, they are set to dropdown-item,rightAligned: whether the menu elements are right-aligned.  Example:  &lt;div class=&quot;btn-group dropdown&quot; [sq-action-item]=&quot;{ item: item, size: size, style: style, autoAdjust: autoAdjust, autoAdjustBreakpoint: autoAdjustBreakpoint, rightAligned: rightAligned}&quot; &gt;&lt;/div&gt;   The sq-action-menu component is another way to create a dropdown menu.  This component expects the following values:  items: the children Action elements of the menu,size: the size of the menu, the valid values are (in ascending order): &quot;xs&quot;, &quot;sm&quot;, &quot;md&quot;, &quot;lg&quot;, &quot;xl&quot;, &quot;xxl&quot;,autoAdjust: whether to automatically change the visualisation of the menu and its children when resizing the browser window,autoAdjustBreakpoint: if autoAdjust is activated, this property defines the size of the browser window, at which the menu size can be adjusted instead of always adjusting the menu each time a resizing happens,right: whether the menu elements are right-aligned.  Example:  &lt;sq-action-menu [items]=&quot;items&quot; [autoAdjust]=&quot;true&quot; [autoAdjustBreakpoint]=&quot;'xxl'&quot; [right]=&quot;true&quot;&gt;&lt;/sq-action-menu&gt;   Finally, there is the sq-dropdown-menu directive.  The input of the directive is an (DropdownMenuOptions object):  item: the Action object represents the menu,rightAligned: whether the elements of the menu will be right-aligned,showMenuClass: the CSS class of the menu when it is shown.  Example:  &lt;ul [sq-dropdown-menu]=&quot;{item: menuAction, showMenuClass: menuClass}&quot;&gt;&lt;/ul&gt;  ","version":"Next","tagName":"h3"},{"title":"Timeline Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/analytics/timeline","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Timeline Module","url":"/dokku/docs/libraries/analytics/timeline#features","content":" This module includes a Timeline visualization for temporal data based on the D3 library. The timeline can display continuous time series (as a line/area plot) or punctual events (as interactive symbols).  The module includes two components:  A timeline component taking data as an input and displaying it, unaware of Sinequa's API and data structures.A &quot;facet&quot; component taking care of fetching, updating and pre-processing the data, and passing it to the timeline component.    ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Timeline Module","url":"/dokku/docs/libraries/analytics/timeline#import","content":" Import this module in your app.module.ts.  import { BsTimelineModule } from '@sinequa/analytics/timeline'; @NgModule({ imports: [ ... BsTimelineModule   ","version":"Next","tagName":"h2"},{"title":"Timeline Component​","type":1,"pageTitle":"Timeline Module","url":"/dokku/docs/libraries/analytics/timeline#timeline-component","content":" ","version":"Next","tagName":"h2"},{"title":"Time series​","type":1,"pageTitle":"Timeline Module","url":"/dokku/docs/libraries/analytics/timeline#time-series","content":" The sq-timeline component displays a SVG built with both D3 and Angular. Its most basic usage is as follow:    Additionally, the timeseries object (of type TimelineSeries) can take 3 additional parameters: lineStyles and areaStyles which allow to style the chart with css-like rules (SVG rules passed via ngStyle), and showDatapoints which allows to visualize the data points when hovering the timeline with the mouse.  this.timeseries = [ { name: 'my series', dates: [ ... ], primary: true, lineStyles: {'stroke': 'red', 'stroke-width': '3px'}, areaStyles: {'fill': 'none'}, showDatapoints: true } ];     You can combine multiple series. At least one must have primary: true to serve as reference for computing the x-axis.  this.timeseries = [ { name: 'series 1', dates: [ {date: new Date('2020-01-01'), value: 42.3}, {date: new Date('2020-02-01'), value: 58.4}, {date: new Date('2020-03-01'), value: 21.0}, {date: new Date('2020-04-01'), value: 3.1}, {date: new Date('2020-05-01'), value: 34.3}, ], primary: true, lineStyles: {'stroke': 'red'}, areaStyles: {'fill': 'none'}, showDatapoints: true }, { name: 'series 2', dates: [ {date: new Date('2020-03-01'), value: 42.0}, {date: new Date('2020-04-01'), value: 46.1}, {date: new Date('2020-05-01'), value: 21.3}, {date: new Date('2020-06-01'), value: 4.3}, {date: new Date('2020-07-01'), value: 10.4}, ], primary: true, lineStyles: {'stroke': 'green'}, areaStyles: {'fill': 'none'}, showDatapoints: true }, { name: 'series 3', dates: [ {date: new Date('2019-11-01'), value: 60.1}, {date: new Date('2019-12-01'), value: 59.3}, {date: new Date('2020-01-01'), value: 23.3}, {date: new Date('2020-02-01'), value: 78.4}, {date: new Date('2020-03-01'), value: 45.0}, ], primary: false, lineStyles: {'stroke': 'blue'}, areaStyles: {'fill': 'none'}, showDatapoints: true } ];   The X-axis is computed to fit the red and green series as they are primary series  It is also possible to change globally how the component renders these areas and curves by binding the curveType input property. By default, it is set to &quot;curveMonotoneX&quot;, but any of the methods described on this page can be selected.  ","version":"Next","tagName":"h3"},{"title":"Events​","type":1,"pageTitle":"Timeline Module","url":"/dokku/docs/libraries/analytics/timeline#events","content":" In addition to timeseries, this component can display events, of type TimelineEvent:  &lt;sq-timeline [data]=&quot;timeseries&quot; [events]=&quot;events&quot;&gt;&lt;/sq-timeline&gt;   With:  this.events = [ {id: '1', date: new Date('2019-12-25'), display: 'Christmas!'}, {id: '2', date: new Date('2020-03-24'), display: 'Big meeting'}, {id: '3', date: new Date(), display: 'Now!'}, ]     Like for the timeseries, it is possible to customize the size and style of each event with the following optional properties:  size (default: 6): Height of the marker in pixelssizeOpened (default: 12): Height of the marker in pixels when the event is selected (with a click)styles: Custom style object for this element, passed to the SVG element via ngStyle.  this.events = [ {id: '1', date: new Date('2019-12-25'), display: 'Christmas!', size: 10}, {id: '2', date: new Date('2020-03-24'), display: 'Big meeting', sizeOpened: 20}, {id: '3', date: new Date(), display: 'Now!', styles: {fill: 'red', stroke: 'orange'}}, ]     By default, when an event is selected, a tooltip is displayed, showing the event's date and display property. It is possible to pass a custom template to the component to display the event in a completely custom way:  {% raw %}&lt;sq-timeline [data]=&quot;timeseries&quot; [events]=&quot;events&quot;&gt; &lt;ng-template #tooltipTpl let-event&gt; &lt;div class=&quot;custom-display&quot;&gt; &lt;span&gt;{{ event.display }}&lt;/span&gt; &lt;span style=&quot;color: red;&quot;&gt;{{ event.date | sqDate }}&lt;/span&gt; &lt;/div&gt; &lt;/ng-template&gt; &lt;/sq-timeline&gt;{% endraw %}     When there are too many events in the same timeframe, the events are grouped together under one marker. When the user zooms in or zooms out, the events are grouped/ungrouped appropriately. The tooltip diplays the list of events under one marker. Note that the size and style of the marker is the one of the first marker (chronologically).    Note that the X-axis is not resized in function of events (only the primary time series). A different implementation would be possible, to account for both the series and events.  ","version":"Next","tagName":"h3"},{"title":"Interactions​","type":1,"pageTitle":"Timeline Module","url":"/dokku/docs/libraries/analytics/timeline#interactions","content":" The component allows different types of interactions:  Zooming: Performed via the mouse wheel. Zooming is effective only along the X-axis. When zooming is finished, an event is triggered, so that the parent component can respond (for example by refreshing the data). &lt;sq-timeline [data]=&quot;timeseries&quot; (rangeChange)=&quot;refreshData($event)&quot;&gt;&lt;/sq-timeline&gt; The $event in question contains the new minimum and maximum dates of the X-axis in an array ([Date, Date]). Zooming is enabled by default but can be turned off by binding [zoomable]=&quot;false&quot; to the component. It is possible (and recommended) to limit the possible zoom extent by binding the minZoomDays and minZoomDays properties. By default, these are set respectively to 1 (meaning we can zoom in to no less than 1 day) and 36500 (meaning we can zoom out to no more than 100 years). Finally, it is also possible to provide fixed dates for the X-axis (rather than auto-fitting to the data), by binding the minDate and maxDate properties. If zooming is enabled, these will just be the initial scale. Selection: Performed by clicking and dragging the mouse over the chart. This allows to select a range of dates, which triggers an event so that the parent component can respond (for example by launching a new search). &lt;sq-timeline [data]=&quot;timeseries&quot; (selectionChange)=&quot;onSelectionChange($event)&quot;&gt;&lt;/sq-timeline&gt; The $event in question contains the new minimum and maximum dates of the selection in an array ([Date, Date]). Note that the selection is removed when clicking outside of the selected area. Tooltip: As we have seen above, a tooltip is displayed when clicking on an event. Additionally, when the user is simply moving the mouse over the chart, a vertical line is displayed with the corresponding date. This behavior can be turned off by binding [showTooltip]=&quot;false&quot; to the component.  ","version":"Next","tagName":"h3"},{"title":"Sizing​","type":1,"pageTitle":"Timeline Module","url":"/dokku/docs/libraries/analytics/timeline#sizing","content":" You can bind the width and height properties of the component (as numbers), although the component automatically fits the width of its parent container (thanks to the viewBox attribute). Therefore, modifying the width or height primarily affects the aspect ratio.  Additionally you can bind the margin property to adjust the space around the timeline. The default is: {top: 15, bottom: 30, left: 40, right: 15} (more space to the left and bottom due to the axes).  ","version":"Next","tagName":"h3"},{"title":"Facet Timeline Component​","type":1,"pageTitle":"Timeline Module","url":"/dokku/docs/libraries/analytics/timeline#facet-timeline-component","content":" The sq-timeline component does a lot of work to render the timelines, events and manage the user interactions, but it does not know anything about the Sinequa services and data structures.  The sq-facet-timeline component is in charge of &quot;feeding&quot; the timeline with actual data for the timeseries and events, potentially coming from different sources  ","version":"Next","tagName":"h2"},{"title":"Time series​","type":1,"pageTitle":"Timeline Module","url":"/dokku/docs/libraries/analytics/timeline#time-series-1","content":" sq-facet-timeline requires at least the following inputs:  results: Generally binded to SearchService.results, which ensures that ngOnChanges() is called every time new results come in. This ensures data is refreshed at the same time as the results.timeseries: An array of configuration (one for each series). Different types of configuration are accepted: Raw data: It is possible to pass directly a TimelineSeries object (as seen above), which must then computed by another source/service.A &quot;simple&quot; aggregation: In this case, the configuration (of type TimelineAggregation) specifies the name of an aggregation to be plotted (of course this aggregation should be over a sourcedatetime column). Note that you can specify an aggregation that may or may not be included in the standard search (See the Include in standard search option of the aggregation in the administration).A &quot;combined&quot; aggregation: In this case, the configuration consists of multiple TimelineAggregation objects. Each of them corresponds to a different &quot;scale&quot; of the same value. It is required to provide the list of scales corresponding to each aggregation. The component will respond to changes of scale (when the user zooms in or out) by querying the most appropriate aggregation. Combined aggregations are the only scalable way of displaying temporal information when the amount of data is enormous, without loosing any accuracy or performance.  Sample aggregation configured in the admin. Note: 1) modified is a datetime column 2) The aggregation is not included in standard search 3) We do not truncate the data 4) The data will sorted by date 5) The resolution is a week  By default, a simple TimelineAggregation is configured, to display the Timeline aggregation configured in the default Query web service.  Therefore, the following displays the default aggregation:  &lt;sq-facet-timeline [results]=&quot;results&quot;&gt;&lt;/sq-facet-timeline&gt;   A more complex configuration could be:  &lt;sq-facet-timeline [results]=&quot;results&quot; [timeseries]=&quot;[rawTimeseries, combinedAggregation, otherAggregation]&quot;&gt; &lt;/sq-facet-timeline&gt;   With:  // TimelineSeries this.rawTimeseries = { name: 'series 1', dates: [ {date: new Date('2020-01-01'), value: 42.3}, {date: new Date('2020-02-01'), value: 58.4}, {date: new Date('2020-03-01'), value: 21.0}, {date: new Date('2020-04-01'), value: 3.1}, {date: new Date('2020-05-01'), value: 34.3}, ], primary: true, showDatapoints: true } // TimelineCombinedAggregation const aggregations = [ {name:'timeline', aggregation:'TimelineYears', primary:true, showDatapoints: true}, {name:'timeline', aggregation:'TimelineMonths', primary:true, showDatapoints: true}, {name:'timeline', aggregation:'TimelineWeeks', primary:true, showDatapoints: true}, {name:'timeline', aggregation:'TimelineDays', primary:true, showDatapoints: true} ] this.combinedAggregation = { aggregations: aggregations, default: aggregations[0], maxNMonths: [-1, 5*12, 1*12, 2] // Infinite, 5 years, 1 year, 2 months } // TimelineAggregation this.otherAggregation = { name: 'dates', aggregation: 'Date', primary: false, lineStyles: {stroke: 'lightGreen'}, areaStyles: {fill: 'lightGreen'}, showDatapoints: true }   The above illustrates the three types of timeseries configuration that can be passed to sq-facet-timeline  We have already seen the structure and options of TimelineSeries.  TimelineAggregation requires the following parameters:  aggregation: The name of the aggregation configured in the Query web service.primary: Whether this is a primary series or not.  Additionally, the following parameters from TimelineSeries are optional and work in the same way (see above): name, areaStyles, lineStyles and showDatapoints.  TimelineCombinedAggregations requires the following parameters:  aggregations: An array of TimelineAggregation. These aggregations configured on the server should typically be computed on the same sourcedatetime column but with different masks. The masks allow to modulate the resolution of the aggregation. Using a fine-grained mask (YYYY-MM-DD) potentially returns a lot of data unless we query the aggregation with a selection (&quot;date between X and Y&quot;), which is exactly what our component is doing to always offer optimum accuracy and performance.maxNMonths: An array of number, each corresponding to the maximum number of months for a given aggregation (the array must be the same size as aggregations). These are the &quot;breakpoints&quot; at which the component will switch to an aggregation better suited to the current scale of the timeline. For example, if the X axis is 13.4 months long, the component will choose the aggregation with the minimum maxNMonths such that maxNMonths &gt; 13.4. If the array is [-1, 48, 12, 2], then 48 is selected (-1 is infinity).default: The TimelineAggregation to initialize the view (it should typically be a coarse-grained aggregation, returning few values even for a large scale).  Note that the styling parameters and the primary input are still there but can be passed via each of the TimelineAggregation.  ","version":"Next","tagName":"h3"},{"title":"Events​","type":1,"pageTitle":"Timeline Module","url":"/dokku/docs/libraries/analytics/timeline#events-1","content":" sq-facet-timeline can also display events coming from different data sources:  Raw data: It is possible to pass an array of raw TimelineEvent objects, which must then be computed by another source/service.The list of records in the current results: If a record has a &quot;modified&quot; date (or other sourecedatetime), it can be plotted on the timeline as an event. This allows the user to quickly visualize how the top, most relevant data is distributed in time, and filter this data accordingly. Furthermore, the component listens for selection changes from the SelectionService and can modify the event styling for selected records (which makes it easy for a user to see where a selected record is placed on the timeline).An aggregation of events: If a column of the index stores &quot;events&quot;, they can be aggregated by the engine and displayed on the timeline. An &quot;event&quot; in that sense is a normalized field that contains a date and name/id. For example (2020-02-14)#(VALENTINES DAY), which is the format of extraction of cooccurrences (but any format can be used). Note that Sinequa ES includes a very capable Text-Mining Agent that can extract date entities from text in a wide array of formats and languages. Event names can easily be extracted via a simple dictionary-based entity. It is then easy to configure a cooccurrence extraction for dates and event names.  Sample configuration of a cooccurrence entity  By default, the list of records is configured to be displayed by their modified dates. Therefore, the following displays the list of records:  &lt;sq-facet-timeline [results]=&quot;results&quot;&gt;&lt;/sq-facet-timeline&gt;   A more complex configuration could be:  &lt;sq-facet-timeline [results]=&quot;results&quot; [events]=&quot;[rawEvents, records, eventAggregation]&quot;&gt; &lt;/sq-facet-timeline&gt;   With:  // TimelineEvent[] this.rawEvents = [ {id: '1', date: new Date('2019-12-25'), display: 'Christmas!'}, {id: '2', date: new Date('2020-03-24'), display: 'Big meeting'}, {id: '3', date: new Date(), display: 'Now!'}, ]; // TimelineRecords this.records = { field: 'sourcedatetime3', display: (r: Record) =&gt; `${r['shortTitle']} by ${r['authors']}`, styles: (r: Record, selected: boolean) =&gt; { return {fill: selected? 'red' : 'green'}; } }; // TimelineEventAggregation this.eventAggregation = { aggregation: 'Events', getDate: (item: AggregationItem) =&gt; new Date(item.value.toString().split(')#(')[0].replace('(','')), getDisplay: (item: AggregationItem) =&gt; item.value.toString().split(&quot;)#(&quot;)[1].replace(')','')};   We have already seen the structure and parameters of the raw TimelineEvent.  The TimelineRecords requires the field parameter, which specifies which column to use to place the record on the timeline. The display parameter is optional (by default, record.title is displayed). The styles parameter is also optional, and it allows to generate the TimelineEvent's styles property. Similarly, an optional size parameter allows to customize the size. Note that styles and size can each be a static value (size: 10) or a dynamic value, computed individually for each record (size: (record, selected) =&gt; selected? 10 : 5).  The TimelineEventAggregation requires the name of the aggregation configured on the server (aggregation), as well as two methods, getDate and getDisplay, which respectively extract a Date and display (string) from each AggregationItem object. In the example above, the events from this aggregation are supposed to be formatted as (2020-02-14)#(VALENTINES DAY) (hence the use of .split() and .replace()). Additionally, the size and styles parameters are also optionally available and work in the same way as above, with the difference that for the dynamic values the input argument is an AggregationItem instead of a Record.  ","version":"Next","tagName":"h3"},{"title":"Legend​","type":1,"pageTitle":"Timeline Module","url":"/dokku/docs/libraries/analytics/timeline#legend","content":" The sq-facet-timeline component can display a legend sub-component. The legend's content, position and styles can be customized with the following parameters:  showLegend (default: false): Whether or not to display the legendlegendOrientation (default: 'row'): Whether to display the legend in a row or a columnlegendYOffset (default: 3): An offset to position the legend markers vertically relative to the textlegendStyles: A list of styles applied to the legend container (can be useful to position the legend in the right position, add a border, background, etc.)legendEvents: By default the legend automatically displays the timeseries but no the timeline events. To display the events, add a list of &quot;event types&quot; (incl. name and styling).  &lt;sq-facet-timeline [results]=&quot;results&quot; [showLegend]=&quot;true&quot; [legendEvents]=&quot;[{name: 'Events', styles: {fill: 'green'}}]&quot; [legendYOffset]=&quot;3&quot; [legendOrientation]=&quot;'column'&quot; [legendStyles]=&quot;{position: 'absolute', 'top.px': 30, 'right.px': 20, 'padding-left.px':8, border: '1px solid lightgrey'}&quot; &gt;&lt;/sq-facet-timeline&gt;     Note that the legend is available as a standalone component (sq-timeline-legend):  &lt;sq-timeline-legend [data]=&quot;timeseries&quot; [events]=&quot;eventTypes&quot; [legendStyles]=&quot;{'justify-content': 'center'}&quot;&gt; &lt;/sq-timeline-legend&gt;     ","version":"Next","tagName":"h3"},{"title":"Other parameters and events​","type":1,"pageTitle":"Timeline Module","url":"/dokku/docs/libraries/analytics/timeline#other-parameters-and-events","content":" We have seen the two most important inputs of sq-facet-timeline: timeseries and events. Other parameters are available. In fact, the following parameters (described before) are &quot;forwarded&quot; to the sq-timeline (using the same default values):  minDate and maxDate allow to &quot;hard-code&quot; the X-axis extent (prior to any zooming).minAggregationDate and maxAggregationDate allow to filter out dates from aggregations that fall outside of a time period.zoomable, minZoomDays and maxZoomDays allow to specify the zoom behavior.width, height and margin allow to size the chart (which resizes itself to fill the width of the container).curveType allows to select the type of curve approximation from the D3 library.showTooltip allows to turn on or off the tooltip when hovering the mouse of the chart.  Note that sq-facet-timeline listens to the events triggered by sq-timeline:  When the user zooms in and out, a rangeChange event is triggered. The facet captures this event and updates the data of any TimelineCombinedAggregation in function of the new scale. When the user selects a range of dates by clicking and dragging the mouse over the chart, a selectionChange event is triggered. The facet captures this event and filters the search accordingly, using the SearchService. The filter is applied to the metadata plotted by each TimelineAggregation. For example, if we plot 2 time series corresponding to 2 aggregations computed on the modified and sourcedatetime3, the filter will be modified BETWEEN x AND Y OR sourcedatetime3 BETWEEN x AND y. When the user clicks on a event, the tooltip showing the event's display parameter actually displays a clickable link. When the link is clicked, the component forwards the event to the parent by emitting a eventClicked event (passing the clicked event as a parameter). The tooltip is automatically closed after the click. The parent can exploit this event is different ways: &lt;sq-facet-timeline [results]=&quot;results&quot; [events]=&quot;timelineEvents&quot; (eventClicked)=&quot;timelineEventClicked($event)&quot;&gt;&lt;/sq-facet-timeline&gt; And: timelineEventClicked(event: TimelineEvent) { // If the event is a record, we &quot;open&quot; it (eg. in the preview) if(event['record']){ this.openedDoc = event['record']; } // If the event is an aggregation item, we filter the search with this item else { const item = event['item'] as AggregationItem; const aggregation = event['aggregation'] as Aggregation; this.facetService.addFilterSearch('Timeline', aggregation, item); } }   ","version":"Next","tagName":"h3"},{"title":"Facet integration​","type":1,"pageTitle":"Timeline Module","url":"/dokku/docs/libraries/analytics/timeline#facet-integration","content":" Finally, sq-facet-timeline is a facet component, and can therefore easily be embedded within a sq-facet-card:  &lt;sq-facet-card [icon]=&quot;'fas fa-chart-line'&quot; [title]=&quot;'Awesome Timeline'&quot;&gt; &lt;sq-facet-timeline #facet [results]=&quot;results&quot; [timeseries]=&quot;timeseries&quot;&gt;&lt;/sq-facet-timeline&gt; &lt;/sq-facet-card&gt;     The component provides a &quot;clear filters&quot; action displayed in the facet frame. It is possible to add custom actions, by binding them to the [actions] input of sq-facet-card.  ","version":"Next","tagName":"h3"},{"title":"Customization​","type":1,"pageTitle":"Timeline Module","url":"/dokku/docs/libraries/analytics/timeline#customization","content":" The two components documented above provide a great level of flexiblity, but there is a infinite number of ways one could customize this timeline. Rather than adding many inputs and a lot of complexity to the components' source code, they are designed to be simple and modular enough to be customized by overriding or modifying their code.  ","version":"Next","tagName":"h2"},{"title":"Styling​","type":1,"pageTitle":"Timeline Module","url":"/dokku/docs/libraries/analytics/timeline#styling","content":" The timeline is pure HTML (actually SVG), so it is possible to change a lot of things by simply adding rules in your global stylesheet.  sq-timeline { .axis { line { stroke: #323232; } text { fill: #545454; } } }   ","version":"Next","tagName":"h3"},{"title":"Templating​","type":1,"pageTitle":"Timeline Module","url":"/dokku/docs/libraries/analytics/timeline#templating","content":" Modifying the Angular HTML templates allows you to easily add dynamic elements to the SVG. For example a legend could easily be added in the following way:  {% raw %}&lt;g *ngFor=&quot;let series of data; let i=index&quot; class=&quot;series&quot; [attr.transform]=&quot;'translate('+(margin.left+i*50)+','+ (height-20) +')'&quot;&gt; &lt;line class=&quot;line&quot; x1=&quot;0&quot; x2=&quot;15&quot; y1=&quot;0&quot; y2=&quot;0&quot; [ngStyle]=&quot;series.lineStyles&quot;&gt;&lt;/line&gt; &lt;text x=&quot;20&quot; y=&quot;5&quot;&gt;{{ series.name }}&lt;/text&gt; &lt;/g&gt;{% endraw %}   Note that you don't have to copy the entire component code to do this. Just use TypeScript's extends clause, with something like:  import {BsTimelineComponent} from '@sinequa/analytics/timeline'; @Component({ selector: 'my-timeline', templateUrl: './my-timeline.html' styleUrls: ['./my-timeline.scss'] // Or just link the original stylesheet }) export class MyTimeline extends BsTimelineComponent {}   ","version":"Next","tagName":"h3"},{"title":"Controller​","type":1,"pageTitle":"Timeline Module","url":"/dokku/docs/libraries/analytics/timeline#controller","content":" If you need to modify the controller, you can also use the extends clause and only modify the methods that need to be modified. This approach means you must be comfortable with the way the component works internally.  For example, if you want to modify the axes properties, you could simply override the drawXAxis() or drawYAxis() methods:  @Component({ selector: 'my-timeline', templateUrl: 'my-timeline.html' styleUrls: ['my-timeline.scss'] // Or just link the original stylesheet }) export class MyTimeline extends BsTimelineComponent { drawXAxis() { const xAxis = d3.axisBottom(this.xt).ticks(5); // Only 5 ticks this.xAxis$.call(xAxis); this.xAxis$.selectAll(&quot;.domain&quot;).remove(); // Remove the axis line } drawYAxis() { const yAxis = d3.axisLeft&lt;number&gt;(this.y) .ticks(5) // Only 5 ticks .tickFormat(d3.format(&quot;.2s&quot;)); this.yAxis$.call(yAxis); this.yAxis$.selectAll(&quot;.domain&quot;).remove(); // Remove the axis line } }  ","version":"Next","tagName":"h3"},{"title":"Collapse Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/components/collapse","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Collapse Module","url":"/dokku/docs/libraries/components/collapse#features","content":" This module provides components to add collapsible panels to your components as well as collapse/expand buttons to trigger this effect.  One of the usages of this module is the collapse/expand functionality of the facets (with collapsible = true).  Collapse functionality in facet  ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Collapse Module","url":"/dokku/docs/libraries/components/collapse#import","content":" Add CollapseModule to your Angular imports in app.module.ts:  import { CollapseModule } from &quot;@sinequa/components/collapse&quot;; /*....*/ @NgModule({ imports: [ /*....*/ CollapseModule, /*....*/ ], /*....*/ })   This module is internationalized: If not already the case, you need to import its messages for the language(s) of your application. For example, in your app's src/locales/en.ts:  ... import {enCollapse} from &quot;@sinequa/components/collapse&quot;; const messages = Utils.merge({}, ..., enCollapse, appMessages);   ","version":"Next","tagName":"h2"},{"title":"API usage​","type":1,"pageTitle":"Collapse Module","url":"/dokku/docs/libraries/components/collapse#api-usage","content":" The sq-collapse component can be used in Angular templates to create collapsible panels.  Wrap the collapsible content into &lt;sq-collapse&gt; and &lt;ng-template&gt; elements (meaning the content will be instantiated only once displayed).  Example 1: A collapsible list of element in the HTML template    The sq-collapse component only expects a boolean property collapsed, which instructs it whether to show the collapsible content or not.  You can manage the variable/property that is used as input of this property as you like. You can change it using an HTML button like in the above example or with any other HTML components.  @sinequa/components/collapse also includes a syntactic sugar component - sq-collapse-button - to help you quickly create input components to toggle the collapsed property. By default, these components display a chevron icon (as in the image above), but the icon and text can be customized via the icon, text, collapsedTitle and expandedTitle inputs respectively.  Example 2: Usage of the sq-collapse-button   ","version":"Next","tagName":"h2"},{"title":"Comments Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/components/comments","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Comments Module","url":"/dokku/docs/libraries/components/comments#features","content":" This module provides a component to display a thread of comments attached to a document.    Users can post comments, replies and like other comments. The author of a comment (or an admin) has the possibility to edit and delete this comment. The component supports Markdown syntax, enabling users to format their posts without the need for a complex Wysiwyg editor.  ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Comments Module","url":"/dokku/docs/libraries/components/comments#import","content":" ⚠️ This component requires a web service deployed on the Sinequa server, that is NOT part of the Sinequa product. The web service is provided a plugin (See below). It is also required to create a custom index to store the comments, and to manage the lifecycle of this index.  Add CommentsModule to your Angular imports in app.module.ts:  import { CommentsModule } from &quot;@sinequa/components/comments&quot;; /*....*/ @NgModule({ imports: [ /*....*/ CommentsModule, /*....*/ ], /*....*/ })   This module is internationalized: If not already the case, you need to import its messages for the language(s) of your application. For example, in your app's src/locales/en.ts:  ... import {enComments} from &quot;@sinequa/components/comments&quot;; const messages = Utils.merge({}, ..., enComments, appMessages);   This component has one important dependency: the Marked library needed to render the markdown-formatted comments as HTML.  ","version":"Next","tagName":"h2"},{"title":"Comments component​","type":1,"pageTitle":"Comments Module","url":"/dokku/docs/libraries/components/comments#comments-component","content":" The sq-comments component displays a list of comments and replies attached to a specific document. This component can be displayed anywere as long as a document id is provided.  The component requires one mandatory input: docid (string), the id of the document to which the thread of comments is attached.  &lt;sq-comments [docid]=&quot;record.id&quot;&gt;&lt;/sq-comment&gt;   The component uses a service (CommentsWebService) to retrieve the list of Comment objects from the server (as well as all the other actions: create, edit, delete and like comments).  ","version":"Next","tagName":"h2"},{"title":"Server-side configuration​","type":1,"pageTitle":"Comments Module","url":"/dokku/docs/libraries/components/comments#server-side-configuration","content":" Comments are not yet part of the Sinequa product, so a plugin needs to be deployed on the Sinequa server for the component to work properly.  The code of the plugin is provided here. The file can be simply copied in a plugin under the data/configuration/plugins directory on the Sinequa server.  Additionally, a custom index must be created to store the comments. The schema of this index is provided here. The XML can be copied in the data/configuration/indexes. ","version":"Next","tagName":"h2"},{"title":"Filters Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/components/filters","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Filters Module","url":"/dokku/docs/libraries/components/filters#features","content":" This module provides 3 components to visualize the filters of a Query object.  A query can contain a &quot;tree&quot; of filters defining the boolean conditions for filtering the search results. These filters might look like:  Source: &quot;Documentation&quot;And either: Format: &quot;pdf&quot;Format: &quot;html&quot;  These filters would be added to a query object with the addFilter method:  query.addFilter({ operator: &quot;and&quot;, filters: [ {field: &quot;Source&quot;, value: &quot;Documentation&quot;}, { operator: &quot;or&quot;, filters: [ {field: &quot;Format&quot;, value: &quot;pdf&quot;}, {field: &quot;Format&quot;, value: &quot;html&quot;}, ] } ] });   See more details about the supported filters in the documentation of the Query objects.  The filters would then be represented by the following tree (in the sq-filters-editor component):    ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Filters Module","url":"/dokku/docs/libraries/components/filters#import","content":" import { FiltersModule } from '@sinequa/components/filters'; @NgModule({ imports: [ ... FiltersModule, ], })   This module is internationalized: If not already the case, you need to import its messages for the language(s) of your application. For example, in your app's src/locales/en.ts:  ... import {enFilters} from &quot;@sinequa/components/filters&quot;; const messages = Utils.merge({}, ..., enFilters, appMessages);   ","version":"Next","tagName":"h2"},{"title":"API usage​","type":1,"pageTitle":"Filters Module","url":"/dokku/docs/libraries/components/filters#api-usage","content":" ","version":"Next","tagName":"h2"},{"title":"Filters component​","type":1,"pageTitle":"Filters Module","url":"/dokku/docs/libraries/components/filters#filters-component","content":" The sq-filters component displays the filters of a query in an inline view:    ","version":"Next","tagName":"h3"},{"title":"Filters editor component​","type":1,"pageTitle":"Filters Module","url":"/dokku/docs/libraries/components/filters#filters-editor-component","content":" The sq-filters-editor component displays the filters of a query in an editable tree view:    ","version":"Next","tagName":"h3"},{"title":"Filters view component​","type":1,"pageTitle":"Filters Module","url":"/dokku/docs/libraries/components/filters#filters-view-component","content":" The sq-filters-view component integrates both the sq-filters and sq-filters-editor components. By default it displays the sq-filters component, and when clicking on the &quot;Edit&quot; button, it displays the sq-filters-editor component.   ","version":"Next","tagName":"h3"},{"title":"Feedback Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/components/feedback","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Feedback Module","url":"/dokku/docs/libraries/components/feedback#features","content":" This module includes a single sample component which displays a menu letting a user send feedback to the administrator of the Sinequa server. This feedback is collected via the audit index and needs to be displayed in an audit report. ⚠️ No email is sent to anyone automatically.    ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Feedback Module","url":"/dokku/docs/libraries/components/feedback#import","content":" Import this module in your app.module.ts:  import { BsFeedbackModule } from '@sinequa/components/feedback'; @NgModule({ imports: [ ... BsFeedbackModule   This module is internationalized: If not already the case, you need to import its messages for the language(s) of your application. For example, in your app's src/locales/en.ts:  ... import {enFeedback} from &quot;@sinequa/components/feedback&quot;; const messages = Utils.merge({}, ..., enFeedback, appMessages);   ","version":"Next","tagName":"h2"},{"title":"Feedback​","type":1,"pageTitle":"Feedback Module","url":"/dokku/docs/libraries/components/feedback#feedback","content":" The sq-feedback-menu component can be displayed in an application with:    It is possible to pass optional inputs to the component:  size ('sm', 'lg' or leave undefined): controls the size of the action's button (will translate into the Bootstrap classes btn-sm or btm-lg).style ('light', 'dark', 'primary', etc.): controls the style of the action's button (will translate into the Bootstrap classes btn-light, btn-primary, etc.).rightAligned (default: false): controls the submenu alignment to the right or the left.  ","version":"Next","tagName":"h2"},{"title":"Audit configuration​","type":1,"pageTitle":"Feedback Module","url":"/dokku/docs/libraries/components/feedback#audit-configuration","content":" The component uses the Audit web service to record the user feedback. The audit record will contain the following information:  Type of feedback: The default categories are lang, content, ui and other. The type is stored in the message column of the index.Comment from the user (stored in the column detail).Time of the comment (stored in the column timestamp).User id (stored in the column timestamp).  The comments can be displayed in an audit report, in various steps:  Define a query to fetch the user comments: Define a new section in the &quot;Parameters&quot;: The audit events are now visible in the audit report: ","version":"Next","tagName":"h2"},{"title":"Facet Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/components/facet","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Facet Module","url":"/dokku/docs/libraries/components/facet#features","content":" This modules provides:  FacetService: A service to manage data for the facet components and modify the search criteria (via the SearchService).sq-facet-card and AbstractFacet: A flexible API for creating custom facets.A list of diverse facet components using the above facet API. These components are generally styled with the Bootstrap library, and their class names start with Bs.  ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Facet Module","url":"/dokku/docs/libraries/components/facet#import","content":" Import this module in your app.module.ts. Optionally include lists of of dynamic facet configuration via the forRoot() method.  import { BsFacetModule } from '@sinequa/components/facet'; @NgModule({ imports: [ ... BsFacetModule   This module is internationalized: If not already the case, you need to import its messages for the language(s) of your application. For example, in your app's src/locales/en.ts:  ... import {enFacet} from &quot;@sinequa/components/facet&quot;; const messages = Utils.merge({}, ..., enFacet, appMessages);   ","version":"Next","tagName":"h2"},{"title":"Facet Card API​","type":1,"pageTitle":"Facet Module","url":"/dokku/docs/libraries/components/facet#facet-card-api","content":" ","version":"Next","tagName":"h2"},{"title":"Standard usage​","type":1,"pageTitle":"Facet Module","url":"/dokku/docs/libraries/components/facet#standard-usage","content":" The facet card API is based on a generic container component, sq-facet-card, and an abstract facet component for the content of the facets (AbstractFacet):  The container displays the frame, icon, title, action buttons around the facet.The content can be any Angular template displayed within the facet. If the content extends AbstractFacet, the container will automatically detect its dynamic list of actions (and other features) and display them.  For example:    Notice the list of actions returned by override get actions() in HelloWorldComponent (a method of AbstractFacet):  The API is very flexible and allows for very different types of facets:    ","version":"Next","tagName":"h3"},{"title":"Multiple views​","type":1,"pageTitle":"Facet Module","url":"/dokku/docs/libraries/components/facet#multiple-views","content":" It is possible to inject multiple views inside the same facet card. Views need to be wrapped inside an ng-template augmented with the sqFacetView directive.  For example, one might want to display an aggregation viewed as a facet list OR as a chart.    Adding/removing views is as easy as modifying the list of ng-templates injected into the facet card. The [sqFacetView] input is an Action object that is used to display the buttons to toggle between views.  ","version":"Next","tagName":"h3"},{"title":"Template customization​","type":1,"pageTitle":"Facet Module","url":"/dokku/docs/libraries/components/facet#template-customization","content":" It is possible to inject ng-templates to customize specific parts of the facet card:  The header template (#headerTpl)The &quot;sub-header&quot; template (#subHeaderTpl)The footer template (#footerTpl)The settings template (#settingsTpl)  Here is an example (notice the settings button in the top right, which displays the settings template):    Note that these templates can be injected in 2 different ways:  Either injected by the parent, as in the example aboveOr defined in the child component's template (in the example above, it would be the sq-facet-list component). The child component (which extends AbstractFacet) can thus customize its display, when embedded in a facet card, without requiring the parent to do anything.  ","version":"Next","tagName":"h3"},{"title":"Custom actions display​","type":1,"pageTitle":"Facet Module","url":"/dokku/docs/libraries/components/facet#custom-actions-display","content":" By default all actions are displayed in the facet card's top-right corner. These actions may come from different places:  the [actions] input of the facet cardthe get actions() method of the child component (AbstractFacet)the different views injected in the facetspecific options of the facet card, like [collapsible]=&quot;true&quot;  For complex components, the number of buttons can grow quickly and become overwhelming or confusing. For this reason it is possible to split these actions into 3 separate groups, each with their own set of options:  Primary actions (displayed in the top-right corner)Secondary actions (displayed under the primary actions)View actions to toggle between views (displayed in the bottom-left corner)  Secondary actions can be defined in two ways:  The [secondaryActions] input of the facet card.Taken from the child component (AbstractFacet), via the [facetActionsAreSecondary]=&quot;true&quot; option of the facet card.  View actions are displayed separately with the [viewActionsAreSecondary]=&quot;true&quot; option of the facet card.  A complete example is the display of the preview:  &lt;!-- With selected document --&gt; &lt;sq-facet-card class=&quot;mb-3 facet-preview&quot; [actions]=&quot;previewCustomActions&quot; actionsSize=&quot;&quot; [facetActionsAreSecondary]=&quot;true&quot; secondaryActionsClass=&quot;position-absolute end-0 btn-group-vertical mt-4 me-3 bg-light rounded shadow on-hover&quot; [viewActionsAreSecondary]=&quot;true&quot; viewActionsClass=&quot;d-block btn-group mt-2&quot; viewButtonsStyle=&quot;outline-primary&quot;&gt; &lt;ng-template #headerTpl&gt; &lt;sq-result-title class=&quot;flex-grow-1&quot; [record]=&quot;openedDoc&quot; field=&quot;title&quot; titleLinkBehavior=&quot;open-if-url&quot;&gt; &lt;/sq-result-title&gt; &lt;/ng-template&gt; &lt;ng-template #subHeaderTpl&gt; &lt;sq-metadata [record]=&quot;openedDoc&quot; [config]=&quot;metadata&quot; class=&quot;small&quot;&gt;&lt;/sq-metadata&gt; &lt;/ng-template&gt; &lt;ng-template [sqFacetView]=&quot;{text: 'msg#facet.preview.viewPreview'}&quot;&gt; &lt;sq-facet-preview-2 #facet [record]=&quot;openedDoc&quot; [query]=&quot;searchService.query&quot; [height]=&quot;750&quot; (previewLoaded)=&quot;previewReady($event)&quot;&gt; &lt;/sq-facet-preview-2&gt; &lt;/ng-template&gt; &lt;ng-template [sqFacetView]=&quot;{text: 'msg#facet.preview.viewPassages'}&quot; [default]=&quot;!!passageId&quot; *ngIf=&quot;openedDoc.$hasPassages&quot; #passagesList&gt; &lt;sq-passage-list [record]=&quot;openedDoc&quot; [passageId]=&quot;passageId&quot;&gt;&lt;/sq-passage-list&gt; &lt;/ng-template&gt; &lt;/sq-facet-card&gt;   This results in the following view (notice the custom positioning of the secondary actions made possible by the [secondaryActionsClass] input):    ","version":"Next","tagName":"h3"},{"title":"Facet containers​","type":1,"pageTitle":"Facet Module","url":"/dokku/docs/libraries/components/facet#facet-containers","content":" It is possible to display facets in other types of containers besides the simple facet card:  The facet bar component displays a list of facets in a column.The &quot;multi-facet&quot; component displays one facet at a time, and menu to switch between them.The &quot;facet filters&quot; component displays facets as a horizontal bar with dropdown menus.  These containers share a similar API. In particular, they require:  A list of facet configuration objects (FacetConfig&lt;T&gt;).The Angular components instantiated within these containers, for each facet type.  Each facet requires a set of inputs. These inputs are included within the FacetConfig interface. For example, for a list facet the facet configuration looks like this:  const config: FacetConfig&lt;FacetListParams&gt; = { name: &quot;myfacet&quot;, title: &quot;My facet&quot;, type: &quot;list&quot;, parameters: { aggregation: &quot;MyAggregation&quot;, showCount: true, searchable: true } }   The FacetConfig interface has a part that is common to all facets:  type defines the type of component to be displayedtitle and icon define what is displayed in the facet headerincludedTabs and excludedTabs allow to list the tabs (from the results object) in which this facet should be displayed.  The parameters property is specific to the component type. In the example above, its type is FacetListParams, which corresponds to the configuration of a &quot;list&quot; facet component.  The Angular components displayed by the containers is provided as a MapOf&lt;Type&lt;any&gt;&gt;. By default, the containers support the standard components from the @sinequa/components/facet module:  export const DEFAULT_FACET_COMPONENTS: MapOf&lt;Type&lt;any&gt;&gt; = { &quot;list&quot;: BsFacetList, &quot;range&quot;: BsFacetRange, &quot;refine&quot;: BsRefine, &quot;tag-cloud&quot;: BsFacetTagCloud }   But this list can be extended, to include components from other modules:  import { BsFacetDate } from '@sinequa/analytics/timeline'; public facetComponents = { ...DEFAULT_FACET_COMPONENTS, &quot;date&quot;: BsFacetDate };   And in the template:  &lt;sq-facet-bar [results]=&quot;results&quot; [facetComponents]=&quot;facetComponents&quot;&gt; &lt;/sq-facet-bar&gt;   ","version":"Next","tagName":"h2"},{"title":"Facet Bar​","type":1,"pageTitle":"Facet Module","url":"/dokku/docs/libraries/components/facet#facet-bar","content":" The sq-facet-bar component is a container which can display a dynamic list of facets.  The Facet Service manages the list of facets displayed in the facet bar. The service allows adding, moving and removing facets dynamically. The facets' configuration and list of facets displayed by default must be injected in the Facet Service by calling BsFacetModule.forRoot() in your app.module.ts:  // List of facet configurations (of type list and tree) export const allFacets: FacetConfig&lt;FacetListParams | FacetTreeParams&gt;[] = [ { name: &quot;facet1&quot;, type: &quot;list&quot;, parameters: { aggregation: &quot;Aggregation1&quot; } }, { name: &quot;facet2&quot;, type: &quot;tree&quot;, parameters: { aggregation: &quot;Aggregation2&quot; } } ]; // List of default facets displayed (only facet2 is displayed here) export const defaultFacets: FacetState[] = [ {name: &quot;facet2&quot;, position: 0} ]; @NgModule({ imports: [ ..., BsFacetModule.forRoot(allFacets, defaultFacets) ] })   This component requires at least a Results input and optionally a list of custom components (facetComponents).  &lt;sq-facet-bar [results]=&quot;results&quot; [facetComponents]=&quot;facetComponents&quot;&gt; &lt;/sq-facet-bar&gt;   It is also possible to insert static content which will be displayed at the top of the facet bar.  &lt;sq-facet-bar [results]=&quot;results&quot; [facetComponents]=&quot;facetComponents&quot;&gt; &lt;!-- Static facet --&gt; &lt;sq-facet-card [title]=&quot;'Sources'&quot; [icon]=&quot;'fas fa-sitemap'&quot;&gt; &lt;sq-facet-tree #facet [results]=&quot;results&quot; [aggregation]=&quot;'Treepath'&quot;&gt;&lt;/sq-facet-tree&gt; &lt;/sq-facet-card&gt; &lt;/sq-facet-bar&gt;   ","version":"Next","tagName":"h3"},{"title":"Multiple-type Facet​","type":1,"pageTitle":"Facet Module","url":"/dokku/docs/libraries/components/facet#multiple-type-facet","content":" The &quot;multiple-type&quot; facet sq-facet-multi displays multiple types of metadata in the same facet. The user selects the type of metadata, which then changes the view of the facet into one of the classical views above.  This component requires at least a Results input, the list of the facets configuration (equivalent to the allFacets list of the facet bar above), and optionally a list of custom components (facetComponents). The title and icon of the facet card need to be set dynamically, as a function of the currently selected metadata.    ","version":"Next","tagName":"h3"},{"title":"Facet Container​","type":1,"pageTitle":"Facet Module","url":"/dokku/docs/libraries/components/facet#facet-container","content":" The sq-facet-container component displays a list of buttons that users can click to open a facet.  This component is used in the integrated search form of the Pepper application.    Note that the style of the buttons can be customized via the buttonClass input (default: primary).  This component lets the user choose between the &quot;current results&quot; and &quot;all data&quot;:  The &quot;current results&quot; mode corresponds to the normal behavior of facets.The &quot;all data&quot; mode corresponds to the aggregations computed with no filters over all indexes. This data is computed by the FirstPageService with a separate (potentially slow) query sent to the server. This mode is useful to display the facets on a home page, when no search has been performed yet.  ","version":"Next","tagName":"h3"},{"title":"Facet Filters​","type":1,"pageTitle":"Facet Module","url":"/dokku/docs/libraries/components/facet#facet-filters","content":" The sq-facet-filters components displays facets as a navigation bar where each item is a facet displayed as a dropdown component.    This component requires a:  Results input.FacetConfig&lt;T&gt;[]: A list of facets' configuration. This list can be passed directly via the [facets] input (as for the Multiple type facet). Or it can be injected with the BsFacetModule.forRoot() method (as for the Facet bar). This 2nd option is interesting when enableCustomization is set to true.facetComponents: Optionally, a map of &quot;facet types&quot; (&quot;list&quot;, &quot;range&quot;, &quot;date&quot;, etc.) to facet components (BsFacetList, BsFacetRange, BsFacetDate, etc.).enableCustomization: Optionally, turns on user customization of the list of facets displayed in the component.  ","version":"Next","tagName":"h3"},{"title":"Facet Service​","type":1,"pageTitle":"Facet Module","url":"/dokku/docs/libraries/components/facet#facet-service","content":" The FacetService provides the following functionality:  Provide access to the facet data, via the following methods: facetService.getAggregation(aggregation name, results): Returns the ListAggregation or TreeAggregation from the results (and takes care of initializing the aggregation items).facetService.open(aggregation, item, query): Opens a collapsed node item in a tree aggregation (queries the server for the data inside that node).facetService.loadData(aggregation name, query): Loads more data from the server to append at the end of a list aggregation. Add and remove search filters (When a user clicks on an aggregation item in a facet): facetService.addFilterSearch(aggregation, selected items, options, query, facet name): Add a filter to the query for a given facet and aggregation, and refresh the search.facetService.removeFilterSearch(aggregation, selected item, query, facet name): Remove a filter from the query for a given facet and aggregation, and refresh the search.facetService.clearFiltersSearch(fields, all?, query, facet name): Clears filters from a facet, and refresh the search.facetService.hasFiltered(field, query): Returns whether the query has an active filter for a field. Manage the presence/absence of facets in dynamic containers like the facet bar component (the states of dynamic facet is stored in the User Settings): facetService.isFacetOpened(facet name): Test whether a facet is visible in a container.facetService.addFacet(facet state): Add a facet to a container.facetService.removeFacet(facet state): Remove a facet from a container.  ","version":"Next","tagName":"h2"},{"title":"Components​","type":1,"pageTitle":"Facet Module","url":"/dokku/docs/libraries/components/facet#components","content":" ","version":"Next","tagName":"h2"},{"title":"List Facet​","type":1,"pageTitle":"Facet Module","url":"/dokku/docs/libraries/components/facet#list-facet","content":" The sq-facet-list component displays a regular list of metadata (aggregation). The user can click on items in the list to filter the results.    This component requires at least a Results input and the name of the aggregation to work properly.  The full list of inputs is:  results: The current search results.aggregation: The name of the regular list of metadata.name: The name of the search filter associated to this facet. If ommited, the aggregation name is used.showCount: (true by default) Show/hide the number of occurrences.searchable: (true by default) Whether the component allows to search for items in it.focusSearch: (false by default) Whether the search input should be focused automatically.allowExclude: (true by default) Allow to exclude selected items.allowOr: (true by default) Allow to search various items in OR combination.allowAnd: (true by default) Allow to search various items in AND combination.displayEmptyDistributionIntervals: (false by default) If the aggregration is a distribution, then this property defines whether empty distribution intervals should be displayed.acceptNonAggregationItemFilter: (true by default) When false, filtered items which don't match an existing aggregation item, should not be added to the filtered list.replaceCurrent: (false by default) If true, the current search filter associated to this facet will be cleared and replaced by the new value.expandedLevel: (2 by default) The number of levels the list should be expanded to.  This component can be used in two ways :  Basic angular component and input bindings (as the example above)By transclusion within a parent component. This approach requires a config object implementing the FacetListConfig interface.  ","version":"Next","tagName":"h3"},{"title":"Range Facet​","type":1,"pageTitle":"Facet Module","url":"/dokku/docs/libraries/components/facet#range-facet","content":" The sq-facet-range component displays a slider to select a range of values for a numerical (eg. document size) or temporal (eg. modified date) metadata.    The full list of inputs is:  results: The current search results.aggregation: The name of the regular list of metadata.name: The name of the search filter associated to this facet. If ommited, the aggregation name is used.min: Minimum authorized value of the range.max: Maximum authorized value of the range.stepDefs: Allow to exclude selected items.  This component can be used in two ways :  Basic angular component and input bindings (as the example above)By transclusion within a parent component. This approach requires a config object implementing the FacetRangeConfig interface.  ","version":"Next","tagName":"h3"},{"title":"Refine Facet​","type":1,"pageTitle":"Facet Module","url":"/dokku/docs/libraries/components/facet#refine-facet","content":" The sq-refine component displays a secondary search form, including an autocomplete, to add a fulltext search criteria to a query, without removing the active filters.    This component requires at least a Results input. If the autocomplete is enabled, all the parameters of the autocomplete directive should be provided to this component.  The full list of inputs is:  results: The current search results.autocompleteEnabled: Whether or not to enable autocompletion.suggestQuery: Suggest query with which to perform autocompletion.suggestDelay: (200 by default) Minimum delay (in ms) between suggest queries.  This component can be used in two ways :  Basic angular component and input bindings (as the example above)By transclusion within a parent component. This approach requires a config object implementing the FacetRefineConfig interface.  ","version":"Next","tagName":"h3"},{"title":"Tag Cloud Facet​","type":1,"pageTitle":"Facet Module","url":"/dokku/docs/libraries/components/facet#tag-cloud-facet","content":" The sq-facet-tag-cloud displays multiple types of metadata in the same facet. It provides a direct access to the most relevant filters, belonging to the supplied metadata.    The inputs of the component are:  results: The results of the current search.aggregations: List of aggregations to be considered in collecting data.limit: (50 by default) Maximum number of data to be displayed.uniformRepartition: (false by default) Define the way data are collected from given aggregations: equal repartition between them or most relevant among all of them.showCount: (false by default) show/hide number of occurrences of each item.proportionalWeight: (true by default) Define the size of each displayed item: common size for all or proportional size based on item's count.countThreshold: (0 by default) Lowest count under which items will not be taken into account.shuffleData: (false by default) Wether data are rendered sorted according to their count or randomly.  This component can be used in two ways :  Basic angular component and input bindings (as the example above)By transclusion within a parent component. This approach requires a config object implementing the FacetTagCloudConfig interface. ","version":"Next","tagName":"h3"},{"title":"Machine Learning Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/components/machine-learning","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Machine Learning Module","url":"/dokku/docs/libraries/components/machine-learning#features","content":" This module introduces the Neural Search components displaying Answers and Passages extracted from the documents according to your search.  ","version":"Next","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Machine Learning Module","url":"/dokku/docs/libraries/components/machine-learning#prerequisites","content":" The SBA framework requires some configuration on the Sinequa server in order to have access to Neural Search features. Note that it comes within the usual query API and not an additional one, so there is nothing to change there.  On the server, your application needs to be linked to a query web service with Neural Search enabled. To do so, you need to have an index with Neural Search configuration set, you can then link a query web service to this index and enable Neural Search in the Search Settings tab, you then can use it for your SBA application's query.  ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Machine Learning Module","url":"/dokku/docs/libraries/components/machine-learning#import","content":" import { MLModule } from '@sinequa/components/machine-learning'; @NgModule({ imports: [ /*....*/ MLModule, /*....*/ ], /*....*/ })   This module is internationalized: If not already the case, you need to import its messages for the language(s) of your application. For example, in your app's src/locales/en.ts:  ... import {enML} from &quot;@sinequa/components/machine-learning&quot;; const messages = Utils.merge({}, ..., enML, appMessages);   ","version":"Next","tagName":"h2"},{"title":"API usage​","type":1,"pageTitle":"Machine Learning Module","url":"/dokku/docs/libraries/components/machine-learning#api-usage","content":" This module exports the AnswerCardComponent, TopPassagesComponent and PassageListComponent components that are responsible for displaying the Neural Search data from your query.  It also exports components for chatting with a Generative Large Language Model: ChatComponent, ChatSettingsComponent and SavedChatsComponent.  ","version":"Next","tagName":"h2"},{"title":"Answer Component​","type":1,"pageTitle":"Machine Learning Module","url":"/dokku/docs/libraries/components/machine-learning#answer-component","content":" The answers are the possible direct answers the platform supposes from your query according to the documents it searches through.    Required parameters:  results: The query's results which includes all the necessary data to display the answers.  Optional parameters:  collapsed (default: false): Whether the components starts collapsed.showLikeButtons (default: false): Whether the Like/Dislike buttons should be shown.hideDate (default: false): Whether the dates should be hidden.dateFormat (default: { year: 'numeric', month: 'short', day: 'numeric' }): The format for the dates.  The component also emits previewOpened, triggered when the answer has been clicked and that we should open the preview, and also titleClicked upon clicking the title.  ","version":"Next","tagName":"h3"},{"title":"Top Passages Component​","type":1,"pageTitle":"Machine Learning Module","url":"/dokku/docs/libraries/components/machine-learning#top-passages-component","content":" Similar as the Answer component, the Top Passages one displays the relevant passages that Neural Search has figured from your query according to your documents.  The passages may include some answers which are included in spans with an answer class which allows to highlight them.    Required parameters:  results: The query's results which includes all the necessary data to display the passages.  Optional parameters:  collapsed (default: false): Whether the components starts collapsed.hideDate (default: false): Whether the dates should be hidden.dateFormat (default: { year: 'numeric', month: 'short', day: 'numeric' }): The format for the dates.  The component also emits passageClicked, usually to open the preview, and documentOpened when the title is clicked.  ","version":"Next","tagName":"h3"},{"title":"Passage List​","type":1,"pageTitle":"Machine Learning Module","url":"/dokku/docs/libraries/components/machine-learning#passage-list","content":" The passages list is used to display all of the relevant passages from the selected document in a collapsed number of lines that you can expand manually.  It is placed in the mini preview where you can switch of view between the document preview and the passages list when some are found.    Required parameters:  record: The selected document from the results list.  Optional parameters:  maxPassages: The maximum number of passages to show from the passages list of the document.passageId: The id from a passage to expand it automatically.  ","version":"Next","tagName":"h3"},{"title":"Chat​","type":1,"pageTitle":"Machine Learning Module","url":"/dokku/docs/libraries/components/machine-learning#chat","content":"   The chat opens a conversation instance with a Generative Large-Language Model service (such as Azure OpenAI, powering ChatGPT, or Google's PaLM). It has a default configuration and therefore doesn't require any parameter in order to work, but there are many options to configure it.  Optional parameters:  chat: A saved chat, to reload the previous messages, tokens and attachments. These conversations may be SavedChat (conversations manually saved by the user), or programmatically-constructed conversation starters (for example &quot;take these documents and build a summary&quot;). (the null input is needed if no other input is provided to the component)enableChat (default: true): Whether it is allowed to chat with ChatGPT (we may want to disable it sometimes, like when we just want to display a summary, or any desired message that we can setup with the prompt configuration).searchMode (default: false): When set to true, this enables &quot;auto-search&quot;. This lets users trigger a Sinequa search query that constructs &quot;attachments&quot; (snippets of text from documents) that they can then inject in the conversation with ChatGPT. Auto-search is triggered directly from the Chat's input, by pressing the Tab key, or by click the Sinequa logo displayed to the right of the search bar.    query (default: SearchService.query): The query to interact with when making requests (like when searching for attachments while in searchMode).All properties from defaultChatConfig to override (model, UI, prompts, auto search properties)  Here is the simplest possible usage of the chat component:  &lt;sq-chat [chat]=&quot;null&quot;&gt;&lt;/sq-chat&gt;   Another example could be to provide the list of passages and ask for a summary:  const passages = this.searchService.results?.topPassages?.passages; if(passages?.length) { const attachments = this.chatService.addTopPassages(passages, []); const prompt = `Please generate a summary of these passages`; const messages = [ {role: 'system', display: false, content: prompt} ]; this.chat = {messages, attachments}; }   &lt;sq-chat [chat]=&quot;chat&quot;&gt;&lt;/sq-chat&gt;   ","version":"Next","tagName":"h3"},{"title":"Chat Settings​","type":1,"pageTitle":"Machine Learning Module","url":"/dokku/docs/libraries/components/machine-learning#chat-settings","content":"   This component allows to edit a chat configuration, which corresponds to all properties from the ChatConfig interface.  It only requires the config input, and emits on reset when the user clicks on the Reset button.  &lt;sq-chat-settings [config]=&quot;chatConfig&quot;&gt;&lt;/sq-chat-settings&gt;   ","version":"Next","tagName":"h3"},{"title":"Saved Chats​","type":1,"pageTitle":"Machine Learning Module","url":"/dokku/docs/libraries/components/machine-learning#saved-chats","content":" sq-chat offers the possibility to save a chat session in the User Settings. In order to load them back, the sq-saved-chat component can be used to display the list chats that have been saved.  The component requires no input parameter. It will only emit the SavedChat with the load input upon clicking on a chat name, and you can also delete them in this list if you wish. ","version":"Next","tagName":"h3"},{"title":"Labels Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/components/labels","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Labels Module","url":"/dokku/docs/libraries/components/labels#features","content":" This module provides functionality to display the labels of a document, as well as components to manage them:  LabelsService: manages the different operations that can be applied to the labels of a document in Sinequa.A list of components to display and manage the labels. These components are styled with the Bootstrap library, and their class names start with Bs.  ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Labels Module","url":"/dokku/docs/libraries/components/labels#import","content":" import { BsLabelsModule } from '@sinequa/components/labels'; @NgModule({ imports: [ /*....*/ BsLabelsModule, /*....*/ ], /*....*/ })   This module is internationalized: If not already the case, you need to import its messages for the language(s) of your application. For example, in your app's src/locales/en.ts:  ... import {enLabels} from &quot;@sinequa/components/labels&quot;; const messages = Utils.merge({}, ..., enLabels, appMessages);   ","version":"Next","tagName":"h2"},{"title":"Labels Service​","type":1,"pageTitle":"Labels Module","url":"/dokku/docs/libraries/components/labels#labels-service","content":" The LabelsService provides a variety of methods.  So far, if your component wants to know the index columns, use the following :  publicLabelsField(): string | undefined This method returns the index column for the public labels. privateLabelsField(): string | undefined This method returns the index column for the private labels.  Public labels can have specific access rules. If your components need to respect users rights and the label's configuration on the server side, use the following :  allowPublicLabelsManagement(): boolean This method indicates if the configuration of the Sinequa server is globally allowing to manage (create/rename/delete) public labels. allowPublicLabelsEdition(): boolean This method indicates if the configuration of the Sinequa server is globally allowing to edit (add/remove/bulkAdd/bulkRemove) public labels. userLabelsRights(): LabelsRights This method retrieves the logged in user's rights to manage and edit public labels.  Actually, the Labels Module defines three levels of actions that could be applied to labels :  ","version":"Next","tagName":"h2"},{"title":"Navigation bar menu actions​","type":1,"pageTitle":"Labels Module","url":"/dokku/docs/libraries/components/labels#navigation-bar-menu-actions","content":" As for global actions, the menu, in the navigation bar, uses the ModalService to open a popup dialog and perform following actions :  renameLabelModal(): Promise&lt;ModalResult&gt; This method renames the label(s) in the index. Be careful, this action is irreversible. deleteLabelModal(): Promise&lt;ModalResult&gt; This method deletes the selected label(s) from the index. Be careful, this action is also irreversible. bulkRemoveLabelModal(): Promise&lt;ModalResult&gt; This method unassign the given label(s) from all results reported by the engine (not only from the first page). bulkAddLabelModal(): Promise&lt;ModalResult&gt; This method assign the given label(s) to all results reported by the engine (not only to the first page).  Note that the methods _modalProperties(action: number): ModalProperties and _getModalRadioButtonsConf(publicRight: boolean): any are used to full-fill the properties of each modal.  ","version":"Next","tagName":"h3"},{"title":"Selection menu actions​","type":1,"pageTitle":"Labels Module","url":"/dokku/docs/libraries/components/labels#selection-menu-actions","content":" If you are targeting a specific selected documents, the selection menu actions is the right place to edit their labels.  buildSelectionAction(): Action | undefined the syntactic sugar to append the labels edit action to the selection menu.  Therefor, two use cases can be distinguished :  For a single document selection, a popup dialog with one autocomplete input is used to update the labels of this document. Thus, it can be an assign, unassign or even both actions at the same time. For a multi-selection, the popup dialog is getting divided into two blocs to separately, defining which labels to be assigned to all the selected documents and which ones to be unassigned from them.  Both cases are using the same method:  editLabelModal(): Promise&lt;ModalResult&gt; This method edits the labels of the current selected documents.  ","version":"Next","tagName":"h3"},{"title":"Displayed labels actions​","type":1,"pageTitle":"Labels Module","url":"/dokku/docs/libraries/components/labels#displayed-labels-actions","content":" Each Document's labels are displayed just below its extracts. Selecting a label will filter the current results page while keeping documents whose labels are given in the list. Here you will be using selectLabels(labels: string[], _public: boolean): Promise&lt;boolean&gt;.  The LabelsService also provides the LABELS_COMPONENTS injection token which can be used to override the UI components used in this module.  To do that you need to declare your component with the Angular providers in app.module.ts  /* ... */ import { NgModule } from &quot;@angular/core&quot;; import { LABELS_COMPONENTS } from &quot;@sinequa/components/labels.service&quot;; /* ... */ @NgModule({ /* ... */ providers: [ /* ... */ { provide: LABELS_COMPONENTS, useValue: MyCustomLabelsComponents }, /* ... */ ] /* ... */ }) /* ... */   This MyCustomLabelsComponents object needs to be  { renameModal: Type&lt;any&gt;; labelsAutocompleteComponent: Type&lt;any&gt;; deleteModal: Type&lt;any&gt;; addModal: Type&lt;any&gt;; editModal: Type&lt;any&gt;; }   If your component wants to manipulate the labels of the a document itself, without using the LabelPipe (ie sqLabel), The LabelsService provides here some methods that you may need:  LabelsService.privateLabelsPrefix: returns the prefix that are to be pre-appended to private label value.addPrivatePrefix(labels: string|string[]): string|string[]: prepends the private label prefix to the given label list.removePrivatePrefix(labels: string|string[]): string|string[]: removes the private label prefix from the given label list.split(labels: string): string[]: transform a semicolon-delimited label list string into a list of labels.sort(labels: string[], _public: boolean): string[]: sorts the labels list in ascending order with respect to the current locale.  ","version":"Next","tagName":"h3"},{"title":"Components​","type":1,"pageTitle":"Labels Module","url":"/dokku/docs/libraries/components/labels#components","content":" The LabelsModule comes with a set of components :  The LabelsMenu component is used to display dropdown menu that manages public and private labels. You can see this menu in the navigation bar. Labels menu in navigation bar The inputs of the component are: results: The current search results.icon: The menu icon.autoAdjust: Whether the component will adjust its display when the application is resized.autoAdjustBreakpoint: The threshold of the application size at which the display of the component changes.collapseBreakpoint: The threshold of the application size at which the display of the component changes when it is inside a parent menu.size: The display size of the component. The Labels component is used to display and to manage the assigned labels of a document. Note the background color used to distinguish public and private labels. Display labels of a document The inputs of the component are: record: The record whose labels are to be displayed.enableDelete: Display the delete icon in the label tag.public: Whether the labels are public. The ResultLabels component is used to display the assigned labels of a document. This component is backed by Labels component. The inputs of the component are: record: The record whose labels are to be displayed.caption: The caption for the labels.public: Whether the labels are public. The Modals components have basically a very common behavior for the different actions on the labels. The standard template can be seen as a(n): Alert texts: Explicitly explain the action to be performed on labels.Radio button: The type of label you want to manage. Note that it depends on the configuration of sinequa instance.Autocomplete input: List of labels you want to manage. Each modal component uses the MODAL_MODEL injection token. The object needs to be { public: boolean; allowEditPublicLabels: boolean; allowManagePublicLabels: boolean; allowNewLabels: boolean; disableAutocomplete: boolean; action: number; radioButtons: ModalButton[]; } where: public: Whether the labels are public.allowEditPublicLabels: The user right to Add, Remove, BulkAdd, BulkRemove operations.allowManagePublicLabels: The user right to Create, Rename, Delete operations.allowNewLabels: Whether considering the selection of a not existing label among the suggestions.disableAutocomplete: Turns off the autocomplete input.action: The action to be performed as result of the current popup dialog.radioButtons: Properties of the modal buttons . The BsLabelsAutocomplete component is the main building block of the Modals components. Actually, it is an input element, hosting the sqAutocompleteLabels directive. Example: &lt;input type=&quot;text&quot; class=&quot;input-autocomplete flex-grow-1&quot; name=&quot;labelName&quot; spellcheck=&quot;false&quot; autocomplete=&quot;off&quot; sqAutocompleteLabels [public]=&quot;public&quot; [placeholder]=&quot;'msg#labels.selectLabel' | sqMessage&quot; [dropdown]=&quot;dropdown&quot; [allowNewLabels]=&quot;allowNewLabels&quot; [allowManagePublicLabels]=&quot;allowManagePublicLabels&quot; (keydown)=&quot;keydown($event)&quot; (keypress)=&quot;keypress($event)&quot; (itemsUpdate)=&quot;onLabelsItemsChanged($event)&quot; [disabled]=&quot;disableAutocomplete&quot; [off]=&quot;disableAutocomplete&quot; [class.disabled]=&quot;disableAutocomplete&quot; [labelsItems]=&quot;labelsItems&quot;&gt; The inputs of the component are: public: Whether the labels are public.disableAutocomplete: Turns off the autocomplete input.allowNewLabels: Whether considering the selection of a not existing label among the suggestions.allowManagePublicLabels: Here it means the user right to allow adding new labels.labelsItems: Initial labels to be displayed in the container. The component also emits a labelsUpdate event used to synchronize the list of selected labels and their type in the parent component. The component takes as input public (Whether the labels are public) and emits itemRemoved event each time a label is getting removed from the list.  ","version":"Next","tagName":"h3"},{"title":"Labels Autocomplete directive​","type":1,"pageTitle":"Labels Module","url":"/dokku/docs/libraries/components/labels#labels-autocomplete-directive","content":" The LabelsAutocomplete provides the sqAutocompleteLabels directive. It extends and overrides the main sqAutocomplete directive. Thus, the suggestions are fetched and displayed also in case of empty input. This feature requires the labelsAutoSuggestWildcard to be configured in the sinequa server.    In addition to that, the selection of items is being possible on blur event. As a result, on blur, the value of the input is checked against the existing suggestions and then added to the list if it matches.  The inputs of the directive are:  public: Whether the labels are public.labelsItemsContainer: Container displaying the selected labels and obviously implementing LabelsItemsContainer interface.allowNewLabels: Whether considering the selection of a not existing label among the suggestions.allowManagePublicLabels: Here it means the user right to allow adding new labels.initLabels: Initial labels to be displayed in the container.  The directive also emits an itemsUpdate event which is needed to synchronize the list of selected labels in the parent component.  ","version":"Next","tagName":"h3"},{"title":"Labels Pipe​","type":1,"pageTitle":"Labels Module","url":"/dokku/docs/libraries/components/labels#labels-pipe","content":" Private labels are encoded before being stored in index columns. The LabelPipe (sqLabel) is introduced to help you with displaying the labels assigned to a document without worrying about the decoding procedure and eventually, formatting the value.  Example:  &lt;span&gt;Private label: &lt;/span&gt;&lt;span style=&quot;color: red;&quot;&gt;{{privateLabel | sqLabel:false}}&lt;/span&gt; &lt;span&gt;Public label: &lt;/span&gt;&lt;span style=&quot;color: red;&quot;&gt;{{publicLabel | sqLabel:true}}&lt;/span&gt;   With a document whose private label is 'My private label' and 'My public label', the example yields  &lt;span&gt;Private label: &lt;/span&gt;&lt;span style=&quot;color: red;&quot;&gt;My private label&lt;/span&gt; &lt;span&gt;Public label: &lt;/span&gt;&lt;span style=&quot;color: red;&quot;&gt;My public label&lt;/span&gt;  ","version":"Next","tagName":"h3"},{"title":"Modal Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/components/modal","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Modal Module","url":"/dokku/docs/libraries/components/modal#features","content":" The Modal module is divided into two parts:  The generic part in @sinequa\\core provides service, and components declaration for the creation of popup modals,The components in @sinequa\\components provides overrides for the components in @sinequa\\core for styling, for Bootstrap (BsModalModule).  This documentation page focuses on the Bootstrap flavor components of Modal.  Please refer to the document of the core modal module for the usage of the generic module.  ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Modal Module","url":"/dokku/docs/libraries/components/modal#import","content":" import { LoginModule } from &quot;@sinequa/core/login&quot;; import { ModalModule } from &quot;@sinequa/core/modal&quot;; import { BsModalModule } from &quot;@sinequa/components/modal&quot;; // Bootstrap flavor of Modal @NgModule({ imports: [ /*....*/ LoginModule, ModalModule, BsModalModule, // Overrides login and modal components with Bootstrap components /*....*/ ], /*....*/ })   This module is internationalized: If not already the case, you need to import its messages for the language(s) of your application. For example, in your app's src/locales/en.ts:  ... import {enModal} from &quot;@sinequa/components/modal&quot;; const messages = Utils.merge({}, ..., enModal, appMessages);   ","version":"Next","tagName":"h2"},{"title":"API usage​","type":1,"pageTitle":"Modal Module","url":"/dokku/docs/libraries/components/modal#api-usage","content":" This module introduces the BsModal component that helps creating popup modal with Bootstrap styling.  This component provides the sq-modal selector that can be used to display a modal in the HTML template of your component  Example: The &quot;New saved query&quot; popup with BsModal  &lt;form name=&quot;editSavedQuery&quot; novalidate [formGroup]=&quot;form&quot;&gt; &lt;sq-modal [title]=&quot;'msg#editSavedQuery.title'&quot; [buttons]=&quot;buttons&quot;&gt; &lt;div class=&quot;form-group sq-form-group&quot;&gt; &lt;label for=&quot;savedQueryName&quot;&gt; {{'msg#editSavedQuery.name' | sqMessage}} &lt;/label&gt; &lt;input [sqValidation]=&quot;form&quot; type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;savedQueryName&quot; formControlName=&quot;savedQueryName&quot; spellcheck=&quot;off&quot; sqAutofocus &gt; &lt;/div&gt; &lt;/sq-modal&gt; &lt;/form&gt;   which yields the following popup  New saved query popup  The input of the components are  title: The title of the popup, could be internationalized (i18n) messagebuttons: The list of the buttons in the popup, each follows the interface IModalButton,showHeader: whether to show the header of the modal, true by default,showFooter: whether to show the footer of the modal, true by default. ","version":"Next","tagName":"h2"},{"title":"Metadata Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/components/metadata","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Metadata Module","url":"/dokku/docs/libraries/components/metadata#features","content":" This module introduces the UI component that displays the metadata of a document in the search result page.  Document metadata  ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Metadata Module","url":"/dokku/docs/libraries/components/metadata#import","content":" import { MetadataModule } from '@sinequa/components/metadata'; @NgModule({ imports: [ /*....*/ MetadataModule, /*....*/ ], /*....*/ })   This module is internationalized: If not already the case, you need to import its messages for the language(s) of your application. For example, in your app's src/locales/en.ts:  ... import {enMetadata} from &quot;@sinequa/components/metadata&quot;; const messages = Utils.merge({}, ..., enMetadata, appMessages);   ","version":"Next","tagName":"h2"},{"title":"API usage​","type":1,"pageTitle":"Metadata Module","url":"/dokku/docs/libraries/components/metadata#api-usage","content":" This module exports 2 main components: MetadataItemComponent which displays one metadata entry, and MetadataComponent which displays a list of metadata entries with a layout.  An entry of metadata is simply a value of an index column of the considered document. Documents have many different types of metadata (mono-valued, multiple-valued, entities, tree-structured, text, numbers, dates, booleans...)  For example, some of the metadata displayed by vanilla-search are:  Metadata title\tIndex column\tFontawesome IconSources\ttreepath\tfas fa-folder-open Filename\tfilename\tfar fa-file-alt Date\tmodified\tfar fa-calendar-alt Authors\tauthors\tfas fa-user-edit  ","version":"Next","tagName":"h2"},{"title":"The sq-metadata-item selector​","type":1,"pageTitle":"Metadata Module","url":"/dokku/docs/libraries/components/metadata#the-sq-metadata-item-selector","content":"   This component displays one metadata entry and it expects these inputs:  Required parameters:  record: The document whose metadata is being displayed.field: The column name to retrieve the value from.  Optional parameters:  query (default: SearchService.query): The query to apply any filter action to.label: A label to insert before the value (which will look like &quot;label: value&quot;).icon: The Fontawesome class of the icon to insert before the label and value.fieldClass: Any additional CSS classes you want to apply to the field value.filterable (default: false): Whether you can add a filter on this metadata for the query. This will add a &quot;Filter&quot; button in a tooltip.excludable (default: false): Whether you can add an exclusion filter on this metadata for the query. This will add an &quot;Exclude&quot; button in a tooltip.showEntityExtract (default: false): Whether the entity extract should be displayed in a tooltip. Note that there are some prerequisites on the server like checking &quot;return entity locations&quot; in the Query web service.actions: Any additional actions for the metadata entry to display in a tooltip.collapseRows (default: true): Whether the rows are collapsible, to save space.entityExtractMaxLines (default: 4): The maximum number of lines to display for the entity extract in the tooltip.actionsButtonsStyle (default: btn btn-secondary): The style to apply to the action buttons.actionsButtonsSize (default: sm): The size to apply to the action buttons.  ","version":"Next","tagName":"h3"},{"title":"The sq-metadata selector​","type":1,"pageTitle":"Metadata Module","url":"/dokku/docs/libraries/components/metadata#the-sq-metadata-selector","content":"   This component displays a list of sq-metadata-item and facilitates the layout which can either be linear or with one entry per line. It also allows to construct sentences to include metadata entries to.  Required parameters:  record: The document whose metadata is being displayed,config ((MetadataConfig | string)[]): The metadata entries of the document to be displayed, this is a list containing some MetadataConfig objects which contain the parameters to apply for each metadata entry following what sq-metadata-item as inputs. There can also be strings in this array which allows you to make sentences with metadata entries in the middle of them (example below).  Optional parameters:  query (default: SearchService.query): The query to apply any filter action to.layout (default: inline): The type of layout for the metadata entries list. This can only be &quot;inline&quot; (all next to each other) or &quot;table&quot; (one per line).actionsButtonsStyle (default: btn btn-secondary): The style to apply to the action buttons.actionsButtonsSize (default: sm): The size to apply to the action buttons.  The component also emits an event when an element of the metadata is selected / clicked on.  ","version":"Next","tagName":"h3"},{"title":"Examples​","type":1,"pageTitle":"Metadata Module","url":"/dokku/docs/libraries/components/metadata#examples","content":" ","version":"Next","tagName":"h2"},{"title":"Metadata​","type":1,"pageTitle":"Metadata Module","url":"/dokku/docs/libraries/components/metadata#metadata","content":" The following metadata is displayed with all the default options:  this.metadata: MetadataConfig[] = [ { field: &quot;docformat&quot;, label: &quot;Format&quot;, icon: &quot;fas fa-info-circle&quot; }, { field: &quot;modified&quot;, label: &quot;Date&quot;, icon: &quot;far fa-calendar-alt&quot; }, { field: &quot;size&quot;, label: &quot;Size&quot;, icon: &quot;fas fa-weight-hanging&quot; }, { field: &quot;treepath&quot;, label: &quot;Source&quot;, icon: &quot;fas fa-folder-open&quot; }, { field: &quot;filename&quot;, label: &quot;Filename&quot;, icon: &quot;far fa-file-alt&quot; } ];   &lt;sq-metadata [record]=&quot;record&quot; [config]=&quot;metadata&quot;&gt; &lt;/sq-metadata&gt;     You can also add the [layout]=&quot;'table'&quot; input to the component to have one entry per line.    The filterable and excludable parameters can be used to display the filtering buttons when hovering the metadata entry:  this.metadata: MetadataConfig[] = [ { field: &quot;docformat&quot;, label: &quot;Format&quot;, icon: &quot;fas fa-info-circle&quot;, filterable: true, excludable: true }, { field: &quot;modified&quot;, label: &quot;Date&quot;, icon: &quot;far fa-calendar-alt&quot;, filterable: true }, ...       If a metadata is an entity, you can set the showEntityExtract parameter as true to display the entity extract when you hover it:    Here is an example with a custom action:  this.metadata: MetadataConfig[] = [ { field: &quot;docformat&quot;, label: &quot;Format&quot;, icon: &quot;fas fa-info-circle&quot;, filterable: true, excludable: true, actions: [new Action({ text: &quot;Test&quot;, icon: &quot;fas fa-user-edit&quot;, action: () =&gt; { // some code } }) }, ...     As mentioned before, the config array input can also contain strings, allowing to create full sentences containing some metadata entries inside of it. Here is an example:  this.metadata: (MetadataConfig | string)[] = [ &quot;The document &quot;, { field: &quot;filename&quot;, fieldClass: &quot;mx-1 badge rounded-pill bg-secondary&quot;, filterable: true }, &quot; has been created the &quot;, { field: &quot;modified&quot;, fieldClass: &quot;ms-1&quot; } ];     ","version":"Next","tagName":"h3"},{"title":"Metadata item​","type":1,"pageTitle":"Metadata Module","url":"/dokku/docs/libraries/components/metadata#metadata-item","content":" While sq-metadata facilitates the layout, you can just use sq-metadata-item to display a metadata entry:  &lt;sq-metadata-item [record]=&quot;record&quot; [field]=&quot;'modified'&quot;&gt;&lt;/sq-metadata-item&gt;     Or with more parameters:  &lt;sq-metadata-item [record]=&quot;record&quot; [field]=&quot;'modified'&quot; [icon]=&quot;'fas fa-phone'&quot; [fieldClass]=&quot;'badge rounded-pill bg-secondary'&quot; [filterable]=&quot;true&quot; [excludable]=&quot;true&quot; [label]=&quot;'Label'&quot;&gt; &lt;/sq-metadata-item&gt;    ","version":"Next","tagName":"h3"},{"title":"Notification Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/components/notification","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Notification Module","url":"/dokku/docs/libraries/components/notification#features","content":" This module introduces the Bootstrap-flavored components to display and manage user notifications.  For the creation and management of notifications, please refer to the Core Notification module.  An error notification  ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Notification Module","url":"/dokku/docs/libraries/components/notification#import","content":" import { BsNotificationModule } from &quot;@sinequa/components/notification&quot;; @NgModule({ imports: [ /*....*/ BsNotificationModule, /*....*/ ], /*....*/ })   This module is internationalized: If not already the case, you need to import its messages for the language(s) of your application. For example, in your app's src/locales/en.ts:  ... import {enNotification} from &quot;@sinequa/components/notification&quot;; const messages = Utils.merge({}, ..., enNotification, appMessages);   ","version":"Next","tagName":"h2"},{"title":"API usage​","type":1,"pageTitle":"Notification Module","url":"/dokku/docs/libraries/components/notification#api-usage","content":" ","version":"Next","tagName":"h2"},{"title":"Components​","type":1,"pageTitle":"Notification Module","url":"/dokku/docs/libraries/components/notification#components","content":" BsNotification​  The BsNotification component is the Bootstrap-flavor implementation of a notification shown on the screen.  BsNotifications​  The BsNotifications component is the component representing the current notification list and displaying the notification on the screen. It is imported and used in the app.component.html of vanilla-search.  BsNotificationsManager​  The BsNotificationsManager component is the component that is used to manage the list of notifications of your application.  For more information about how you can manage the notification list, please refer to Manage user notifications ","version":"Next","tagName":"h3"},{"title":"Results Views Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/components/results-view","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Results Views Module","url":"/dokku/docs/libraries/components/results-view#features","content":" This module provides a way to manage multiple views of the search results. At the core, the ResultsViewService keeps track of the current active view, and the list of all available views. This service persists the view name in the URL, and manages the navigation and interactions with the SearchService.  The module includes a component (coupled to the service) to select a view (among the list of all views), and a sample &quot;grid&quot; results view, that can be used as an alternative to a standard &quot;list&quot; results view. Other modules include other types of views, such as the heatmap results view.  ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Results Views Module","url":"/dokku/docs/libraries/components/results-view#import","content":" Import this module in your app.module.ts.  import { BsResultsViewModule } from '@sinequa/components/results-view'; @NgModule({ imports: [ ... BsResultsViewModule.forRoot(allViews, defaultView)   This module is internationalized: If not already the case, you need to import its messages for the language(s) of your application. For example, in your app's src/locales/en.ts:  ... import {enResultsView} from &quot;@sinequa/components/results-view&quot;; const messages = Utils.merge({}, ..., enResultsView, appMessages);   ","version":"Next","tagName":"h2"},{"title":"Defining Results Views​","type":1,"pageTitle":"Results Views Module","url":"/dokku/docs/libraries/components/results-view#defining-results-views","content":" A &quot;view&quot; is defined by a ResultsView object which contains different settings. Note that this object is independent from the actual rendering of the view: this aspect needs to be handled separately.  For example, let's imagine we have two views:  one standard list view (e.g. the one from Vanilla Search).one &quot;grid&quot; view (which is more compact, so it can display more results).  First, we define the ResultsView objects and inject them in our app.module.ts:  import { BsResultsViewModule, ResultsView } from '@sinequa/components/results-view'; export const allViews: ResultsView[] = [ { name: &quot;list&quot;, type: &quot;list&quot;, display: &quot;List&quot;, icon: &quot;fas fa-list&quot; }, { name: &quot;grid&quot;, type: &quot;grid&quot;, display: &quot;Grid&quot;, icon: &quot;fas fa-th&quot; } ]; export const defaultView = allViews[0]; @NgModule({ imports: [ ..., BsResultsViewModule.forRoot(allViews, defaultView)   ","version":"Next","tagName":"h2"},{"title":"Results View Service​","type":1,"pageTitle":"Results Views Module","url":"/dokku/docs/libraries/components/results-view#results-view-service","content":" The ResultsViewService keeps track of the current view and the list of all active views.  When switching views, the service navigates to a new URL including the view name as a query parameter.  Selecting a results view is as simple as calling:  this.resultsViewService.selectResultsViewName(&quot;grid&quot;);   Behind the scene, the service performs a series of actions:  Emit a before-select event (which can be caught by subscribing to this.resultsViewService.events). It is possible to trigger custom actions when this event is fired and tell the service to wait for these actions to complete before actually going to the next step: Simply add 1 (or more) Promise to the event object (event.promises.push(myActionPromise)).Optionally, execute a new custom search query that will yield different results from the ones displayed in the current view. To do so, add a beforeSearch method to the ResultsView object to modify the query (example below). In that case, the service waits for the results to come in before going to the next step.Navigate to a new URL with the new view name. For example #/search?view=grid&amp;query=....When the navigation is complete, the service finally sets this.resultsViewService.resultsView to the new view and emits an after-select event.  ","version":"Next","tagName":"h2"},{"title":"Displaying Results Views​","type":1,"pageTitle":"Results Views Module","url":"/dokku/docs/libraries/components/results-view#displaying-results-views","content":" The display of results views is managed via simple Angular template syntax:  &lt;ng-container *ngIf=&quot;resultsViewService.resultsView.name === 'list'&quot;&gt; &lt;!-- Template of the list view --&gt; &lt;/ng-container&gt; &lt;ng-container *ngIf=&quot;resultsViewService.resultsView.name === 'grid'&quot;&gt; &lt;!-- Template of the grid view --&gt; &lt;/ng-container&gt;   The module includes a standard &quot;grid&quot; result view component: sq-results-grid-view. You could use for example:  By convention, results view components expect the ResultsView object as an input parameter (view). The ResultsView interface can be extended to include more settings to configure the results view. For example, in the case of the grid results view, the GridView interface includes a columns array to configure what to display in each column of the grid.    ","version":"Next","tagName":"h2"},{"title":"Switching Between Views​","type":1,"pageTitle":"Results Views Module","url":"/dokku/docs/libraries/components/results-view#switching-between-views","content":" To switch between results views, include the sq-results-view-selector component. The component uses the ResultsViewService to display the current view and list of available views.    Alternatively, the selector can be displayed as a dropdown menu (useDropdownMenu = true):    ","version":"Next","tagName":"h2"},{"title":"Advanced options​","type":1,"pageTitle":"Results Views Module","url":"/dokku/docs/libraries/components/results-view#advanced-options","content":" It is possible to assign a view to specific tabs. Use the includedTabs and excludedTabs parameters of the ResultsView interface.  For example:  export const allViews: ResultsView[] = [ { name: &quot;list&quot;, type: &quot;list&quot;, display: &quot;List&quot;, icon: &quot;fas fa-list&quot;, includedTabs: [&quot;all&quot;] }, { name: &quot;grid&quot;, type: &quot;grid&quot;, display: &quot;Grid&quot;, icon: &quot;fas fa-th&quot;, columns: [ {active: true, title: &quot;Title&quot;, field: &quot;displayTitle&quot;, sortable: false, renderAsHtml: true}, {active: true, title: &quot;Type&quot;, field: &quot;sourcestr4&quot;, sortable: true, renderAsHtml: false}, {active: true, title: &quot;PageRank&quot;, field: &quot;sourcedouble1&quot;, sortable: true, renderAsHtml: false}, ], excludedTabs: [&quot;company&quot;, &quot;people&quot;] } ];   It is also possible to customize the query for a specific results view. But note that if you use that feature, you will probably need to customize the query for every view, to cancel the effects of the first modification.  For example, it would make sense to display more results in the grid view (let's say 100), so we can tune the query to do that (pageSize parameter), but we also need to clean up the query when switch from the grid view back to the list view:  export const allViews: (ResultsView|GridView)[] = [ { name: &quot;list&quot;, type: &quot;list&quot;, display: &quot;List&quot;, icon: &quot;fas fa-list&quot;, includedTabs: [&quot;all&quot;], beforeSearch: (query: Query) =&gt; {delete query.pageSize; return true;} }, { name: &quot;grid&quot;, type: &quot;grid&quot;, display: &quot;Grid&quot;, icon: &quot;fas fa-th&quot;, columns: [ {active: true, title: &quot;Title&quot;, field: &quot;displayTitle&quot;, sortable: false, renderAsHtml: true}, {active: true, title: &quot;Type&quot;, field: &quot;sourcestr4&quot;, sortable: true, renderAsHtml: false}, {active: true, title: &quot;PageRank&quot;, field: &quot;sourcedouble1&quot;, sortable: true, renderAsHtml: false}, ], excludedTabs: [&quot;company&quot;, &quot;people&quot;], beforeSearch: (query: Query) =&gt; {query.pageSize = 100; return true;} } ];  ","version":"Next","tagName":"h2"},{"title":"Preview Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/components/preview","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Preview Module","url":"/dokku/docs/libraries/components/preview#features","content":" This module provides functionality to display the HTML preview of a document in Sinequa, as well as features to interact with the content of this preview:  A service that queries the server for the preview data (PreviewData) and manages the different ways of displaying the preview (in a popup, in a route or in a new tab/window).A core API to display the HTML preview and interact with its content. It is composed of three components: sq-preview to display the preview, sq-preview-tooltip, a dynamic tooltip that can be inserted in the document, and sq-preview-minimap which adds a right bar with the location of the relevant extracts inside the document.Additional components based on this core API to interact with the preview and display some related data (the extracts or entities list, etc.).    ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Preview Module","url":"/dokku/docs/libraries/components/preview#import","content":" Import this module in your app.module.ts.  import { PreviewModule } from '@sinequa/components/preview'; @NgModule({ imports: [ ... PreviewModule   This module is internationalized: If not already the case, you need to import its messages for the language(s) of your application. For example, in your app's src/locales/en.ts:  ... import {enPreview} from &quot;@sinequa/components/preview&quot;; const messages = Utils.merge({}, ..., enPreview, appMessages);   ","version":"Next","tagName":"h2"},{"title":"Preview CSS and JS files​","type":1,"pageTitle":"Preview Module","url":"/dokku/docs/libraries/components/preview#preview-css-and-js-files","content":" In order for some features to work such as passages highlightings, entities coloring, the tooltip and the minimap, you need to load a preview.js file in your project. It is already set in Vanilla Search which contains a preview folder in its src folder, then in angular.json at the project's root:  &quot;vanilla-search&quot;: { ... &quot;architect&quot;: { &quot;build&quot;: { ... &quot;assets&quot;: [ ... &quot;projects/vanilla-search/src/preview/preview.js&quot; ],   And then to avoid duplicates and still use it in the other projects like Hello Search:  &quot;hello-search&quot;: { ... &quot;architect&quot;: { &quot;build&quot;: { ... &quot;assets&quot;: [ ... { &quot;glob&quot;: &quot;**/*.js&quot;, &quot;input&quot;: &quot;projects/vanilla-search/src/preview/&quot;, &quot;output&quot;: &quot;./preview&quot; } ],   To customize further the CSS, you also need to add preview.scss in the angular.json file, which is also present in Vanilla Search:  &quot;vanilla-search&quot;: { ... &quot;architect&quot;: { &quot;build&quot;: { ... &quot;styles&quot;: [ ... { &quot;input&quot;: &quot;projects/vanilla-search/src/preview/preview.scss&quot;, &quot;bundleName&quot;: &quot;preview&quot;, &quot;inject&quot;: false } ],   Because the preview is loaded in an iframe, those JS and CSS files have to be loaded separately from the rest of the application.  If despite importing the JS file you cannot see any highlights, you may want to make sure the Preview web service is properly setup on the server.  ","version":"Next","tagName":"h2"},{"title":"Preview Service​","type":1,"pageTitle":"Preview Module","url":"/dokku/docs/libraries/components/preview#preview-service","content":" The PreviewService provides the following API:  getPreviewData(id: string, query: Query, audit = true): Observable&lt;PreviewData&gt; This method uses the PreviewWebService to obtain the PreviewData for a given document and search query and also takes care of generating audit events. openRoute(record: Record, query: Query, path = &quot;preview&quot;) This method navigates to a URL of the form #preview?id=...&amp;query=..., which means your app must have a /preview route which takes care of extracting these parameters for the URL, querying getPreviewData() and displaying the preview. This is the case in Vanilla Search. openNewWindow(record: Record, query: Query) This method opens a new window with a URL of the form: #preview?id=...&amp;query=...&amp;app=..., which means your app must have a /preview route which takes care of extracting these parameters for the URL, querying getPreviewData() and displaying the preview. openModal(record: Record, query: Query, model: any) This method uses the ModalService to open a popup dialog with the preview. The component displayed by this modal is by default sq-preview, but it can be replaced by your own custom component by adding it in to your providers in app.module.ts: providers: [ ... {provide: PREVIEW_MODAL, useValue: MyPreviewPopup} ] Note that the component itself must take care of querying the getPreviewData() method.  ","version":"Next","tagName":"h2"},{"title":"Core API​","type":1,"pageTitle":"Preview Module","url":"/dokku/docs/libraries/components/preview#core-api","content":" ","version":"Next","tagName":"h2"},{"title":"Preview component​","type":1,"pageTitle":"Preview Module","url":"/dokku/docs/libraries/components/preview#preview-component","content":" The HTML preview is a standalone webpage with its styles and scripts. It must be displayed inside an &lt;iframe&gt; element. This is the role of the sq-preview component.  The component expects the following inputs:  id: The ID of the document. The component will use it to download the document data and display it properly.query (Optional, default SearchService.query): The query to search the record data from which will impact the additional data such as the relevant extracts according to your search text.scale (Optional, default 1): The default document scale.scaleIncrement (Optional, default 0.1): The amount to increment/decrement when handling the scale.highlightColors (Optional): A list of PreviewHighlightColors to provide information about the desired colors for some CSS classes.highlightEntities (Optional, default true): Whether to highlight entities by default.highlightExtracts (Optional, default true): Whether to highlight extracts by default.highlightActions (Optional, default true): Whether to display the highlight actions.extracts (Optional, default [&quot;matchlocations&quot;, &quot;extractslocations&quot;, &quot;matchingpassages&quot;]): List of highlights considered as &quot;extracts&quot;.usePassageHighlighter (Optional, default [&quot;extractslocations&quot;, &quot;matchingpassages&quot;]): List of the CSS classes that the passage highlighter should consider.preferenceName (Optional, default preview): Name of the preference property used to stored the highlight preferences.  By default, the highlights that are visible correspond to the highlightEntities and highlightExtracts inputs. If highlightActions is enabled, then the users have the possibility to toggle the highlights on and off. When this happens, their preference is stored in the user settings. Then the next time the component is displayed the preference is used instead of the highlightEntities and highlightExtracts parameters  When the HTML preview finishes loading, the component emits an empty ready event.  ","version":"Next","tagName":"h3"},{"title":"Preview Components​","type":1,"pageTitle":"Preview Module","url":"/dokku/docs/libraries/components/preview#preview-components","content":" ","version":"Next","tagName":"h2"},{"title":"Preview Tooltip​","type":1,"pageTitle":"Preview Module","url":"/dokku/docs/libraries/components/preview#preview-tooltip","content":" The core API also includes sq-preview-tooltip, a customizable component which can be inserted in the HTML preview, and responds to the user's mouse movements and clicks. This enables custom features when hovering over an entity or selecting some text.  Default Preview Tooltip when hovering over an entity  Customized tooltip showing a &quot;Search&quot; action in Vanilla Search  The tooltip is inserted in the preview by transclusion. It takes custom actions (See Action Module) as inputs for either the entity hover or the text selection behaviors shown above.  For example:  &lt;sq-preview [id]=&quot;id&quot;&gt; &lt;sq-preview-tooltip [textActions]=&quot;tooltipTextActions&quot;&gt; &lt;/sq-preview-tooltip&gt; &lt;/sq-preview&gt;   And:  this.tooltipTextActions = [new Action({ text: &quot;Search&quot;, icon: &quot;fas fa-search&quot;, action: (action, event) =&gt; { ... } })];   ","version":"Next","tagName":"h3"},{"title":"Preview Mini Map​","type":1,"pageTitle":"Preview Module","url":"/dokku/docs/libraries/components/preview#preview-mini-map","content":" The component sq-preview-minimap could be inserted within the HTML Preview to display a highlights's minimap.  highlights mini map  The minimap is inserted by transclusion:  &lt;sq-preview [id]=&quot;id&quot;&gt; &lt;!-- minimap injected in the preview --&gt; &lt;sq-preview-minimap&gt;&lt;/sq-preview-minimap&gt; &lt;/sq-preview&gt;   ","version":"Next","tagName":"h3"},{"title":"Extract Panel​","type":1,"pageTitle":"Preview Module","url":"/dokku/docs/libraries/components/preview#extract-panel","content":" The sq-preview-extracts-panel component displays the relevant extracts extracted from the PreviewDocument. Clicking on a extract selects it in the preview (highlight and scroll).    The component requires the inputs previewData and preview. You may want to also provide highlights to apply some.  &lt;sq-preview-extracts-panel [previewData]=&quot;previewData&quot; [preview]=&quot;preview&quot; [extractsNumber]=&quot;10&quot; [highlights]=&quot;previewHighlights&quot;&gt; &lt;/sq-preview-extracts-panel&gt;   This component is used in Vanilla Search's Preview component.  ","version":"Next","tagName":"h3"},{"title":"Entity Panel​","type":1,"pageTitle":"Preview Module","url":"/dokku/docs/libraries/components/preview#entity-panel","content":" The sq-preview-entity-panel component displays the lists of entities and matches in the document. The data is available in the PreviewData object. The facets displaying each type of highlight allow the user to navigate between the different occurrences and turn them on or off.    The component requires the inputs previewData and preview. You may want to also provide highlights to apply some.  &lt;sq-preview-entity-panel [previewData]=&quot;previewData&quot; [preview]=&quot;preview&quot; [highlights]=&quot;previewHighlights&quot;&gt; &lt;/sq-preview-entity-panel&gt;   This component is used in Vanilla Search's Preview component.  ","version":"Next","tagName":"h3"},{"title":"Search Form​","type":1,"pageTitle":"Preview Module","url":"/dokku/docs/libraries/components/preview#search-form","content":" The sq-preview-search-form component is a simple search form that lets users search for content within the preview.  The search is actually triggered by navigating to the same URL but updating the query.text field. ⚠️ This assumes the component lives inside a &quot;Preview&quot; route which listens to URL changes and updates the PreviewData via the PreviewService accordingly.   ","version":"Next","tagName":"h3"},{"title":"Result Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/components/result","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Result Module","url":"/dokku/docs/libraries/components/result#features","content":" This module provides simple components to easily display the different fields of a document/result/record (object of type Record).  These components do not depend on a styling framework like Bootstrap, nor on a global stylesheet.    ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Result Module","url":"/dokku/docs/libraries/components/result#import","content":" Import this module in your app.module.ts.  import { ResultModule } from '@sinequa/components/result'; @NgModule({ imports: [ ... ResultModule   This module is internationalized: If not already the case, you need to import its messages for the language(s) of your application. For example, in your app's src/locales/en.ts:  ... import {enResult} from &quot;@sinequa/components/result&quot;; const messages = Utils.merge({}, ..., enResult, appMessages);   ","version":"Next","tagName":"h2"},{"title":"Components​","type":1,"pageTitle":"Result Module","url":"/dokku/docs/libraries/components/result#components","content":" ","version":"Next","tagName":"h2"},{"title":"Title​","type":1,"pageTitle":"Result Module","url":"/dokku/docs/libraries/components/result#title","content":" The sq-result-title component displays the title of a document. More precisely, it displays the record.displayTitle (formatted value) or record.title (raw value), or a custom field (field input).    When the title is clicked, various behaviour are possible (titleLinkBehavior field):  'open' (default): The title is a regular link pointing at record.url1 if it exists (the titleClicked event fires for information and an audit event is emitted).'action': the title is a link pointing at no URL, the action is custom and must be performed by the parent via the titleClicked event.  ","version":"Next","tagName":"h3"},{"title":"Source​","type":1,"pageTitle":"Result Module","url":"/dokku/docs/libraries/components/result#source","content":" The sq-result-source component displays the treepath (record.treepath) and URL (record.url1) of a document.    ","version":"Next","tagName":"h3"},{"title":"Extracts​","type":1,"pageTitle":"Result Module","url":"/dokku/docs/libraries/components/result#extracts","content":" The sq-result-extracts component displays the relevant extracts of a document in a summarized form (record.relevantExtracts) or raw form (record.extracts). It can also display the record.text if that field is configured in the Query web service. It also displays the modified date of a document (record.modified).    ","version":"Next","tagName":"h3"},{"title":"Thumbnail​","type":1,"pageTitle":"Result Module","url":"/dokku/docs/libraries/components/result#thumbnail","content":" The sq-result-thumbnail component displays the thumbnail of a document, if it exists. The behavior of a thumbnail click is similar to the title component.    ","version":"Next","tagName":"h3"},{"title":"Icon​","type":1,"pageTitle":"Result Module","url":"/dokku/docs/libraries/components/result#icon","content":" The sq-result-icon component displays the icon of a document, defined by its file extension (record.fileExt). This component simply inserts a &lt;span&gt; element with a class name including the file extension.  The extensions are mapped with icons and colors in the TypeScript. A default mapping of file extension (string) to an icon and color (IconFormat) is defined in the component.  Custom icons can be provided via the formatIcons input from the component which you can use to both override the ones defined by default, and to add some extensions that may not be in that list. For example:  const formatIcons: Record&lt;string, IconFormat&gt; = { &quot;html&quot;: { icon: &quot;fas fa-browser&quot;, color: 'purple' }, &quot;abcd&quot;: { icon: &quot;fas fa-users&quot;, color: '#123456' } }   Vanilla Search allows overriding the mappings using the app configuration on the server (as for the facets, metadata, etc.) or it could be also defined in config.ts.    ","version":"Next","tagName":"h3"},{"title":"Missing terms​","type":1,"pageTitle":"Result Module","url":"/dokku/docs/libraries/components/result#missing-terms","content":" The sq-missing-terms component displays the list of terms in the user's query that are not found in the document.    ","version":"Next","tagName":"h3"},{"title":"Sponsored Results​","type":1,"pageTitle":"Result Module","url":"/dokku/docs/libraries/components/result#sponsored-results","content":" The sq-sponsored-results component displays the sponsored links relevant for a user query (using the SponsoredLinksWebService). The configuration of these links must be done in the Sinequa administration.    &lt;sq-sponsored-results [query]=&quot;searchService.query&quot;&gt;&lt;/sq-sponsored-results&gt;   Note that, in the background, the SponsoredLinksWebService makes a call to the query.links API endpoint, every time the query text is modified (which does not include clicks on facets for example).  The configuration of the links is done as depicted below in the Sinequa administration. Notice the bottom-right buttons to edit the properties of each link (including their thumbnail). See the general documentation about Sponsored Links.    ","version":"Next","tagName":"h3"},{"title":"User ratings​","type":1,"pageTitle":"Result Module","url":"/dokku/docs/libraries/components/result#user-ratings","content":" The sq-user-rating component displays the rating of a given document in the form of a number of stars. Users can assign a rating to a document by clicking on a star: This stores each user's rating (as a number) in the engine metadata store, and additionally it computes the average rating from all users (which is stored in a different column).    Note that the column names are case sensitive (should always be lower case), and aliases are not supported.  In the background, the component uses the UserRatingsWebService to update the engine metadata store. This web service has no configuration on the backend (at the moment). This is why it is required to pass the index column names to the component directly.  As a pre-requisite, an Engine Metadata store must exist on the backend, and the engine* columns must have been created. Note that the ratingsColumn should normally be an engineusercsv column, since it needs to store the rating for each user. Whereas the averageColumn should be an enginecsv column to store the average for all users (See Implementing the Engine Metadata).  ⚠️ Note that inserting user ratings in your SBA has no direct effect on the relevance computed by the engine. To influence the relevance (= the ranking of results), you must configure your Query web service to boost or penalize rated documents:    The sq-user-rating component supports additional optional parameters:  values: By default, the rating values stored in the index are digits from 1 to count, but it is possible to instead store strings provided in this values input. For example: terrible;poor;average;good;perfect.titles: Similar to values, this input allows to define the tooltip texts displayed when hovering over the stars.caption: A caption for the ratings, displayed before the stars.showAverage: A boolean to display or not the average rating from all users (after the stars).  ","version":"Next","tagName":"h3"},{"title":"Duplicate documents​","type":1,"pageTitle":"Result Module","url":"/dokku/docs/libraries/components/result#duplicate-documents","content":" This module includes 3 components to manage duplicate documents:  Exact duplicates are the documents excluded from the results list by the engine, using a &quot;group by&quot; clause. This deduplication is generally based on the exacthash or nearhash columns. By definition, exact duplicates are not returned by the WebApp and therefore NOT displayed in the result list. Near (or approximate) duplicates are determined by a developer-supplied function (in the SearchOptions) that compares two documents and returns a boolean. By definition, near duplicates are returned by the WebApp and present in the result list (only their appearance is modified). The order of the results list is not modified and a near duplicate always follows either its &quot;parent&quot; document or another near duplicate.  sq-result-duplicates displays the number of exact and near duplicates of a document.  sq-result-duplicates-spacer: A component that visually differentiates near duplicates in a results list.    sq-result-duplicates-list: Retrieves and displays the list of exact duplicates for a given document.  &lt;sq-result-duplicates-list [record]=&quot;record&quot;&gt;&lt;/sq-result-duplicates-list&gt;  ","version":"Next","tagName":"h3"},{"title":"Search Form Component","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/components/search-form","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Search Form Component","url":"/dokku/docs/libraries/components/search-form#features","content":" This standalone component offers an input with a dropdown and many options such as the voice recognition and a Neural Search toggle.  Search Form Component in Vanilla Search  ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Search Form Component","url":"/dokku/docs/libraries/components/search-form#import","content":" import { SearchFormComponent } from &quot;@sinequa/components/search-form&quot;; @NgModule({ imports: [ /*....*/ SearchFormComponent, /*....*/ ], /*....*/ })   This component is internationalized: If not already the case, you need to import its messages for the language(s) of your application. For example, in your app's src/locales/en.ts:  ... import {enSearchForm} from &quot;@sinequa/components/search-form&quot;; const messages = Utils.merge({}, ..., enSearchForm, appMessages);   ","version":"Next","tagName":"h2"},{"title":"API usage​","type":1,"pageTitle":"Search Form Component","url":"/dokku/docs/libraries/components/search-form#api-usage","content":" The SearchFormComponent can be used with the sq-search-form selector which expects these inputs:  Required parameters:  query: The search query.  Optional parameters:  searchRoute (default: search): The route provided to the SearchService to navigate to after a search.autoApply (default: true): Whether a filter change is to be applied automatically.autoSubmit (default: true): Whether hitting enter performs a submit.showFilterCount (default: false): Whether the filters count should be displayed.enableVoiceRecognition (default: true): Whether the voice recognition button should be displayed (the service will also require to be available). When clicking on the linked button, it triggers the voice recognition.enableNeuralSearch (default: true): Whether the Neural Search button should be displayed (Neural Search should also be enabled in the query). When clicking on the linked button, it toggles Neural Search on or off for the performed search.neuralSearchPref (default: neural-search): The name of the Neural Search preference to fetch and update in UserPreferences.  The component also emits two events:  search: When a search has been performed. It contains a boolean on whether the text has changed compared to the input query.expanded: When the dropdown is being expanded or collapsed. It returns in a boolean value whether it is expanded or not.  Additionally, the component also requires you to provide a template for the dropdown as displayed on the example just below, or in the Autocomplete tutorial.  ","version":"Next","tagName":"h2"},{"title":"Examples​","type":1,"pageTitle":"Search Form Component","url":"/dokku/docs/libraries/components/search-form#examples","content":"   A more complex example could be what Pepper does which includes an sq-filters-view to allow adding filters to the query, then an sq-facet-container to display the filters when we select a category, and finally the app-autocomplete (taken from Vanilla Search) to display the suggestions.  &lt;sq-search-form #searchForm [query]=&quot;searchService.query&quot; [showFilterCount]=&quot;true&quot; [autoSubmit]=&quot;false&quot;&gt; &lt;ng-template let-query&gt; &lt;div class=&quot;search-dropdown border-top m-2&quot;&gt; &lt;div class=&quot;small fw-bold mb-1&quot; *ngIf=&quot;query?.filters&quot;&gt; {{'msg#searchForm.currentFilters' | sqMessage}} &lt;/div&gt; &lt;sq-filters-view [query]=&quot;query&quot; (filterEdit)=&quot;onFiltersChange()&quot;&gt; &lt;/sq-filters-view&gt; &lt;hr *ngIf=&quot;query?.filters &amp;&amp; facets?.length&quot;/&gt; &lt;sq-facet-container *ngIf=&quot;facets?.length&quot; [results]=&quot;searchService.results&quot; [query]=&quot;query&quot; [facetConfigs]=&quot;facets&quot; [facetComponents]=&quot;facetComponents&quot;&gt; &lt;/sq-facet-container&gt; &lt;hr *ngIf=&quot;query.text&quot; /&gt; &lt;app-autocomplete [inputElement]=&quot;searchForm.searchInput.nativeElement&quot; [queryText]=&quot;query.text || ''&quot; [suggestTypes]=&quot;autocompleteSources&quot; (search)=&quot;onAutocompleteSearch($event, query)&quot; (select)=&quot;onAutocompleteSelect($event, query)&quot;&gt; &lt;/app-autocomplete&gt; &lt;/div&gt; &lt;/ng-template&gt; &lt;/sq-search-form&gt;   Pepper's Search Form  Upon selecting a filter category ","version":"Next","tagName":"h2"},{"title":"Search Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/components/search","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Search Module","url":"/dokku/docs/libraries/components/search#features","content":" This modules provides:  SearchService: A central service to manage search queries and results, and their life cycles. This service is used by many other modules to modify the search query and get results globally.A list of components to control the search query (Query). These components are styled with the Bootstrap library, and their class names start with Bs.  ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Search Module","url":"/dokku/docs/libraries/components/search#import","content":" Import this module in your app.module.ts and pass the list of routes where you need the Search service to be active, as well as other optional parameters (See SearchOptions).  import { BsSearchModule } from '@sinequa/components/search'; @NgModule({ imports: [ ... BsSearchModule.forRoot({ routes: [&quot;search&quot;, &quot;search2&quot;], homeRoute: &quot;home&quot; })   This module is internationalized: If not already the case, you need to import its messages for the language(s) of your application. For example, in your app's src/locales/en.ts:  ... import {enSearch} from &quot;@sinequa/components/search&quot;; const messages = Utils.merge({}, ..., enSearch, appMessages);   ","version":"Next","tagName":"h2"},{"title":"Search Service​","type":1,"pageTitle":"Search Module","url":"/dokku/docs/libraries/components/search#search-service","content":" ","version":"Next","tagName":"h2"},{"title":"Overview​","type":1,"pageTitle":"Search Module","url":"/dokku/docs/libraries/components/search#overview","content":" The SearchService provides an opinionated way to manage the lifecycle of Sinequa search queries and their results. It has a query property which determines the Query that will be used when executing any of the service's search methods. When you access the query property a new Query is created if one does not already exist. The query name used is taken from the current ccquery held on the AppService. This determines the query web service used on the server when executing the query.  After a query has been executed its Results are stored in the results property.  As you work with the Search Service it issues a number of events (new-query, new-results, ...) on the events property that can be listened to by other services and components. In addition, there is the resultsStream behavior subject that is convenient to use in components when displaying results:  &lt;ng-container *ngIf=&quot;searchService.resultsStream | async; let results&quot;&gt; &lt;my-results-component [results]=&quot;results&quot;&gt;&lt;/my-results-component&gt; &lt;/ng-container&gt;   ","version":"Next","tagName":"h3"},{"title":"Usage​","type":1,"pageTitle":"Search Module","url":"/dokku/docs/libraries/components/search#usage","content":" Initial fulltext search:  // Clear the current query, if any this.searchService.clearQuery(); // Set the text on the query (a new query is created by the query getter) this.searchService.query.text = 'some fulltext'; // Initiate the search this.searchService.search();   Faceted search:  // Add the filter this.searchService.query.addSelect('authors:proust', 'Authors'); // Initiate the search this.searchService.search();   Did you mean:  this.searchService.didYouMean('corrected text', DidYouMeanKind.Original);   Pagination:  this.searchService.gotoPage(3);   Tab selection:  this.searchService.selectTab('mytab');   ","version":"Next","tagName":"h3"},{"title":"Routing​","type":1,"pageTitle":"Search Module","url":"/dokku/docs/libraries/components/search#routing","content":" By default, the Search Service works with the Angular router. A search issued by the service updates the query query string parameter and uses the router to navigate to the new URL. The query is actually executed on completion of the navigation which lets the service react to external navigations too. The routes for which the service is active are defined in the SearchOptions specified when importing the SearchModule. If no SearchOptions are specified then default options are created with the routes array set to ['search']. Urls with routes that include the current query can be shared with other users. When they click on the URL the associated query will automatically be executed (in the context of that user).  Owing to this interaction with the router, navigate is the fundamental method for executing queries with the SearchService. The most common method used is search which resets the currently selected page and &quot;did-you-mean&quot; status before calling navigate. The methods which call navigate aresearch, gotoPage and didYouMean. The search method is called by searchText, selectBreadcrumbsItem, searchRefine and selectTab. These methods send auditing information with the queries.  The SearchService.home method clears the current query and navigates to the homeRoute defined on the SearchOptions unless an explicit route is passed. If no route is specified and the homeRoute is empty then navigation remains in the context of the current route.  It is possible to deactivate routing in the SearchService using SearchOptions:  NgModule({ imports: [ SearchModule.forRoot({deactivateRouting: true}) ] })   The search methods will all still work but they will execute the queries immediately rather than passing via the router.  ","version":"Next","tagName":"h3"},{"title":"Components​","type":1,"pageTitle":"Search Module","url":"/dokku/docs/libraries/components/search#components","content":" ","version":"Next","tagName":"h2"},{"title":"Tabs​","type":1,"pageTitle":"Search Module","url":"/dokku/docs/libraries/components/search#tabs","content":" The sq-tabs component allows to control the query.tab parameter. When clicking on a tab, this parameter is set and a new search is triggered.  This components requires at least a Results input to work properly.    ","version":"Next","tagName":"h3"},{"title":"Did you mean​","type":1,"pageTitle":"Search Module","url":"/dokku/docs/libraries/components/search#did-you-mean","content":" The sq-did-you-mean component displays the syntaxic or phonetic corrections of the user's search query. These corrections are sent by the server via the Results.didYouMean object.  This components requires at least a Results input to work properly.    ","version":"Next","tagName":"h3"},{"title":"Page Size Selector​","type":1,"pageTitle":"Search Module","url":"/dokku/docs/libraries/components/search#page-size-selector","content":" The sq-page-size-selector component displays a button allowing the user to select the number of results per page from a dropdown menu (query.pageSize parameter). The component is based on the Action module.  This components requires at least a Results input to work properly.    ","version":"Next","tagName":"h3"},{"title":"Sort selector​","type":1,"pageTitle":"Search Module","url":"/dokku/docs/libraries/components/search#sort-selector","content":" The sq-sort-selector component displays a button that allows the user to select the sorting criteria (by relevance, by date, etc.). It controls the query.orderBy parameter (the different values can be configured server-side in the Query web service). The component is based on the Action module.    This components requires at least a Results input to work properly.  &lt;sq-sort-selector [results]=&quot;results&quot;&gt;&lt;/sq-sort-selector&gt;   ","version":"Next","tagName":"h3"},{"title":"Pager​","type":1,"pageTitle":"Search Module","url":"/dokku/docs/libraries/components/search#pager","content":" The sq-pager component displays a list of buttons allowing the user to navigate between the different pages of documents in the results. It controls the query.page parameter.    This components requires at least a Results input to work properly.  &lt;sq-pager [results]=&quot;results&quot;&gt;&lt;/sq-pager&gt;   ","version":"Next","tagName":"h3"},{"title":"Loading bar​","type":1,"pageTitle":"Search Module","url":"/dokku/docs/libraries/components/search#loading-bar","content":" The sq-loading-bar component displays a indeterminate loading bar when the search is active (the SearchService expects results from the server). The component uses the SearchService.searchActive property and requires no mandatory input.    ","version":"Next","tagName":"h3"},{"title":"Load More Button​","type":1,"pageTitle":"Search Module","url":"/dokku/docs/libraries/components/search#load-more-button","content":" The sq-load-more component display a simple button allowing user to fetch next results.  Results comes from SearchService.resultsStream and requires no mandatory input.  &lt;sq-load-more&gt;&lt;/sq-load-more&gt;   ","version":"Next","tagName":"h3"},{"title":"Lazy-loading results while scrolling down​","type":1,"pageTitle":"Search Module","url":"/dokku/docs/libraries/components/search#lazy-loading-results-while-scrolling-down","content":" The sq-scroller component allow continuously loading results as the user scrolls down the page.  Results comes from SearchService.resultsStream and requires no mandatory input.  We are using the Observer API to do this.  &lt;sq-scroller&gt;&lt;/sq-scroller&gt;   ","version":"Next","tagName":"h3"},{"title":"Scope selector​","type":1,"pageTitle":"Search Module","url":"/dokku/docs/libraries/components/search#scope-selector","content":" The sq-scope component allows users to select a subset of sources, much like the tabs but with additional flexibility for defining the WHERE-clause returning the documents.  The scope configuration is defined in the query web service (Result Page tab):      The scope selector is typically displayed in the search bar, although this is not an obligation.    Selecting a scope updates the Query object, without triggering a new search (if this behavior is required, it is possible to trigger a new search by listening to the (queryChange) event emited by this component).  A complete implementation could look like this:  &lt;sq-scope *ngIf=&quot;appService.ccquery?.scopesActive&quot; [query]=&quot;searchService.query&quot; (queryChange)=&quot;searchService.search()&quot;&gt; &lt;/sq-scope&gt;   (Note that, unlike with the tabs, the query web service does not support counting the number of elements in each scope for a given query. Therefore, scopes could be displayed in the form of tabs, but without tab counters.) ","version":"Next","tagName":"h3"},{"title":"Selection Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/components/selection","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Selection Module","url":"/dokku/docs/libraries/components/selection#features","content":" This module provides a transverse service that keeps track of selected documents and records. Documents may typically be selected by a click on a button or a checkbox. Selecting documents allows other services to operate over these documents (for example, adding selected documents to a basket, or setting a label or tag onto these documents).  The module also provides components based on this service. These components allow to select one or multiple documents, and to rearrange a given selection (changing its order, removing items).  ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Selection Module","url":"/dokku/docs/libraries/components/selection#import","content":" import { BsSelectionModule, SelectionOptions, SELECTION_OPTIONS } from '@sinequa/components/selection'; /* These options override the default settings */ export const mySelectionOptions: SelectionOptions = { resetOnNewQuery: false, resetOnNewResults: false, storage: &quot;record&quot; }; @NgModule({ imports: [ /*....*/ BsSelectionModule, /*....*/ ], providers: [ /* If you want to the default options of the selection module */ { provide: SELECTION_OPTIONS, useValue: mySelectionOptions }, /*....*/ ], /*....*/ })   This module is internationalized: If not already the case, you need to import its messages for the language(s) of your application. For example, in your app's src/locales/en.ts:  ... import {enSelection} from &quot;@sinequa/components/selection&quot;; const messages = Utils.merge({}, ..., enSelection, appMessages);   ","version":"Next","tagName":"h2"},{"title":"API usage​","type":1,"pageTitle":"Selection Module","url":"/dokku/docs/libraries/components/selection#api-usage","content":" ","version":"Next","tagName":"h2"},{"title":"Selection Service​","type":1,"pageTitle":"Selection Module","url":"/dokku/docs/libraries/components/selection#selection-service","content":" The SelectionService offers a transverse solution to keep track of selected documents. Components use this service both to modify the selection (select or unselect documents), and to access this selection and be notified of its changes (via events).  Like any other service, it can be injected into components and other service by dependency injection:  import { SelectionService } from &quot;@sinequa/components/selection&quot;; @Component({ selector: &quot;my-component&quot;, templateUrl: &quot;...&quot; }) export class MyComponent { constructor( public selectionService: SelectionService ){}   The following methods of the service are of interest:  getSelectedItems(): returns the list of selected items (SelectionItem). A selected item contains at least the id property of the associated Record object. But it may contain more: If the module's SelectionOptions specifies storage: &quot;record&quot; (instead of &quot;id&quot;), then the selection item is the record itself. The storage property may also be a function that maps a record to a custom object (which must contain at least the record's id). ⚠️ The list returned by this method is a copy of the list maintained by this service. Therefore modifying this list will have no effect on the selection. To add, remove or reorder items, one must use the appropriate methods listed below. getSelectedIds(): returns the list of ids (as string) of the selected items. This method always work in the same way regardless of the SelectionOptions (it should therefore be preferred when possible, to implement new functionality based on this service). haveSelectedRecords: is true if there are selected records. getSelectedCount(): returns the number of selected items. allRecordsSelected: is true if all records in the search service results are selected. toggleSelectedRecords(record?: Record, source?: string): This method allows to add or remove records to/from the selection. It takes two optional arguments: record: a specific record to add or remove to/from the selection. If this parameter is omitted or undefined, all the records in the search service's results or added or removed (they are all removed only if they were all selected). source: an identifier for the type of source which causes the selection change. The source will be included in the events emitted by the service, and it can be used by client services if they listen to these events. This method generates a SELECT or UNSELECT event. moveSelectedRecord(record: Record, newIndex: number): Moves a selected record to a different index. The input record must be already in the selection. This method generates a MOVE event. clearSelectedRecords(): Unselect all selected records. This method generates an UNSELECT event.  Additionally, the service includes the following properties:  events: a Subject emitting events of three types: SELECT, UNSELECT and MOVE, when the selection changes. These events (SelectionEvent) include the list of records concerned by the event, as well as the (optional) source of the event. selectionActions: a list of Action (See Action module) that can be registered by other services. These actions are automatically updated when the selection changes. The actions are displayed by the sq-results-selector component For example, the Baskets service can register an action to add the selected documents to a basket. If the action includes an update method, it can, for example, hide itself if there is no selected document. These actions can be registered within a service or a component, typically at the start of the application. For example, in Vanilla Search, the actions are registered in the AppComponent's constructor: this.selectionService.selectionActions.push(this.savedQueriesService.selectedRecordsAction); this.selectionService.selectionActions.push(this.basketsService.selectedRecordsAction); ...   ","version":"Next","tagName":"h3"},{"title":"Result Selector​","type":1,"pageTitle":"Selection Module","url":"/dokku/docs/libraries/components/selection#result-selector","content":" The sq-result-selector component displays a simple checkbox associated to a record (Record).  It is typically meant to be displayed in a list of results for each record.  &lt;sq-result-selector [record]=&quot;record&quot;&gt;&lt;/sq-result-selector&gt;     ","version":"Next","tagName":"h3"},{"title":"Results Selector​","type":1,"pageTitle":"Selection Module","url":"/dokku/docs/libraries/components/selection#results-selector","content":" Not to be confused with the previous component, the sq-results-selector displays a global list of actions including:  The selectionActions from the SelectionService (mentioned above).An action allowing to toggle the selection of all results in the search service's results. This action displays a checkbox and the number of selected documents.  Options are available to customize the actions' display:  rightAligned (boolean): whether the actions are aligned to the right.style (string): A Bootstrap class name to change the style of the action buttons (Typically, light, dark, primary, etc.).size (string): A Bootstrap size modifier (small: sm, large: lg).  &lt;sq-results-selector [rightAligned]=&quot;true&quot; [style]=&quot;'light&quot;&gt;&lt;/sq-results-selector&gt;     ","version":"Next","tagName":"h3"},{"title":"Selection arranger​","type":1,"pageTitle":"Selection Module","url":"/dokku/docs/libraries/components/selection#selection-arranger","content":" The sq-selection-arranger component displays the list of selected components (using a template passed by transclusion). It allows to rearrange the selected items by changing their order (with drag &amp; drop) or removing them.  The component directly modifies the selection via the SelectionService, using the methods described above.  &lt;sq-selection-arranger&gt; &lt;!-- Template passed by transclusion --&gt; &lt;ng-template let-record&gt; &lt;div class=&quot;p-2&quot;&gt;{{record.title}}&lt;/div&gt; &lt;/ng-template&gt; &lt;/sq-selection-arranger&gt;     This component makes use of the DragDropModule from @angular/cdk.  It is also posible to display and rearrange a list of record which is not tied to the SelectionService. To do so, simply bind the records input, and listen to selection changes via the (changes) event emitter:  &lt;sq-selection-arranger [records]=&quot;results.record&quot; (changes)=&quot;onChanges($event)&quot;&gt; &lt;!-- Template passed by transclusion --&gt; &lt;ng-template let-record&gt; &lt;div class=&quot;p-2&quot;&gt;{{record.title}}&lt;/div&gt; &lt;/ng-template&gt; &lt;/sq-selection-arranger&gt;  ","version":"Next","tagName":"h3"},{"title":"Slide Builder Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/components/slide-builder","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Slide Builder Module","url":"/dokku/docs/libraries/components/slide-builder#features","content":" This module provides components for displaying, rearranging and exporting Powerpoint slides.    Users can select slides from the results list to add them to their presentation. Rearranging the slide order is simply done by drag and drop. Finally, a button allows to produce a Powerpoint file from the list of slides.  ","version":"Next","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Slide Builder Module","url":"/dokku/docs/libraries/components/slide-builder#prerequisites","content":" ⚠️⚠️⚠️ NOTE: This module requires a web service available as of Sinequa 11.7.0. ⚠️⚠️⚠️  ","version":"Next","tagName":"h2"},{"title":"Server-side configuration​","type":1,"pageTitle":"Slide Builder Module","url":"/dokku/docs/libraries/components/slide-builder#server-side-configuration","content":" Before slide builder can be implemented on the front-end, the server-side configuration requires the following:  Conversion Plan &amp; Converter: integral part to splitting the individual PowerPoint slides.Collection: requires included extensions and the appropriate conversion plan.Query Web Service: requires a specific tab configuration that displays the slide builder.  ","version":"Next","tagName":"h2"},{"title":"Conversion Plan & Converter​","type":1,"pageTitle":"Slide Builder Module","url":"/dokku/docs/libraries/components/slide-builder#conversion-plan--converter","content":" In order to implement slide builder, a collection requires storing PowerPoint documents locally. Thus, we must ensure the conversion plan satisfies the following criteria:  Conversion Plan: Store Original --enabled for PowerPoint extensions. Converter: Converters splitting the documents  ","version":"Next","tagName":"h3"},{"title":"Collection​","type":1,"pageTitle":"Slide Builder Module","url":"/dokku/docs/libraries/components/slide-builder#collection","content":" All slide builder collections should be stored in a centralized source and index. No other type of records should be stored.  There are two ways to configure a collection to index slides:  Creating a collection only indexing PowerPoint documents When creating a collection specifically for the slide builder module, the collection should only index PowerPoint extensions. ⚠️ The conversion plan previously configured should be attached to this collection. Creating a HyperIndex collection targetting an exisiting index containing other extensions Some collections may already contain preexisting data. To avoid repetition creating a collection from scratch and reindexing data on a seperate collection, ensure that the preexisting collections satisfies the conversion plan configuration. It is required to reindex the preexisting data if the conversion plan was not configured previously.By creating a HyperIndex connector, the targeted index (that contains various types of documents) will be filtered to index only PowerPoint extensions.  ","version":"Next","tagName":"h3"},{"title":"Query Web Service​","type":1,"pageTitle":"Slide Builder Module","url":"/dokku/docs/libraries/components/slide-builder#query-web-service","content":" The query web service must be configured to provide the slides in a context where we want to display the slide builder. One way to achieve this is to create a dedicated tab.  For example, we can configure tab search based on the docformat or treepath column and use index inclusions/exclusions to return the right content in our dedicated &quot;slides&quot; tab.      Note that the slides index is excluded from the &quot;all&quot; tab, to avoid displaying individual slides in that context.  ","version":"Next","tagName":"h3"},{"title":"SBA integration​","type":1,"pageTitle":"Slide Builder Module","url":"/dokku/docs/libraries/components/slide-builder#sba-integration","content":" ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Slide Builder Module","url":"/dokku/docs/libraries/components/slide-builder#import","content":" Add SlideBuilderModule to your Angular imports in app.module.ts:  import { SlideBuilderModule } from &quot;@sinequa/components/slide-builder&quot;; /*....*/ @NgModule({ imports: [ /*....*/ SlideBuilderModule, /*....*/ ], /*....*/ })   This module is internationalized: If not already the case, you need to import its messages for the language(s) of your application. For example, in your app's src/locales/en.ts:  ... import {enSlideBuilder} from &quot;@sinequa/components/slide-builder&quot;; const messages = Utils.merge({}, ..., enSlideBuilder, appMessages);   ","version":"Next","tagName":"h3"},{"title":"Slide Builder component​","type":1,"pageTitle":"Slide Builder Module","url":"/dokku/docs/libraries/components/slide-builder#slide-builder-component","content":" The sq-slide-builder component displays a list of selected slides. The component actually uses the SelectionService from the Selection Module as a data model for the selected slides. The Drag &amp; Drop capability is actually directly based on the sq-selection-arranger component.    This component is designed to be embedded in a facet card:  &lt;sq-facet-card *ngIf=&quot;results.tab === 'slides'&quot; [collapsible]=&quot;false&quot; icon=&quot;far fa-file-powerpoint&quot; title=&quot;Slide Deck Builder&quot; tooltip=&quot;Click on a slide from the search results to add it to the Slide Deck Builder.&quot; class=&quot;d-block mb-3 facet-preview&quot;&gt; &lt;sq-slide-builder #facet&gt;&lt;/sq-slide-builder&gt; &lt;/sq-facet-card&gt;   When at least one slide is selected, the action buttons are displayed in the facet header. They let users export the presentation as a Powerpoint file, save it as a basket (or collection), or clear the current selection.  It is possible to deactivate the option to save as a basket by passing the input enableSaveAsBasket as false.  It is also possible to customize the display by passing a template by transclusion:  &lt;sq-slide-builder #facet&gt; &lt;ng-template let-record&gt; &lt;div&gt;This is the record: {{record.id}}&lt;/div&gt; &lt;ng-template&gt; &lt;/sq-slide-builder&gt;   ","version":"Next","tagName":"h3"},{"title":"Slide List component​","type":1,"pageTitle":"Slide Builder Module","url":"/dokku/docs/libraries/components/slide-builder#slide-list-component","content":" The sq-slide-list component displays a tiled view of PowerPoint slides:    The component requires a Results object as an input, and, of course, the component should be displayed only in a context where the records are individual slides. A good way to create such a context is to use tab, as shown below:  &lt;sq-slide-list [results]=&quot;results&quot; *ngIf=&quot;results.tab === 'slides'&quot;&gt; &lt;/sq-slide-list&gt;   The component has various optional inputs and outputs:  colClass (default: 'col-6'): A Bootstrap column class to determine the width of the slides. By default, 'col-6' gives 50% of the available width to each slide. 'col-12' would give 100% of the width, 'col-4', one-third, and so one. This parameter can be used to easily balance the density of the view and legibility of the slides.selectedRecord: A single Record that is considered &quot;selected&quot; by the user (for example, to display the preview). This affects only the display of that record and the keyboard-based navigation.recordSelect (output): An event triggered when the user uses keyboard-based navigation to go through the list of results.recordKeydown (output): An event triggered when the user uses a key while a record is selected via keyboard-based navigation. ","version":"Next","tagName":"h3"},{"title":"Sinequa Theme","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/components/theme","content":"","keywords":"","version":"Next"},{"title":"Previews​","type":1,"pageTitle":"Sinequa Theme","url":"/dokku/docs/libraries/components/theme#previews","content":" ","version":"Next","tagName":"h2"},{"title":"Homepage​","type":1,"pageTitle":"Sinequa Theme","url":"/dokku/docs/libraries/components/theme#homepage","content":" Without the theme:  With the theme:  ","version":"Next","tagName":"h3"},{"title":"Results page​","type":1,"pageTitle":"Sinequa Theme","url":"/dokku/docs/libraries/components/theme#results-page","content":" Without the theme:  With the theme:  ","version":"Next","tagName":"h3"},{"title":"Importing/removing the theme​","type":1,"pageTitle":"Sinequa Theme","url":"/dokku/docs/libraries/components/theme#importingremoving-the-theme","content":" In your app.scss, you have these lines:  // @import &quot;../../../components/theme/minimal&quot;; @import &quot;../../../components/theme/sinequa&quot;;   To import or remove the theme, you can switch of import between minimal (the very basic one) and sinequa (with the complete theme).  Note that both files include Bootstrap imports and come with an integrated Dark theme.  ","version":"Next","tagName":"h2"},{"title":"Architecture​","type":1,"pageTitle":"Sinequa Theme","url":"/dokku/docs/libraries/components/theme#architecture","content":" As mentioned at the beginning, all files are located inside @sinequa/components/theme. They are organized as follow:    The components are designed to be minimally styled, with the least styling to be usable with Bootstrap. They are also unopiniated with the most simple and neutral customization. This styling is available while using the minimal theme which only imports the basic files such as Bootstrap, Fontawesome and the minimum of files to have everything working.  Only the sinequa theme inserts opiniated customization. It is based on minimal and imports with it all variables along with the files inside components and sba.  ","version":"Next","tagName":"h2"},{"title":"Customization​","type":1,"pageTitle":"Sinequa Theme","url":"/dokku/docs/libraries/components/theme#customization","content":" ","version":"Next","tagName":"h2"},{"title":"How to customize​","type":1,"pageTitle":"Sinequa Theme","url":"/dokku/docs/libraries/components/theme#how-to-customize","content":" Sinequa Theme overrides Bootstrap components using Sass files. If you want to customize your application, do not overrides the Sinequa Theme files. Instead:  override Bootstrap components as Sinequa Theme does https://getbootstrap.com/docs/5.2/customize/overview/  OR  import our minimalist Bootstrap files and write your custom css rules @import &quot;@sinequa/components/theme/minimal&quot; contains Bootstrap importscontains recommended imports to work with SBA components  ","version":"Next","tagName":"h3"},{"title":"Dark mode​","type":1,"pageTitle":"Sinequa Theme","url":"/dokku/docs/libraries/components/theme#dark-mode","content":" If you test Vanilla Search, you may notice that a dark theme is available, and that you can dynamically switch between light and dark colors.  The CSS file (_dark.scss) is already included in the minimal and sinequa themes, so you won't need to import it if you use them.  To build this feature, the following steps are required:  In the case of Vanilla Search, the styles in dark.scss are all wrapped inside a body.dark { .. } rule, which means that to toggle the theme, we simply need to toggle the dark class on the &lt;body&gt; element: document.body.classList.toggle(&quot;dark&quot;); You can also test what the current theme is with: if(document.body.classList.contains(&quot;dark&quot;)) { ... } We need to persist the decision of the user when he chooses a theme. The localStorage of the browser is a convenient place to do so: localStorage.setItem('sinequa-theme', this.isDark()? 'dark' : 'normal'); We need to activate the theme right at the beginning of the app loading, to avoid a flickering effect. To do so, we bypass Angular and add the following script in our index.html: &lt;script&gt; let theme = localStorage.getItem('sinequa-theme'); if(theme &amp;&amp; theme === 'dark'){ document.body.classList.toggle('dark'); } &lt;/script&gt;   ","version":"Next","tagName":"h2"},{"title":"Examples​","type":1,"pageTitle":"Sinequa Theme","url":"/dokku/docs/libraries/components/theme#examples","content":" Updating a few variables​  You may just want to use the whole Sinequa theme but update some properties like colors or borders. Let's say we want to :  change the facet header backgroundadd a border to the facets and remove the border radiuschange the links color  You can have your app.scss like this in Vanilla Search:  // theme overrides $card-cap-bg: #ddffe4; // facet header background $card-border-width: .1rem; // facet border $card-border-radius: 0; // facet border radius // Sinequa global theme (contains Bootstrap imports) @import &quot;../../../components/theme/sinequa&quot;; // SBA components custom CSS overrides @import &quot;vanilla&quot;; // result title + result source color .sq-result-title, sq-result-source a { color: green; }   This will change this :    Into this:    Customize the files you want​  You may also not want the whole package from what sinequa offers. In that case, you can import minimal and then any other files you need.  A possibility would be to check at the sinequa content and pick what you need. Let's say you don't need the sba files, you can have your app.scss like this:  // the variables (needed in most components and sba files) @import &quot;../../../components/theme/colors&quot;; @import &quot;../../../components/theme/variables&quot;; // the minimal theme @import &quot;../../../components/theme/minimal&quot;; // the components files @import &quot;../../../components/theme/components/forms&quot;; @import &quot;../../../components/theme/components/buttons&quot;; @import &quot;../../../components/theme/components/dropdown&quot;; @import &quot;../../../components/theme/components/tabs&quot;; @import &quot;../../../components/theme/components/alerts&quot;; @import &quot;../../../components/theme/components/pagination&quot;; // SBA components custom CSS overrides @import &quot;vanilla&quot;;  ","version":"Next","tagName":"h3"},{"title":"Core library","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/core","content":"","keywords":"","version":"Next"},{"title":"Building the library​","type":1,"pageTitle":"Core library","url":"/dokku/docs/libraries/core#building-the-library","content":" At the root of the workspace, run the following command:  npm run buildcore   The build takes a few minutes to complete and produces a folder dist/core/. Note that this folder is aliased as @sinequa/core, in the tsconfig.json file. This means that all the imports of code of this library from the applications look like:  import { ... } from '@sinequa/core/....';   ","version":"Next","tagName":"h2"},{"title":"Modules​","type":1,"pageTitle":"Core library","url":"/dokku/docs/libraries/core#modules","content":" This library contains several sub-libraries (or &quot;secondary endpoints&quot;). Each sub-library generally includes:  One or more Angular modules. Generally, only one module is used. Zero or one Angular service. Services are where the intelligence of the application is concentrated. Here, top level interactions with Sinequa are maintained (calling the Sinequa REST API, authenticating users via standard protocols supported by Sinequa, etc.) Components generally use those services for the complex data processing tasks and the interactions. Some Angular components, directives and pipes exported by the Angular module, and tied together by the service. Internationalization &quot;messages&quot;, which are simple Typescript files exporting key/value pairs of text allowing to switch between various languages in your app (See Internationalization).  See the tutorial introduction for additional information on the modules' structure and how to get started with them.  Below is list of documented modules. ","version":"Next","tagName":"h2"},{"title":"User Settings Modules","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/components/user-settings","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"User Settings Modules","url":"/dokku/docs/libraries/components/user-settings#features","content":" There are currently five functionalities based on the User Settings. The table below summarizes the features available for each of them:  Functionality\tLibrary @sinequa/components\tService\tCRUD API\tEdit Modal\tManage Modal\tUser Menu\tFacetSaved Queries\t/saved-queries\tSavedQueriesService\t✓ ✓\t✓\t✓ Recent Queries\t/saved-queries\tRecentQueriesService\t✓ ✓ Recent Documents\t/saved-queries\tRecentDocumentsService\t✓ ✓ Baskets\t/baskets\tBasketsService\t✓\t✓\t✓\t✓\t✓ Alerts\t/alerts\tAlertsService\t✓\t✓\t✓\t✓\t  ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"User Settings Modules","url":"/dokku/docs/libraries/components/user-settings#import","content":" Import one or more module(s) in your app.module.ts.  import { BsSavedQueriesModule } from '@sinequa/components/saved-queries'; import { BsAlertsModule } from '@sinequa/components/alerts'; import { BsBasketsModule } from '@sinequa/components/baskets'; @NgModule({ imports: [ ... BsSavedQueriesModule, BsAlertsModule, BsBasketsModule   These modules are internationalized: If not already the case, you need to import their messages for the language(s) of your application. For example, in your app's src/locales/en.ts:  ... import {enAlerts} from &quot;@sinequa/components/alerts&quot;; import {enBaskets} from &quot;@sinequa/components/baskets&quot;; import {enSavedQueries} from &quot;@sinequa/components/saved-queries&quot;; const messages = Utils.merge({}, ..., enAlerts, enBaskets, enSavedQueries, appMessages);   ","version":"Next","tagName":"h2"},{"title":"Saved Queries​","type":1,"pageTitle":"User Settings Modules","url":"/dokku/docs/libraries/components/user-settings#saved-queries","content":" Saved Queries are a functionality that lets users save their current search criteria (which may include searched text, tabs and facets selections, etc.) to replay them later. These queries are given a name and can be displayed in a list (facet, or user menu).  ","version":"Next","tagName":"h2"},{"title":"User Menu​","type":1,"pageTitle":"User Settings Modules","url":"/dokku/docs/libraries/components/user-settings#user-menu","content":" The sq-saved-queries-menu component displays the list of saved queries, lets a user save his current query and allows to reorganize the list (See the Manage modal below).    This menu is meant to be inserted in a Bootstrap-styled navbar:  &lt;ul class=&quot;navbar-nav&quot;&gt; &lt;sq-saved-queries-menu&gt;&lt;/sq-saved-queries-menu&gt; &lt;!-- Other menus --&gt; &lt;/ul&gt;   ","version":"Next","tagName":"h3"},{"title":"Facet​","type":1,"pageTitle":"User Settings Modules","url":"/dokku/docs/libraries/components/user-settings#facet","content":" The sq-facet-saved-queries component displays the list of saved queries, lets a user re-play one of them, open the Manage modal (see below), or delete specific queries.    This facet is meant to work with the sq-facet-card component (See Facet Module):  &lt;sq-facet-card [title]=&quot;'msg#savedQueries.savedQueries'&quot; [tooltip]=&quot;'msg#home.savedQueriesTooltip'&quot; [icon]=&quot;'fas fa-save'&quot;&gt; &lt;sq-facet-saved-queries #facet [maxQueries]=&quot;5&quot;&gt;&lt;/sq-facet-saved-queries&gt; &lt;/sq-facet-card&gt;   The component accepts the following (optional) inputs:  searchRoute (default: '/search'): The route to navigate to when searching a query (clicked by the user).maxQueries (default: 5): The maximum number of queries to display (the rest is available with pagination).enableDelete (default: true): Whether to enable the deletion of queries in the facet.  ","version":"Next","tagName":"h3"},{"title":"Service & Modals​","type":1,"pageTitle":"User Settings Modules","url":"/dokku/docs/libraries/components/user-settings#service--modals","content":" The SavedQueriesService is the access point for the list of saved queries (SavedQueriesService.savedqueries), and it provides a list of public methods to create, read, update and delete this data (CRUD API).  Additional methods allow to display modal dialogs:  createSavedQueryModal() displays the sq-edit-saved-query modal component which prompts the user for a name (for the saved query)manageSavedQueriesModal() displays the sq-manage-saved-queries modal component which displays the list of queries and lets the user reorganize it (change the order, remove or rename elements)exportModal() displays the sq-export-query modal component which allows to export a saved query or a list of results.  Manage Modal component to reorder, rename or delete saved queries  ","version":"Next","tagName":"h3"},{"title":"Recent Queries​","type":1,"pageTitle":"User Settings Modules","url":"/dokku/docs/libraries/components/user-settings#recent-queries","content":" Recent Queries are a functionality that records the latest queries of the user in the User Settings. These queries can then be displayed (eg. in a facet), or used in other ways (eg. autocomplete).  ","version":"Next","tagName":"h2"},{"title":"Facet​","type":1,"pageTitle":"User Settings Modules","url":"/dokku/docs/libraries/components/user-settings#facet-1","content":" The sq-facet-recent-queries component displays the list of recent queries and lets a user re-play, delete or save one of them.    This facet is meant to work with the sq-facet-card component (See Facet Module):  &lt;sq-facet-card [title]=&quot;'msg#facet.recentQueries.title'&quot; [tooltip]=&quot;'msg#home.recentQueriesTooltip'&quot; [icon]=&quot;'fas fa-history'&quot;&gt; &lt;sq-facet-recent-queries #facet [maxQueries]=&quot;5&quot;&gt;&lt;/sq-facet-recent-queries&gt; &lt;/sq-facet-card&gt;   The component accepts the following (optional) inputs:  searchRoute (default: '/search'): The route to navigate to when searching a query (clicked by the user).maxQueries (default: 5): The maximum number of queries to display (the rest is available with pagination).enableDelete (default: true): Whether to enable the deletion of queries in the facet.enableSave (default: true): Whether to enable saving a recent query in the facet.  ","version":"Next","tagName":"h3"},{"title":"Service​","type":1,"pageTitle":"User Settings Modules","url":"/dokku/docs/libraries/components/user-settings#service","content":" The RecentQueriesService is the access point for the list of recent queries (RecentQueriesService.recentqueries), and it provides a list of public methods to create, read, update and delete this data (CRUD API).  ","version":"Next","tagName":"h3"},{"title":"Recent Documents​","type":1,"pageTitle":"User Settings Modules","url":"/dokku/docs/libraries/components/user-settings#recent-documents","content":" Recent Documents are a functionality that records the latest documents opened by the user in the User Settings. This list of documents can then be displayed (eg. in a facet), or used in other ways (eg. autocomplete).  ","version":"Next","tagName":"h2"},{"title":"Facet​","type":1,"pageTitle":"User Settings Modules","url":"/dokku/docs/libraries/components/user-settings#facet-2","content":" The sq-facet-recent-documents component displays the list of recent document and lets a user re-open one, or remove it from the list.    This facet is meant to work with the sq-facet-card component (See Facet Module):  &lt;sq-facet-card [title]=&quot;'msg#savedQueries.savedQueries'&quot; [tooltip]=&quot;'msg#home.savedQueriesTooltip'&quot; [icon]=&quot;'fas fa-save'&quot;&gt; &lt;sq-facet-recent-documents #facet [maxDocuments]=&quot;5&quot;&gt;&lt;/sq-facet-recent-documents&gt; &lt;/sq-facet-card&gt;   The component accepts the following (optional) inputs:  maxDocuments (default: 5): The maximum number of documents to display (the rest is available with pagination).enableDelete (default: true): Whether to enable the deletion of documents from the list.openOriginal (default: false): Whether to open the original document (record.url1) when clicked, or simply emit an event ((documentOpened) event emitter).  ","version":"Next","tagName":"h3"},{"title":"Service​","type":1,"pageTitle":"User Settings Modules","url":"/dokku/docs/libraries/components/user-settings#service-1","content":" The RecentDocumentsService is the access point for the list of recent documents (RecentDocumentsService.recentdocuments), and it provides a list of public methods to create, read, update and delete this data (CRUD API).  ","version":"Next","tagName":"h3"},{"title":"Alerts​","type":1,"pageTitle":"User Settings Modules","url":"/dokku/docs/libraries/components/user-settings#alerts","content":" Alerts are a functionality that lets a user schedule and subscribe to a search alert (which will regularly inform them of new relevant content). These alerts can then be displayed (eg. in a user menu), edited (Edit modal) and reorganized (Manage modal).  ","version":"Next","tagName":"h2"},{"title":"User Menu​","type":1,"pageTitle":"User Settings Modules","url":"/dokku/docs/libraries/components/user-settings#user-menu-1","content":" The sq-alerts-menu component displays the list of alerts, lets a user schedule an alert for the current query and allows to reorganize the list (See the Manage modal below).    This menu is meant to be inserted in a Bootstrap-styled navbar:  &lt;ul class=&quot;navbar-nav&quot;&gt; &lt;sq-alerts-menu&gt;&lt;/sq-alerts-menu&gt; &lt;!-- Other menus --&gt; &lt;/ul&gt;   ","version":"Next","tagName":"h3"},{"title":"Service & Modals​","type":1,"pageTitle":"User Settings Modules","url":"/dokku/docs/libraries/components/user-settings#service--modals-1","content":" The AlertsService is the access point for the list of alerts (AlertsService.Alerts), and it provides a list of public methods to create, read, update and delete this data (CRUD API).  Additional methods allow to display modal dialogs:  createAlertModal() displays the sq-edit-alert modal component which lets the user create and schedule an alert.editAlertModal() displays the sq-edit-alert modal component (same as above) which allows to edit the parameters of an existing alert.manageAlertsModal() displays the sq-manage-alerts modal component which displays the list of alerts and lets the user reorganize it (change the order, remove or rename elements). This component is similar to the sq-manage-saved-queries component.  Edit/Create Modal component for alerts  ","version":"Next","tagName":"h3"},{"title":"Baskets​","type":1,"pageTitle":"User Settings Modules","url":"/dokku/docs/libraries/components/user-settings#baskets","content":" Baskets (a.k.a Bookmarks or Collections) are a functionality that lets users store specific documents to retrieve them later. A basket is essentially a named list of document ids (the document is only referenced, not copied).  Note: in Vanilla Search, Baskets are actually renamed &quot;Collections&quot; (via internationalization).  ","version":"Next","tagName":"h2"},{"title":"User Menu​","type":1,"pageTitle":"User Settings Modules","url":"/dokku/docs/libraries/components/user-settings#user-menu-2","content":" The sq-baskets-menu component displays the list of baskets, lets a user create a new basket and reorganize the list (See the Manage modal below).  This menu is meant to be inserted in a Bootstrap-styled navbar.    ","version":"Next","tagName":"h3"},{"title":"Facet​","type":1,"pageTitle":"User Settings Modules","url":"/dokku/docs/libraries/components/user-settings#facet-3","content":" The sq-facet-baskets component displays the list of baskets, lets a user open one of them, create a new one, open the Manage modal (see below), and delete specific baskets.  This facet is meant to work with the sq-facet-card component (See Facet Module).    The component accepts the following (optional) inputs:  searchRoute (default: '/search'): The route to navigate to when opening a basket (clicked by the user).maxBaskets (default: 5): The maximum number of baskets to display (the rest is available with pagination).enableDelete (default: true): Whether to enable the deletion of baskets in the facet.  ","version":"Next","tagName":"h3"},{"title":"Service & Modals​","type":1,"pageTitle":"User Settings Modules","url":"/dokku/docs/libraries/components/user-settings#service--modals-2","content":" The BasketsService is the access point for the list of baskets (BasketsService.baskets), and it provides a list of public methods to create, read, update and delete this data (CRUD API).  Additional methods allow to display modal dialogs:  addToBasketModal() displays the sq-select-basket modal component which lets the user select a basket. The input document is then added to that basket.removeFromBasketModal() performs the same action as addToBasketModal() but removes the document from that basket.createBasketModal() displays the sq-edit-basket modal component which allows to create a basket after giving it a name.manageBasketsModal() displays the sq-manage-baskets modal component which displays the list of baskets and lets the user reorganize it (change the order, remove or rename elements). This component is similar to the sq-manage-saved-queries component.  Select Modal to add or remove a document to/from a basket ","version":"Next","tagName":"h3"},{"title":"Utils Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/components/utils","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Utils Module","url":"/dokku/docs/libraries/components/utils#features","content":" This module provides the following Angular declarations that are useful for the definition of your documents:  Angular pipes that can be used to format the display of value on your components,Directives that can be used to control the user interaction with your components,The injection token SCREEN_SIZE_RULES to override the component sizing rules based on window/screen size of the application.The UIService  ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Utils Module","url":"/dokku/docs/libraries/components/utils#import","content":" import { UtilsModule, SCREEN_SIZE_RULES } from '@sinequa/components/utils'; /* If you want to change the screen size rules provided by @sinequa/components */ export const myScreenSizeRules = { xl: &quot;(min-width: 1650px)&quot;, lg: &quot;(min-width: 1400px) and (max-width: 1649.98px)&quot;, md: &quot;(min-width: 992px) and (max-width: 1399.98px)&quot;, sm: &quot;(min-width: 576px) and (max-width: 991.98px)&quot;, xs: &quot;(max-width: 575.98px)&quot;, }; @NgModule({ imports: [ /*....*/ UtilsModule, /*....*/ ], providers: [ /* If you want to change the screen size rules provided by @sinequa/components */ { provide: SCREEN_SIZE_RULES, useValue: myScreenSizeRules }, /*....*/ ], /*....*/ })   ","version":"Next","tagName":"h2"},{"title":"API usage​","type":1,"pageTitle":"Utils Module","url":"/dokku/docs/libraries/components/utils#api-usage","content":" ","version":"Next","tagName":"h2"},{"title":"Pipes​","type":1,"pageTitle":"Utils Module","url":"/dokku/docs/libraries/components/utils#pipes","content":" This modules provides the following Angular pipes  DatePipe​  DatePipe provides the sqDate pipe that formats a Date object or a number of ticks (in number) to a localized date string.  Example:  &lt;span&gt;Date:&lt;/span&gt;&lt;span style=&quot;color: red;&quot;&gt;{{ new Date('2020-03-25') | sqDate }}&lt;/span&gt;   yields (for English locale)  &lt;span&gt;Date:&lt;/span&gt;&lt;span style=&quot;color: red;&quot;&gt;03/25/2020&lt;/span&gt;   This is equivalent as importing IntlService and calling IntlService.formatDate().  MomentPipe​  If you use the moment.js library to manipulate date and time value instead of Date from javascript, you can use MomentPipe to format your moment values.  The pipe accepts a MomentParams to configure the formatting result:  format: The format of the result date, if this property is given, the pipe ignores the other properties,type: The type of value formatting, the valid values are: 'iso': formats the moment object as ISO-8601 date string, eg. 'Tue Mar 24 2020 00:00:00 GMT+0100' =&gt; '2020-03-23T23:00:00.000Z','unix': formats the moment object as Unix timestamp (i.e. the number of seconds since the Unix Epoch - January 1 1970 12AM UTC), eg. 'Tue Mar 24 2020 00:00:00 GMT+0100' =&gt; '1585004400','valueOf' same as 'unix' but the unit is in milliseconds, eg. 'Tue Mar 24 2020 00:00:00 GMT+0100' =&gt; '1585004400000','daysInMonth': formats the moment object as the number of days in the given month, of the given year, eg. 'Tue Feb 24 2020 00:00:00 GMT+0100' =&gt; '29' or 'Tue Feb 24 2019 00:00:00 GMT+0100' =&gt; '28''fromNow': formats the moment object as user-friendly relative time to the current time, which is also called timeago, eg. 'Tue Jan 24 2020 00:00:00 GMT+0100' =&gt; '2 months ago' (current time being Tue Mar 24 2020). see moment.fromNow().'from': same as 'fromNow' but you can specify the reference date (as moment object) using reference property. see moment.from().'toNow': same as 'toNow' but in the opposite interval, one can think 'toNow' === -'fromNow', eg. 'Tue Jan 24 2020 00:00:00 GMT+0100' =&gt; 'in 2 months' (current time being Tue Mar 24 2020). see moment.toNow().'to': same as 'toNow' but you can specify specify the reference date (as moment object) using reference property. see moment.to().'calendar': displays time relative to a reference time (given by the reference object, or default to current time). It is slightly different to 'fromX' or 'toX' in that the result string depends on how close to the reference time your value is, eg. 'Tue Mar 22 2020 00:00:00 GMT+0100' =&gt; 'Last Sunday at 12:00 AM' (current time being Tue Mar 24 2020) or 'Mon Mar 30 2020 00:00:00 GMT+0100' =&gt; 'Monday at 1:00 AM' (current time being Tue Mar 24 2020). see moment.calendar().'diff': displays the time difference w.r.t. a reference time (given by the reference object) in milliseconds, it has the same direction as 'fromX', eg. 'Tue Mar 22 2020 00:00:00 GMT+0100' with reference 'Mon Mar 30 2020 00:00:00 GMT+0100' =&gt; '-518400000'. see moment.diff(). suffix: if false, a chronological suffix (i.e. 'ago' or 'in ...' ) is added to the result of 'fromX' and 'toX'. If true, a neutral time amount is returned, eg. 'a months', 'two years'.reference: The reference date for the formatting of 'from', 'to', 'calendar' and 'diff'unit: The time unit when formatting with 'diff', eg. 'hours', 'seconds'.precise: The 'diff' formatting returns a rounded integer by default, if you want a floating-point number instead, put this property as true.  &lt;span&gt;Moment:&lt;/span&gt;&lt;span style=&quot;color: red;&quot;&gt;{{ moment('1995-12-25') | sqMoment:{ type: 'fromNow', reference: moment('2015-12-25') } }}&lt;/span&gt;   yields  &lt;span&gt;Moment:&lt;/span&gt;&lt;span style=&quot;color: red;&quot;&gt;24 years&lt;/span&gt;   RelativeTimePipe​  RelativeTimePipe provides the sqRelativeTime pipe that formats a number, specifying a date time relative to the current time, to a localized date time string.  This pipe is inspired from ECMA-402 RelativeTimeFormat Objects.  Example:  &lt;span&gt;Relative time:&lt;/span&gt;&lt;span style=&quot;color: red;&quot;&gt;{{ -7 | sqRelativeTime:{unit: 'days'} }}&lt;/span&gt;   yields (in English locale)  &lt;span&gt;Relative time:&lt;/span&gt;&lt;span style=&quot;color: red;&quot;&gt;7 days ago&lt;/span&gt;   This is equivalent as importing IntlService and calling IntlService.formatRelativeTime().  TimePipe​  TimePipe provides the sqTime pipe that formats a Date object or a number of ticks (in number) to a localized time string.  Example:  &lt;span&gt;Time:&lt;/span&gt;&lt;span style=&quot;color:red;&quot;&gt;{{ new Date('2020-03-25 12:20:00.00Z') | sqTime }}&lt;/span&gt;   yields (for English locale and UTC)  &lt;span&gt;Time:&lt;/span&gt;&lt;span style=&quot;color:red;&quot;&gt;12:20:00&lt;/span&gt;   This is equivalent as importing IntlService and calling IntlService.formatTime().  MemorySizePipe​  MemorySizePipe provides the sqMemorySize pipe that formats a file size in bytes a localized size string with the appropriate size unit (TB, GB, etc.).  Example:  &lt;span&gt;Size:&lt;/span&gt;&lt;span style=&quot;color:red;&quot;&gt;{{ 16384 | sqMemorySize }}&lt;/span&gt;   yields (for English locale)  &lt;span&gt;Size:&lt;/span&gt;&lt;span style=&quot;color:red;&quot;&gt;16KB&lt;/span&gt;   This is equivalent as importing FormatService and calling FormatService.formatMemorySize().  NumberPipe​  NumberPipe provides the sqNumber pipe that formats a number to the locale format, i.e. using dot '.' as floating point for English and comma ',' for French.  Example:  &lt;span&gt;Decimal number:&lt;/span&gt;&lt;span style=&quot;color:red;&quot;&gt;{{ 3.14 | sqNumber }}&lt;/span&gt;   yields (for French locale)  &lt;span&gt;Size:&lt;/span&gt;&lt;span style=&quot;color:red;&quot;&gt;3,14&lt;/span&gt;   This is equivalent as importing IntlService and calling Intl.formatNumber().  ValuePipe​  ValuePipe provides the sqValue pipe that formats a value coming from an index column based on the value type of that column.  Example:  &lt;div&gt;boolean:&lt;span style=&quot;color:red;&quot;&gt;{{ true | sqValue }}&lt;/span&gt;&lt;/div&gt; &lt;div&gt;number:&lt;span style=&quot;color:red;&quot;&gt;{{ 3.14 | sqValue }}&lt;/span&gt;&lt;/div&gt;   yields (in French locale)  &lt;div&gt;boolean:&lt;span style=&quot;color:red;&quot;&gt;vrai&lt;/span&gt;&lt;/div&gt; &lt;div&gt;number:&lt;span style=&quot;color:red;&quot;&gt;3,14&lt;/span&gt;&lt;/div&gt;   This is equivalent as importing FormatService and calling Intl.formatFieldValue().  ExprPipe​  ExprPipe provides the sqExpr pipe that is mainly used to display a query filter. You can see the usage of this pipe in the breadcrumbs or MySearch facet.  Filters displayed with ExprPipe in breadcrumbs  Example:  &lt;span title=&quot;{{item.display | sqExpr:{withFields: displayFieldNames} }}&quot;&gt;&lt;/span&gt;   ","version":"Next","tagName":"h3"},{"title":"Directives​","type":1,"pageTitle":"Utils Module","url":"/dokku/docs/libraries/components/utils#directives","content":" Autofocus directive​  The sqAutofocus directive specifies which input component to be automatically focused when your component is opened.  Example:  &lt;textarea type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;myInput&quot; sqAutofocus &gt;   ClickOutside directive​  The sqClickOutside directive is a syntactic sugar that helps you manage the behavior of your input component when user clicks outside the component area.  The input for this directive is a ClickOutsideOptions:  exclude: A list of HTML selectors for the HTML elements that will not be effected by this directive. If any HTML element not matching the HTML selectors but contains matching children HTML is also ignored by the directive.  When a user clicks outside of your component, the directive emits an click event via its output sqClickOutside. By providing a callback to this output, you can act on the event.  Example:  &lt;form name=&quot;myform&quot; novalidate [formGroup]=&quot;form&quot;&gt; &lt;sq-modal [title]=&quot;model.title&quot; [buttons]=&quot;buttons&quot;&gt; &lt;div class=&quot;form-group sq-form-group&quot;&gt; &lt;label for=&quot;myInput&quot;&gt;Input:&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;sq-label-input&quot; (sqClickOutside)=&quot;clickOutside()&quot; name=&quot;myInput&quot; [(ngModel)]=&quot;myInputRef.value&quot; &gt; &lt;/div&gt; &lt;/sq-modal&gt; &lt;/form&gt;   ScrollIntoView directive​  The sqScrollIntoView directive is a syntactic sugar that helps to make sure a dynamically rendered child component of the current component to be in the visible area of the window.  This is useful when your component contains some kind of dropdown menu or collapsible part that you want to make sure to be visible when user opens or expands that part.  You can pass a ScrollIntoViewOptions as input of the directive:  active: whether the child component should be in the visible area,first: whether the child component is the first element in the list of elements to be considered.  Example:  &lt;span [sqScrollIntoView]=&quot;{active: true}&quot;&gt;Some item that is needed to be scrolled into visible area&lt;/span&gt;   FocusKeyList and FocusKeyListItem directives​  The sqFocusKeyList directive and sqFocusKeyListItem directive are used together to provide keyboard navigation functionality to items in lists, such as a results list. The sqFocusKeyList directive is added to the container element and the sqFocusKeyListItem directive is added to each child element. The sqFocusKeyList directive has the following inputs:  activeItem: the index of the currently active itemwithWrap: a boolean value indicating whether navigation should wrap on the first and last items. The default is true.  Additionally, sqFocusKeyList raises the itemSelect event with the index of the newly selected item.  Example:  &lt;div class=&quot;container&quot; sqFocusKeyList [activeItem]=&quot;currentIndex&quot; (itemSelect)=&quot;currentIndex = $event&quot;&gt; &lt;div *ngFor=&quot;let item of items&quot; class=&quot;item&quot; sqFocusKeyListItem&gt;{{item.name}}&lt;/div&gt; &lt;/div&gt;   ResizeEvent directive​  The sqResize directive uses the native ResizeObserver browser API to generate an event any time the associated element changes size. The new contentRect of the element is passed with the event. A polyfill is used to emulate this functionality for Internet Explorer.  Example:  &lt;div (sqResize)=&quot;onResize($event)&quot;&gt;&lt;/div&gt;   Sticky Component​  The sqSticky component is a container that &quot;sticks&quot; to the top and the bottom of the screen when scrolling. For example, a sidebar containing facets will be always visible on the screen, even when scrolling down a long list of results. Additionally, if the sidebar is itself very long, it will scroll with the content until reaching the bottom of the side bar (and then &quot;stick&quot; to the bottom of the screen). Note that this behavior is not possible when using a simple position: sticky or Bootstrap's sticky-top.  The component accepts as input an object containing the offsets with respect to the top and bottom of the screen. The default value is {top: 0, bottom: 0}.    Note that in Internet Explorer position: sticky is not supported, so the component automatically deactivates its sticky behavior.  ","version":"Next","tagName":"h3"},{"title":"Services​","type":1,"pageTitle":"Utils Module","url":"/dokku/docs/libraries/components/utils#services","content":" UIService​  The UIService provides helper methods to listen to screen sizing events and to verify the current screen size to the sizing rules of your component.  There are two event streams that you can subscribe to receive the screen sizing events:  priorityResizeEvent: Observable&lt;UIEvent&gt; This listeners of this stream will be be notified of the resize events first. This may be useful when you want to hierarchize the behavior of your components w.r.t to a resizing event.resizeEvent: Observable&lt;UIEvent&gt;  You can also listen to the resizing of a specific HTML element by adding your listeners with UIService.addElementResizeListener(htmlElement, callback) without bothering about the priority of your listener.  In order to remove a listener added by UIService.addElementResizeListener(), use UIService.removeElementResizeListener(htmlElement, callback).  Then there are a family of methods to compare the current screen size to a screen size in input:  screenSizeIsEqual(screenSize: string): booleanscreenSizeIsGreater(screenSize: string): booleanscreenSizeIsLess(screenSize: string): booleanscreenSizeIsGreaterOrEqual(screenSize: string): booleanscreenSizeIsLessOrEqual(screenSize: string): boolean  In combination with the screen sizing rules represented by the injection token SCREEN_SIZE_RULES, you can design the UI content of your component to be responsive to the size of the application (cf. Responsive design).  For example, you can decide to replace the display text of a button by its icon if the overall application screen size if less than a given threshold.  public get showButtonText(): boolean { return this.uiService.screenSizeIsGreaterOrEqual('lg'); }  ","version":"Next","tagName":"h3"},{"title":"Intl Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/core/intl","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Intl Module","url":"/dokku/docs/libraries/core/intl#overview","content":" This module provides internationalization (i18n) support to an application. Core functionality is provided by the IntlServicewhich manages locales and formats dates, numbers and strings depending on the current locale. It is based on the standardIntl API and an implementation of the ICU Message syntax provided by FormatJS.  ","version":"Next","tagName":"h2"},{"title":"Registering locales​","type":1,"pageTitle":"Intl Module","url":"/dokku/docs/libraries/core/intl#registering-locales","content":" A Sinequa locale defines the name and display and the data associated with the locale. At a minimum the data will define the locale for the Intl library and the messages in the locale's language. Locale data for additional 3rd party libaries (eg D3.js, Moment.js) can also be included. The supported locales for an application are defined by passing a class derived fromLocalesConfig to the IntlModule.forRoot static method when importing the IntlNodule in your application's NgModule:  import { LocalesConfig, Locale } from &quot;@sinequa/core/intl&quot;; import enLocale from &quot;../locales/en&quot;; ... export class AppLocalesConfig implements LocalesConfig { defaultLocale: Locale; locales?: Locale[]; constructor() { this.locales = [ { name: &quot;en&quot;, display: &quot;msg#locale.en&quot;, data: enLocale}, { name: &quot;fr&quot;, display: &quot;msg#locale.fr&quot;, data: frLocale}, { name: &quot;de&quot;, display: &quot;msg#locale.de&quot;, data: deLocale}, ] this.defaultLocale = this.locales[0]; } } ... @NgModule({ imports: [ ... IntlModule.forRoot(AppLocalesConfig), ] })   Alternatively, the Core library includes a default (en-US) locale that can be used to quickly get started:  import { DefaultLocalesConfig } from '@sinequa/core'; ... @NgModule({ imports: [ ... IntlModule.forRoot(DefaultLocalesConfig), ] })   ","version":"Next","tagName":"h2"},{"title":"Locale files​","type":1,"pageTitle":"Intl Module","url":"/dokku/docs/libraries/core/intl#locale-files","content":" The data for a locale is typically defined in its own file and follows the following structure:  ./locales/de.ts  import { LocaleData } from '@sinequa/core/intl'; import 'intl/locale-data/jsonp/de-DE'; // Safari import '@formatjs/intl-relativetimeformat/dist/locale-data/de'; // relative time format support import 'moment/locale/de'; // Moment.js import d3Format from 'd3-format/locale/en-US.json'; // D3.js import d3Time from 'd3-time-format/locale/en-US.json'; // D3.js import { enCore } from '@sinequa/core'; // Core language files // Load language files for those components used... import { deAdvanced } from '@sinequa/components/advanced'; ... import appMessages from './messages/en.json'; import { Utils } from '@sinequa/core/base'; // Merge the messages const messages = Utils.merge({}, deCore, deAdvanced, ..., appMessages); // Export the LocaleData export default { intl: { locale: 'de-DE' }, moment: { locale: 'de' }, d3: { locale: 'de-DE', format: d3Format, time: d3Time }, messages: messages } as LocaleData;   ","version":"Next","tagName":"h2"},{"title":"Current locale​","type":1,"pageTitle":"Intl Module","url":"/dokku/docs/libraries/core/intl#current-locale","content":" The current locale is initialized at application startup. It is set in this order:  the previously selected locale retrieved from local storage (key = 'sinequa-locale')a locale matching the browser languagethe deafault locale as specified in LocalesConfig  The IntlService can change the current locale to one of the values in the configured LocalesConfig. By default, the passed value will be persistent (stored in local storage).  this.intlService.use('fr');   Each time the locale is changed an event is raised which can be subscribed to like this:  this.intlService.events.subscribe( (event) =&gt; { console.log('new locale selected:', event.locale); } );   ","version":"Next","tagName":"h2"},{"title":"Messages​","type":1,"pageTitle":"Intl Module","url":"/dokku/docs/libraries/core/intl#messages","content":" Messages defined in locale message files can be accessed by IntlService.formatMessage. The keys must be prefixed by msg# and the remainder of the key is then a simple JSON path lookup into the messages object for the current locale. So, for a messages object with the following structure:  { &quot;sectionOne&quot;: { &quot;greeting1&quot;: &quot;This is greeting one&quot;, &quot;greeting2&quot;: &quot;This is greeting two&quot; }, &quot;sectionTwo&quot;: { &quot;greeting1&quot;: &quot;This is greeting one in sectionTwo&quot; } }   A call to this.intlService.formatMessage('msg#sectionOne.greeting2') would return This is greeting two.  Messages use ICU Message syntax that supports displaying variable values (strings, numbers and dates) and handles pluralization rules according to the current locale. A map of values can be passed as the second parameter to IntlService.formatMessage. For example, if message2 above were changed to Hello {name} and then formatted by calling this.intlService.formatMessage('msg#sectionOne.greeting2', {name: 'Tom'}); the result would be Hello Tom.  For more information on the ICU Message syntax please follow this link.  The sqMessage pipe is provided to facilitate the formatting of messages in component templates. Internally, it callsIntlService.formatMessage but also handles changes to the current locale, allowing any text displayed through the pipe to be refreshed automatically. The above example could be rendered in a template as follows:  &lt;span&gt;{% raw %}{{'#msgsectionOne.greeting2' | sqMessage:{values: {name: 'Tom'} } }}{% endraw %}&lt;/span&gt;   Note the use of spaces between the closing curly brackets in the parameter passed to the pipe. Without these spaces they would be interpreted as the termination of the interpolated value by the Angular template parser and an error would occur. ","version":"Next","tagName":"h2"},{"title":"App Utils Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/core/app-utils","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"App Utils Module","url":"/dokku/docs/libraries/core/app-utils#overview","content":" The App Utils module contains utilities for working with the configuration of a Sinequa SBA. It can be used by simply importing the module.  import { AppUtilsModule } from '@sinequa/core/app-utils'; ... @NgModule({ imports: [ ... AppUtilsModule ] }}   ","version":"Next","tagName":"h2"},{"title":"AppService​","type":1,"pageTitle":"App Utils Module","url":"/dokku/docs/libraries/core/app-utils#appservice","content":" This service includes an init method which is called automatically by LoginService.login and loads the app configuration usingAppWebService.get. It maintains the currently active ccquery which can be used by higher level services and components. Each timeccquery changes a QueryChangedEvent is emitted by the service.  The service provides facilities for working with various Sinequa configuration elements linked to an application:  web serviceslistsindex columns and their aliases  ","version":"Next","tagName":"h2"},{"title":"Query​","type":1,"pageTitle":"App Utils Module","url":"/dokku/docs/libraries/core/app-utils#query","content":" The Query object is the main input of the query web service (see web services and server configuration). It specifies the search query and its parameters.  ","version":"Next","tagName":"h2"},{"title":"Creation​","type":1,"pageTitle":"App Utils Module","url":"/dokku/docs/libraries/core/app-utils#creation","content":" A Query is created with:  const query = new Query(&quot;&lt;name of the query web service&gt;&quot;);   ","version":"Next","tagName":"h3"},{"title":"Searching for text​","type":1,"pageTitle":"App Utils Module","url":"/dokku/docs/libraries/core/app-utils#searching-for-text","content":" Specifying the fulltext query is done with the text property:  query.text = &quot;my search query&quot;;   ","version":"Next","tagName":"h3"},{"title":"Selecting a tab or scope​","type":1,"pageTitle":"App Utils Module","url":"/dokku/docs/libraries/core/app-utils#selecting-a-tab-or-scope","content":" The tab property is used to select a tab:  query.tab = &quot;tab name&quot;;   Similarly, the scope property is used to select a scope:  query.scope = &quot;scope name&quot;;   ","version":"Next","tagName":"h3"},{"title":"Filtering the metadata​","type":1,"pageTitle":"App Utils Module","url":"/dokku/docs/libraries/core/app-utils#filtering-the-metadata","content":" A &quot;filter&quot; is a condition applied on the metadata of the documents. For example, a filter could be &quot;the document's source is 'Documentation'&quot;:  query.addFilter({ field: &quot;source&quot;, value: &quot;Documentation&quot; });   There are different types of filters, that roughly correspond to the SQL operators supported by the Sinequa engine:  Equals: {field: &quot;source&quot;, value: &quot;Documentation&quot;} (the eq operator is implicit)Not equals: {field: &quot;source&quot;, value: &quot;Documentation&quot;, operator: &quot;neq&quot;}Greater than: {field: &quot;size&quot;, value: 1000, operator: &quot;gt&quot;}Greater than or equals: {field: &quot;size&quot;, value: 1000, operator: &quot;gte&quot;}Less than: {field: &quot;size&quot;, value: 1000, operator: &quot;lt&quot;}Less than or equals: {field: &quot;size&quot;, value: 1000, operator: &quot;lte&quot;}Between: {field: &quot;size&quot;, start: 1000, end: 2000, operator: &quot;between&quot;}Like: {field: &quot;title&quot;, value: &quot;Sinequa&quot;, operator: &quot;like&quot;}Contains: {field: &quot;authors&quot;, value: &quot;John&quot;, operator: &quot;contains&quot;}Regex: {field: &quot;format&quot;, value: &quot;doc[xm]?&quot;, operator: &quot;regex&quot;}In: {field: &quot;format&quot;, values: [&quot;pdf&quot;, &quot;doc&quot;, &quot;docx&quot;], operator: &quot;in&quot;}Null: {field: &quot;msgto&quot;, operator: &quot;null&quot;, not: true}  Additionally, the operator property can be set to &quot;and&quot;, &quot;or&quot; or &quot;not&quot; to combine multiple filters:  query.addFilter({ operator: &quot;and&quot;, filters: [ {field: &quot;treepath&quot;, value: &quot;/Documentation/Sinequa/&quot;}, { operator: &quot;or&quot;, filters: [ {field: &quot;docformat&quot;, value: &quot;pdf&quot;}, {field: &quot;docformat&quot;, value: &quot;html&quot;}, ] } ] });   It is also possible to specify a display property to customize the display of the filter in the UI:  query.addFilter({ field: &quot;treepath&quot;, value: &quot;/Documentation/Sinequa/&quot;, display: &quot;Sinequa&quot; });   The Query has various helper methods to manage the filters:  addFilter: Adds a filter to the query. findFilter: Return the first filter in the filter tree that matches the given predicate. For example, find all filters on the &quot;source&quot; field: query.findFilter(f =&gt; isFieldFilter(f) &amp;&amp; f.field === &quot;source&quot;); findAllFilters: Return all filters in the filter tree that match the given predicate. findFieldFilters: Return all filters in the filter tree that are field filters (with a field property, as opposed to and/or/not filters) and that match the given field(s). findValueFilters: Return all filters in the filter tree that are value filters (with a value property, as opposed to and/or/not/in/between/null filters) and that match the given field(s). findSameFilter: Return the first filter in the filter tree that is equivalent to the given filter. forEachFilter: Execute a function on each filter in the filter tree. getFilterCount: Return the number of filters in the filter tree. removeFilters: Remove all filters in the filter tree that match the given predicate. removeSameFilter: Remove the first filter in the filter tree that is equivalent to the given filter. removeFieldFilters: Remove all filters in the filter tree that are field filters (with a field property, as opposed to and/or/not filters) and that match the given field(s).  ","version":"Next","tagName":"h3"},{"title":"Sorting the results​","type":1,"pageTitle":"App Utils Module","url":"/dokku/docs/libraries/core/app-utils#sorting-the-results","content":" The sort property is used to sort the results. It must be configured in the query web service. For example, if the query web service has a sort named &quot;date&quot;, then:  query.sort = &quot;date&quot;;   ","version":"Next","tagName":"h3"},{"title":"Paging​","type":1,"pageTitle":"App Utils Module","url":"/dokku/docs/libraries/core/app-utils#paging","content":" The page property is used to specify the page of results to fetch:  query.page = 2;   The pageSize property is used to specify the number of results per page:  query.pageSize = 20;   ","version":"Next","tagName":"h3"},{"title":"Other properties​","type":1,"pageTitle":"App Utils Module","url":"/dokku/docs/libraries/core/app-utils#other-properties","content":" The Query object has other less frequently used properties that can be configured. See the source code for more details.  ","version":"Next","tagName":"h3"},{"title":"Format Service​","type":1,"pageTitle":"App Utils Module","url":"/dokku/docs/libraries/core/app-utils#format-service","content":" The FormatService is used to format values retrieved from a Sinequa index according to their type and the current locale. Numbers, dates and booleans are all handled by default. Custom formatters can also be assigned to columns in the Sinequa administration. The memorysize and language formatters are provided by default. The strings used in these formatters are defined in the messages in the Intl Module.  // The following will display &quot;size: 2.92Kb&quot; when using the en locale let column = this.appService.getColumn('size'); // Note that this would normally be configured in the Sinequa administration column.formatter = 'memorysize'; console.log('size:', this.formatService.format(3000, column)); // The following will display &quot;language: French&quot; when using the en locale column = this.appService.getColumn('documentlanguages'); // Note that this would normally be configured in the Sinequa administration column.formatter = 'language'; console.log('language:', this.formatService.format('fr', column));   Custom formatters can be provided by overriding the FormatService  import { Injectable } from '@angular/core/'; import { FormatService, ValueItem } from '@sinequa/core/app-utils'; import { FieldValue } from '@sinequa/core/base'; import { CCColumn } from '@sinequa/core/web-services'; ... @Injectable({ providedIn: 'root' }) export class MyFormatService extends FormatService { // Add support for a custom formatter formatValue: (valueItem: ValueItem | FieldValue, column?: CCColumn): string { if (column &amp;&amp; column.formatter === 'mycustomformatter') { let [value, display] = this.getValueAndDisplay(valueItem); switch (value) { case 0: return &quot;zero&quot;; case 1: return &quot;one&quot;; case 2: return &quot;two&quot;; } } return super.formatValue(valueItem, column); } }; ... // Provide @NgModule({ providers: [ { provider: FormatService, useClass: MyFormatService } ] })   Similarly, parsers can also be specified. These are used to parse values in fielded search expressions. A memorysize parser is included by default so that fielded search expressions such as size:&gt;=25Kb can be used. Note that server-side support for custom parsers is also required so that the expressions can be parsed on the server. A server-side custom parser takes the form of a function plugin namedParseExpressionValue which takes the custom parser name and the value to be parsed as parameters:  public class ParseExpressionValue : FunctionPlugin { public override string GetValue(IDocContext ctxt, params string[] values) { if (values.Length &lt;= 1) return null; var parser = values[0]; var value = values[1]; if (parser == &quot;mycustomparser&quot;) { // return the parsed value here } return null; } }  ","version":"Next","tagName":"h2"},{"title":"Login Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/core/login","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Login Module","url":"/dokku/docs/libraries/core/login#overview","content":" This module manages user authentication and the overall login process. User login is initiated automatically when a web service call fails with an HTTP 401 unauthorized error. This error is intercepted by an Angular HttpInterceptor which calls the LoginService.getCredentials method. This method will either request user credentials by opening a login modal dialog or, if configured using StartConfig.autoOAuthProvider orStartConfig.autoSAMLProvider, will initiate an OAuth or SAML authentication. In the case of a manual login via the modal dialog the original request will be resubmitted with the entered credentials. For OAuth and SAML the browser will redirect to the authentication provider and back again to the app. If Windows Authentication (Kerberos/NTLM) is being used then authentication will be handled at a lower level - the HTTP 401 errors shouldn't reach the application.  There is a default login modal dialog provided in this module but this can be replaced with a UI framework specific modal using theLoginModule.forRoot static method to import the LoginModule in the app module:  import { BsLogin } from '@sinequa/components/modal'; ... @NgModule({ imports: [ ... LoginModule.forRoot(BsLogin), ] })   ","version":"Next","tagName":"h2"},{"title":"Working with components​","type":1,"pageTitle":"Login Module","url":"/dokku/docs/libraries/core/login#working-with-components","content":" The login status is maintain in the LoginService. Typically, the top level route components in your application that communicate with the Sinequa platform should work with the LoginService to ensure that the user is logged in each time the component is instantiated and to handle the rendering of the component according to the current login status.  Ensure that the user is logged in at component instantiation like this:  ngAfterViewInit() { this.loginService.login(); }   The login method of the LoginService makes calls to AppService.init, PrincipalWebService.load and UserSettingsWebService.load. A login is successful if all three of these calls are successful. The LoginService maintains a boolean complete property that indicates the current login status. It also emits session events when the login status changes: session-start (login), session-end (logout) andsession-changed (complete state changes).  A helper class, ComponentWithLogin, is provided which formalizes a way to interact with the LoginService. This class implements ngAfterViewInitto call this.loginService.login and also listens to the LoginService events to maintain a loginComplete property and calls a virtual methodonLoginComplete each time the login status changes. An example follows:  import { Component, ChangeDetectorRef } from '@angular/core'; import { ComponentWithLogin, LoginService } from '@sinequa/core/login'; @Component({ selector: 'my-component', template: ` &lt;div *ngIf=&quot;loginComplete; then loginCompleteBlock else loginNotCompleteBlock&quot;&gt;&lt;/div&gt; &lt;ng-template #loginCompleteBlock&gt;User is logged in&lt;/ng-template&gt; &lt;ng-template #loginNotCompleteBlock&gt;User is NOT logged in&lt;/ng-template&gt; ` }) export class MyComponent extends ComponentWithLogin { constructor( loginService: LoginService, changeDetectorRef: ChangeDetectorRef) { super(loginService, changeDetectorRef); } }  ","version":"Next","tagName":"h2"},{"title":"UI Builder","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/ngx-ui-builder","content":"UI Builder UI Builder (ngx-ui-builder) is an Angular library for creating no-code tools &amp; applications. The library is developped by Sinequa as a standalone project hosted on GitHub and published on npm. It has a release cycle independent from the SBA framework, and it has its own documentation page and demo application. The library is used in the Vanilla Builder application to let users customize the standard Vanilla Search User Interface. The goal of this library is to provide three functionalities: The ability to make a User Interface re-configurable by drag-and-dropping its components into &quot;containers&quot; (supporting multiple levels of sub-containers, allowing for arbitrary UI layouts).The ability to customize the configuration and styling of the components by clicking on them and editing their properties in a form (including helper components to generate forms easily).The ability to save the configuration of the User Interface in a JSON format and to load it back later. The configuration can also be used to generate a &quot;static&quot; Angular application (where the components are in a fixed position and not configurable any more, like in a &quot;normal&quot; Angular application). This &quot;export&quot; is generated by running an Angular schematic in the application workspace (passing the configuration as a JSON file). Please refer to the UI Builder documentation for more details.","keywords":"","version":"Next"},{"title":"Notification Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/core/notification","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Notification Module","url":"/dokku/docs/libraries/core/notification#features","content":" This module provides the NotificationService that helps to create user notification.  An error notification  ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Notification Module","url":"/dokku/docs/libraries/core/notification#import","content":" You do not need to import this module because it is imported and overridden by the Components Notification module.  Whenever you want to emit user notifications in your component, inject the NotificationsService into your component.  ","version":"Next","tagName":"h2"},{"title":"API usage​","type":1,"pageTitle":"Notification Module","url":"/dokku/docs/libraries/core/notification#api-usage","content":" ","version":"Next","tagName":"h2"},{"title":"NotificationsService​","type":1,"pageTitle":"Notification Module","url":"/dokku/docs/libraries/core/notification#notificationsservice","content":" The NotificationsService provides several methods that helps you:  to create a user notification,to listen to the stream of notifications, so that your components can be notified when a new user notification arrives and reacts on that event,to manage the list of active notifications: to hide/show, to delete and to close them.  Emit user notification​  There are four types of notifications, which are defined by the enum value NotificationType. The valid values are Success, Info, Warning and Error.  The NotificationsService provides methods to rapidly emit a notification of each of these types:  NotificationsService.success() emits a Success notification.  The method signature is  success( text: string, params?: MapOf&lt;any&gt;, title?: string ): Notification   Example 1: success notification  this.notificationsService.success('A success message');   which yields  A success notification  NotificationsService.info() emits an Info notification.  The method signature is  info( text: string, // The message, could be internationalized (i18n) message. params?: MapOf&lt;any&gt;,// The formatting parameters for the message. title?: string // The title (header) of the notification. ): Notification   Example 2: info notification  this.notificationsService.info('An info message');   which yields  An info notification  NotificationsService.warning() emits an Warning notification.  The method signature is  warning( text: string, // The message, could be internationalized (i18n) message. params?: MapOf&lt;any&gt;,// The formatting parameters for the message. title?: string // The title (header) of the notification. ): Notification   Example 3: warning notification  this.notificationsService.warning('A warning message');   which yields  An info notification  NotificationsService.error() emits an Error notification.  The method signature is  error( text: string, // The message, could be internationalized (i18n) message. params?: MapOf&lt;any&gt;,// The formatting parameters for the message. title?: string // The title (header) of the notification. ): Notification   Example 4: error notification  this.notificationsService.error('An error message');   which yields  An error notification  You may notice that the notifications generated by NotificationsService.success() and NotificationsService.info()automatically disappear after a certain time while those generated by NotificationsService.warning() and NotificationsService.error()stay on the screen until you click on the close button. This is not fixed and you can can choose to make short-lived error notifications or info notification that stays on the screen until user closes it. This can be done using the method NotificationsService.success().  The method signature is  notify( type: NotificationType, // The notification type text: string, // The message, could be internationalized (i18n) message. params?: MapOf&lt;any&gt;, // The formatting parameters for the message. title?: string, // The title (header) of the notification. autoClose?: boolean // Whether the notification automatically closes after a certain time ): Notification   Example 5: custom notification  this.notificationsService.notify(NotificationType.Info, 'An info message');   which yields  A custom notification  Listen to the notification stream​  The NotificationsService provides the NotificationsService.notificationsStream() for any components that want to react on the event of arrival of new notification to subscribe.  In particular, it also emits a null event when notifications are deleted.  Manage user notifications​  The NotificationsService provides a variety of methods to follow and manage the state of the notification lists  haveNotifications() returns true if there are some notifications,allNotificationsShowing() returns true if all the notifications in the list are being shown on the screen,allNotificationsShowing() returns true if none of the notifications are being shown on the screen,lastNotification() returns the latest notification if any,showNotifications() shows all the notifications in the list,showNotifications() hides all notifications,deleteAllNotifications() deletes all notifications,deleteNotification(notification: Notification) deletes a specific notification,closeNotification(notification: Notification) hides a notification if it has just been created and has not been shown, otherwise deletes the notification. ","version":"Next","tagName":"h3"},{"title":"11.3.0","type":0,"sectionRef":"#","url":"/dokku/docs/releases/release-11-3-0","content":"11.3.0 See on Github The repository has the structure of an Angular Workspace. It is composed of two Angular libraries, @sinequa/core and @sinequa/components and two Angular applications using these libraries, Hello Search and Vanilla Search. Vanilla Search is a modern sample of Enterprise Search application including many features of Sinequa, which can be used as is, or as the starting point for a new project. We recommend cloning or forking this repository, and developing your own app within this clone/fork. By doing so, updating your workspace can be easily done by pulling from this repository.","keywords":"","version":"Next"},{"title":"Releases","type":0,"sectionRef":"#","url":"/dokku/docs/releases","content":"Releases This section lists every release of the SBA Framework and their associated release notes. The release notes are also available on the Github repository. In the process of migrating an SBA from an old version of the framework, we strongly recommend reading all the release notes from that version upward, and take note of every potential breaking change that might conflict with your own developments and customizations.","keywords":"","version":"Next"},{"title":"11.4.0","type":0,"sectionRef":"#","url":"/dokku/docs/releases/release-11-4-0","content":"11.4.0 See on Github This update brings many small improvements and bug fixes to the SBA framework. The most significant changes include: Improved display of relevant extracts in Vanilla Search's preview.The selection module can now keep track of record objects instead of just record ids. This allows a new selection arranger component to see and reorder a list of selected documents (see documentation).We removed automatic date revival (scanning of data returned by the REST API, to convert string into Date objects when possible - this caused unexpected bugs), which means custom code may need to be updated to perform this parsing wherever necessary.Improved results view management (currently not used in Vanilla Search since only one view is used)Fixed compatibility issues with IE11.Improved the autocomplete to sort items by relevance across categories.Refactored Heatmap component (see documentation).Refactored Timeline component (see documentation).Sample Vis Timeline component (see documentation).Refactoring of charts modules based on ngx-charts and fusioncharts (see documentation).","keywords":"","version":"Next"},{"title":"Web Services Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/core/web-services","content":"","keywords":"","version":"Next"},{"title":"Initialization​","type":1,"pageTitle":"Web Services Module","url":"/dokku/docs/libraries/core/web-services#initialization","content":" This module contains Angular services for the Sinequa web service APIs. The module can be initialized using the WebServicesModule.forRoot static method in your applications's NgModule which makes an injectable StartConfig object available to the services and components across the application. At a minimum the object passed to forRoot should contain the app and url (for ng serve or CORS support) fields. Other fields such as apiPath, browserUrl will be initialized automatically.  @NgModule({ imports: [ ... WebServicesModule.forRoot({ app: 'app-name', url: 'http://localhost', // set for ng serve / CORS production: environment.production }); ] ... });   Services in this module use SqHttpClient which derives from Angular's HttpClient and does two things:  pipes the returned observable through the share operator so that only one request is issued for multiple subscribersprevents identical concurrent requests by caching pending responses  Authentication is typically performed by the Login Module which provides an Angular HttpInterceptor to handle HTTP 401 errors and automatically initiate the authentication process with the Sinequa server.  Information on the usage of the various services follows:  ","version":"Next","tagName":"h2"},{"title":"App Web Service​","type":1,"pageTitle":"Web Services Module","url":"/dokku/docs/libraries/core/web-services#app-web-service","content":" Retrieves the CCApp configuration object from the Sinequa server. The application name is taken from the injected StartConfig.   this.appWebService.get().subscribe( (app) =&gt; { console.log('app:', app); } );   ","version":"Next","tagName":"h2"},{"title":"Principal Web Service​","type":1,"pageTitle":"Web Services Module","url":"/dokku/docs/libraries/core/web-services#principal-web-service","content":" This service retrieves the Principal object associated with the authenticated user. Although a basic get method exists it is more usual to callload which gets the principal and sets it on the principal property.   this.principalWebService.load().subscribe( (principal) =&gt; { console.log('principal:', principal); } );   The service also has an events property which can be subscribed to. A changed event is emitted each time the principal property changes.   this.principalWebService.events.subscribe( (event) =&gt; { console.log('principal changed:', this.principalWebService.principal); } );   ","version":"Next","tagName":"h2"},{"title":"User Settings Web Service​","type":1,"pageTitle":"Web Services Module","url":"/dokku/docs/libraries/core/web-services#user-settings-web-service","content":" This service can load and save user settings associated with the authenticated user. The user settings are stored as JSON on the Sinequa server. The load method stores the loaded user settings in the userSettings property. The UserSettings interface is declared with an index signature to allow arbitrary values to be stored in it.   this.userSettingsService.load().subscribe( (userSettings) =&gt; { console.log('user settings:', userSettings); } );   The current user settings can be modified on the client by updating the userSettings property and then calling save:   this.userSettingsService.userSettings.myProperty = 123; this.userSettingsService.userSettings.save();   The entire user settings are uploaded each time save is called. To update only a subset of the user settings the patch method can be used. This performs a JSON merge patch (rfc7396) of the passed partial user settings object with the current user settings on the server. Additions and updates can be performed like this:   // Add/update data in the user settings if (!this.userSettingsService.userSettings) { this.userSettingsService.userSettings = {}; } const details = { job: &quot;Sales&quot;, region: &quot;US&quot; }; // Update locally this.userSettingsService.userSettings.details = details; // Update the server, sending only the details object this.userSettingsService.patch({details});   To remove data from the user settings set a null value:   if (this.userSettingsService.userSettings) { // Update locally delete this.userSettingsService.userSettings.details; // Update the server, sending an instruction to remove the `details` value from the user settings this.userSettingsService.patch({details: null}); }   The service also has an events property which can be subscribed to. A changed event is emitted each time the userSettings property changes.  ","version":"Next","tagName":"h2"},{"title":"Query Web Service​","type":1,"pageTitle":"Web Services Module","url":"/dokku/docs/libraries/core/web-services#query-web-service","content":" The query web service issues a Sinequa search Query and retrieves an observable of the Results. The query name used must correspond one of the queries configured on the application in the Sinequa administration.  See the documentation of the query object.   const query = new Query('my-query-name'); query.text = 'football'; this.queryWebService.getResults(query).subscribe( (results) =&gt; { console.log('results:', results); } );   ","version":"Next","tagName":"h2"},{"title":"Preview Web Service​","type":1,"pageTitle":"Web Services Module","url":"/dokku/docs/libraries/core/web-services#preview-web-service","content":" This service retrieves data related to the document preview feature including highlighting information and the url to the preview document in the Sinequa document cache. The identifier of a document and the query context for highlighting are passed to the get call:   ... this.previewWebService.get(docid, query).subscribe( (previewData) =&gt; { console.log('preview data:', previewData); } );   ","version":"Next","tagName":"h2"},{"title":"Suggest Query Web Service​","type":1,"pageTitle":"Web Services Module","url":"/dokku/docs/libraries/core/web-services#suggest-query-web-service","content":" This service gets suggestions for some input text using a Suggest Query defined in the Sinequa administration console. The name of the current Querymust be passed and suggestions can optionally be limited to values from a set of passed fields. This service would typically be used by an autocomplete component.   // Get suggestions based on the input text for the authors column this.suggestQueryWebService.get('my-suggest-query', 'input-text', query.name, ['authors']).subscribe( (suggestions) =&gt; { console.log('suggestions:', suggestions); } );   ","version":"Next","tagName":"h2"},{"title":"Suggest Field Web Service​","type":1,"pageTitle":"Web Services Module","url":"/dokku/docs/libraries/core/web-services#suggest-field-web-service","content":" This service gets suggestions for input text from the values found in the passed input fields in the Sinequa indexes. A Query can be passed to limit suggestions to values in the context of a query.   // Get field value suggestions based on the input text for the authors column in the context of the passed `query` this.suggestFieldWebService.get('input-text', ['authors'], query).subscribe( (suggestions) =&gt; { console.log('suggestions:', suggestions); } );   ","version":"Next","tagName":"h2"},{"title":"Sponsored Links Web Service​","type":1,"pageTitle":"Web Services Module","url":"/dokku/docs/libraries/core/web-services#sponsored-links-web-service","content":" This service retrieves any sponsored links configured on the Sinequa server that match the passed query context. The name of a sponsored links web service configuration on the Sinequa server must also be passed.   this.sponsoredLinksWebService.getLinks(query, '_sponsoredlinks').subscribe( (links) =&gt; { console.log('sponsored links:', links); } );   ","version":"Next","tagName":"h2"},{"title":"Similar Documents Web Service​","type":1,"pageTitle":"Web Services Module","url":"/dokku/docs/libraries/core/web-services#similar-documents-web-service","content":" This service retrieves documents similar to the document with the passed id. It uses Sinequa's semantic vectors to return the documents closest to the passed document in the semantic space.   this.similarDocumentsWebService.get(&quot;docid&quot;, query.name).subscribe( (records) =&gt; { console.log('similar documents:', records); } );   ","version":"Next","tagName":"h2"},{"title":"Labels Web Service​","type":1,"pageTitle":"Web Services Module","url":"/dokku/docs/libraries/core/web-services#labels-web-service","content":" This service provides facilities for working with Sinequa's document tagging functionality. Labels are associated with documents and can be either public (viewable by all users) or private (viewable only by the authenticated user). Labels matching a prefix can be retrieved using the list method. This could be used to provide an autocomplete component for labels.   // Retrieve public labels matching the 'foo' prefix this.labelsWebService.list('foo', true).subscribe( (labels) =&gt; { console.log('labels matching foo:', labels); } );   One or more labels can added to one or more documents using the add method:   // Add a private 'my-label' to documents with ids 'docid1' and 'docid2' this.labelsWebService.add(['my-label'], ['docid1', 'docid2'], false);   Similarly, labels can be removed using the remove method:   // Remove a private 'my-label' from documents with ids 'docid1' and 'docid2' this.labelsWebService.remove(['my-label'], ['docid1', 'docid2'], false);   Labels can be renamed in all documents using the rename method:   // Rename the public 'a-label' to 'new-label' this.labelsWebService.rename(['a-label'], 'new-label', true);   Labels can be deleted from all documents using the delete method:   // Delete the private 'my-label' this.labelsWebService.delete(['my-label'], false);   Labels can be added and removed in bulk for a set of documents identified by a passed query. The number of matching documents is limited by a parameter configurable in the Labels web service in the Sinequa administration console.   // Add the public 'a-label' label to the documents returned by executing `query` this.labelsWebService.bulkAdd(['a-label'], query, true);    // Remove the public 'a-label' label from the documents returned by executing `query` this.labelsWebService.bulkRemove(['a-label'], query, true);   ","version":"Next","tagName":"h2"},{"title":"Query Export Web Service / Download Web Service​","type":1,"pageTitle":"Web Services Module","url":"/dokku/docs/libraries/core/web-services#query-export-web-service--download-web-service","content":" The Query Export Web Service provides methods for exporting the results of Sinequa search queries in a variety of formats. The number of documents exported is limited by the Maximum number of results by index setting on the associatedQuery in the Sinequa administration console. The output of the Query Export Web Service can be passed to the Download Web Service to save the results to disk. There are methods for exporting all the results (exportResult), a selection of the results (exportSelection) and the results of executing a saved query (exportSavedQuery).  Export the results of a query in CSV format and have the browser download the output to a file:   this.downloadWebService.download( this.queryExportWebService.exportResult('web-service-name', query, results, ExportOutputFormat.Csv));  ","version":"Next","tagName":"h2"},{"title":"11.4.1","type":0,"sectionRef":"#","url":"/dokku/docs/releases/release-11-4-1","content":"11.4.1 See on Github This update brings many small improvements and bug fixes to the SBA framework. The most significant changes include: Upgrade to Angular 10, which significantly improves the build performanceA refactoring of the HTTP interceptors to make them more transparent and easy to customize. There are now 3 independent interceptors that should be added to your application's list of providers: Login interceptor: takes care of initiating login/authentication when the server requires it.Audit interceptor: requests to the Sinequa API can include audit events. This interceptor can be used to customize globally the content of these events.Notifications interceptor: the server can now transmit notification messages in the JSON response of any request. This interceptor catches these notifications globally and displays them via the notifications service. ⚠️ When pulling this update into your project, do not forget to inject these interceptors into your own application(s), as it is done here in Vanilla Search We release a new Network component in Beta. The component is based on the Vis.js library and displays a graph that can be formed from Sinequa data (records, aggregations, metadata) in a flexible manner. Read the documentation here.The Query Export functionality now lets the user select which columns to export into a file (CSV, XLSX, etc.).","keywords":"","version":"Next"},{"title":"Modal Module","type":0,"sectionRef":"#","url":"/dokku/docs/libraries/core/modal","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Modal Module","url":"/dokku/docs/libraries/core/modal#features","content":" This module helps creating popups to inform end-user of an information or to prompt for some input from the user. For example, the popup that is shown when creating a new user alert.  Create alert popup  ","version":"Next","tagName":"h2"},{"title":"Import​","type":1,"pageTitle":"Modal Module","url":"/dokku/docs/libraries/core/modal#import","content":" Add import { ModalModule } from &quot;@sinequa/core/modal&quot;; into your app.module.ts.  Include ModalModule in Angular import declaration of app.module.ts.  @NgModule({ imports: [ /*....*/ ModalModule.forRoot(), /*....*/ ], /*....*/ })   ","version":"Next","tagName":"h2"},{"title":"API usage​","type":1,"pageTitle":"Modal Module","url":"/dokku/docs/libraries/core/modal#api-usage","content":" The most important declaration of this module is the ModalService which provides ways to rapidly create a popup and to wait for the user interaction with the popup.  ","version":"Next","tagName":"h2"},{"title":"ModalService​","type":1,"pageTitle":"Modal Module","url":"/dokku/docs/libraries/core/modal#modalservice","content":" The ModalService can be injected to your component when you need to inform user or to ask for user interaction before executing a procedure.  The service provides four public methods that creates four commonly types of popup:  ModalService.oK() is the simplest way to create an informative popup.  Example 1: a component that create a simple popup with OK button to inform user  import { Component, OnInit, Input, OnDestroy } from '@angular/core'; import { ModalService } from '@sinequa/core/modal'; @Component({ selector: 'my-component', templateUrl: './my.component.html' }) export class MyComponent { constructor(private modalService: ModalService) { } /* some component logics */ private someFunctionThatNeedsToInformUser() { this.modalService.oK('Hello world!'); } }   When the method someFunctionThatNeedsToInformUser() is called the following popup appears on the application.  Ok popup  The signature of the method is  oK( message: string, // The message to display to user, can be internationalized (i18n) message. messageParams?: MessageParams, // The format parameters for the message if i18n title?: string, // The title of the popup, could be i18n message. confirmType = ConfirmType.Success // The type of the confirmation ): Promise&lt;ModalResult&gt; // A Promise to wait for user interaction   The valid values of ConfirmType are Success, Info, Warning, Error.  The next method is ModalService.oKCancel(), which creates a popup with two buttons OK and Cancel.  The signature of the method is  oKCancel( message: string, // The message to display to user, can be internationalized (i18n) message. messageParams?: MessageParams, // The format parameters for the message if i18n title?: string, // The title of the popup, could be i18n message. confirmType = ConfirmType.Info, // The type of the confirmation primaryButton = ModalResult.OK // The primary button, ie. the auto-focused button, that will be clicked if user clicks Enter directly ): Promise&lt;ModalResult&gt; // A Promise to wait for user interaction   Example 2: A warning popup with OkCancel  this.modalService.oKCancel('Here is some important information', {}, 'Info', ConfirmType.Warning);   Which yields  Ok Cancel popup  Alternatively, the ModalService provides the method yesNo() to create a popup with two buttons Yes and No, which is essentially the same as okCancel() but with different button naming.  The signature of the method is  yesNo( message: string, // The message to display to user, can be internationalized (i18n) message. messageParams?: MessageParams, // The format parameters for the message if i18n title?: string, // The title of the popup, could be i18n message. confirmType = ConfirmType.Info, // The type of the confirmation primaryButton = ModalResult.OK // The primary button, ie. the auto-focused button, that will be clicked if user clicks Enter directly ): Promise&lt;ModalResult&gt; // A Promise to wait for user interaction   Example 3: A question popup with YesNo  this.modalService.yesNo('Do you want to perform the operation ?', {}, 'Question', ConfirmType.Info);   Which yields,  Yes No popup  Finally, if you want to create a popup that does not fit in those proposed by ModalService, you can use ModalService.confirm().  The signature of the method is  confirm( options: ConfirmOptions // The options to configure the popup modal ): Promise&lt;ModalResult&gt; // A Promise to wait for user interaction   The input of this method is a ConfirmOptions  interface ConfirmOptions { title?: string; // The title of the popup, could be i18n message. message: string; // The message to display to user, can be internationalized (i18n) message. messageParams?: MessageParams; // The format parameters for the message if i18n confirmType?: ConfirmType; // The type of the confirmation buttons: ModalButton[]; // The buttons to display on the popup }   Each button of a popup is of type ModalButton, which can be created by new ModalButtion(options).  The input of the constructor is of type IModalButton  interface IModalButton { result: ModalResult; // The result associated with the button. primary?: boolean; // Indicates whether this button is the primary button amongst a set of buttons. text?: string; // The button text. visible?: boolean; // Indicates whether the button is currently visible. validation?: FormGroup; // The validation `FormGroup` that should be tested when the button is // clicked. The button will only perform its `action` // when the validation is `valid`. anchor?: boolean; // Indicats whether the button should be rendered with an `&lt;a&gt;` tag // rather than a `&lt;button&gt;` tag. action?: (button: ModalButton) =&gt; void; // The action to perform when the button is clicked. // Buttons with `result` values other than `Custom` // also close the modal. }   Example 4: A customized popup with ModalService.confirm()  this.modalService.confirm({ title: 'Some random title', message: 'Hello world!', confirmType: ConfirmType.Info, buttons: [ new ModalButton({ text: 'Yeah wow', action: () =&gt; { }, result: ModalResult.OK }), new ModalButton({ text: 'Whatever', action: () =&gt; { }, result: ModalResult.Ignore }) ] });   Which yields,  Custom popup  All these methods are backed by ModalService.open(). All the modals displayed by ModalService.open() are dynamically created, not by including them in the HTML template of the caller component.  The signature of this method is  open( component: Type&lt;any&gt;, // The component represents the popup modal to be displayed config: ModalConfig = {} // The configuration of the popup modal ): Promise&lt;ModalResult&gt; // A Promise to wait for user interaction   The configuration of a modal is a ModalConfig  interface ModalConfig { panelClass?: string | string[]; // Classes that should be added to the `Overlay` pane. hasBackdrop?: boolean; // Indicates whether a backdrop should be added when opening the modal. backdropClass?: string | string[]; // Classes that should be added to the backdrop. model?: any; // The data model that the modal will operate on. width?: string; // The CSS width of the modal. height?: string; // The CSS height of the modal. fullscreen?: boolean; // Indicates whether the modal should occupy the screen width and height. // In this case `width` and `height` are set to `100%` // and the `sq-modal-fullscreen` class is added to `panelClass` closeOnBackdropClick?: boolean; // Indicates whether a click on the backdrop should close the modal. The default value is `true`. }   As it is shown in the signature of ModalService.open(), any component can be hoisted by this method as a popup modal in the application. The default popup component is injected via the Injection token MODAL_CONFIRM. You can change the default popup component in the Angular provider declaration of your app.module.ts.  import { /*...,*/ MODAL_CONFIRM} from &quot;@sinequa/core/modal&quot;; @NgModule({ /*....*/ providers: [ /*....*/ { provide: MODAL_CONFIRM, useValue: MyConfirmComponent } /*....*/ ], /*....*/ })   Or you can call your popup component directly with ModalService.open().  In effect, many of the popups used by Sinequa components are created using this method. Here are some examples of popup components:  Component name\tUI popupBsEditSavedQuery\tNew saved query BsManageSavedQueries\tManage saved queries BsEditAlert\tAlert BsEditBasket\tBasket  When hoisting the modal popup with your own component, you may want to transfer data back and forth with the component.  For that you need to inject MODAL_MODEL into your component, and then transfer the data object to model property when calling ModalService.open().  Example 5: transferring data to custom popup component  /********* mypopup.component.ts *********/ import { Component, OnInit, OnDestroy, Inject } from &quot;@angular/core&quot;; import { MODAL_MODEL } from &quot;@sinequa/core/modal&quot;; /* ... */ @Component({ /* ... */ }) export class MyPopup implements OnInit, OnDestroy { /* ... */ constructor( /* ... */ @Inject(MODAL_MODEL) public model: SomeDataObject, /* ... */ ) { /* ... */ } /* ... */ } /********* some component calling mypopup.component.ts *********/ import { Component, OnInit, OnDestroy, Inject } from &quot;@angular/core&quot;; import { ModalService, ModalResult, ModalConfig } from &quot;@sinequa/core/modal&quot;; import { MyPopup, SomeDataObject } from &quot;the/path/to/mypopup&quot;; /* ... */ @Component({ /* ... */ }) export class MyComponent implements OnInit, OnDestroy { /* ... */ constructor( /* ... */ private modalService: ModalService, /* ... */ ) { /* ... */ } private callMyPopup(): Promise&lt;void&gt; { const data: SomeDataObject = { /* ... */ }; const modalConfig: ModalConfig = { /* ... */ model: data, /* ... */ } this.modalService .open(MyPopup, modalConfig) .then((popupResult: ModalResult) =&gt; { switch (modalResult) { /* react to the modal result*/ } }); } /* ... */ }  ","version":"Next","tagName":"h3"},{"title":"11.5.0","type":0,"sectionRef":"#","url":"/dokku/docs/releases/release-11-5-0","content":"11.5.0 See on Github Migration to Angular 11. The migration is relatively easy. For customer applications, make sure to apply the following change in angular.json: replace &quot;lazy&quot;: true by &quot;inject&quot;: false (this change is already done for Vanilla Search). Some application-level configuration files also change (tsconfig.ts): In customer applications these files must be aligned with the ones in Vanilla Search. Note that with this new configuration, ng serve captures changes in the core and components libraries (ie. no need to wait for the libraries to recompile when working on a packaged component).The autocomplete supports Fielded Search with a graphical mode (colored badges in the search bar) or advanced mode (text-based, supporting boolean expressions)Improvements of the facet components: Possibility to remove filters in the multi-facet component (for one subfacet or all at once)Multiple selections within the same facet are merged when possibleSelected items always appear at the top of the facet list (even if they yield no result)Multiple selection is supported in search modeScrollbars added by default to manage long lists of itemsFacet filters component now uses actual facet components in dropdownsSimplification of facet-range UI Support for multiple results views added (not enabled by default in Vanilla, but new documentation available)Refactoring of the labels components and integration in Vanilla: Simplified labels menusLabelling integrated in the selection toolbar (supporting single and multiple document selection)Adding/removing labels on a document can be done through the same &quot;edit&quot; dialog (supporting autocomplete) New sample module demonstrating Google maps integration in the SBA framework.New application sample: Pepper, a Search &amp; Analytics application built around a customizable dashboard. Pepper includes various sample widgets (charts, map, timeline, network, heatmap) which can be extended and customized.New &quot;sqSticky&quot; directive to allow facet bars to have a fixed position but still be scrollable when too long. sqSticky is now used by default in Vanilla.Added an &quot;artificial&quot; session id for auditing the application (with a 10 min timeout). Also fixed some audit events (removed events for recent queries &amp; documents, added events when removing filters and sorting the page, etc.).New autoscrolling directive and &quot;more results&quot; components, as modern alternatives to the classical pager. The autoscrolling directive is activated by default in Vanilla Search.Refactoring of advanced search components and sample integration in Vanilla Search, with associated documentation. Simplified API and reusable building blocks designed in line with Angular's best practices.Improvements of document navigator (incl. zoom in/out buttons, better loading of HTML, dynamic position of tooltip)Improvements of home page facets in Vanilla (possibility to open items in new tabs)By default, in Vanilla, the tab currently opened is persisted even when searching for new text. This change can be easily reverted by changing the search() method in search-form.component.ts.New documentation for user ratings, sponsored links, auditing applications, results views, labels, advanced search, feedback, Pepper, autoscroll, facet filters, login methods and server-side plugins.","keywords":"","version":"Next"},{"title":"11.6.0","type":0,"sectionRef":"#","url":"/dokku/docs/releases/release-11-6-0","content":"11.6.0 See on Github General refactoring of the SBA libraries: The @sinequa/components library has been refactored as 2 libraries (@sinequa/components and @sinequa/analytics). The new analytics library contains the most advanced components from the former library (charts, heatmap, network, map, timeline), and we will keep developing new modules featuring similar advanced integrations.References to the material design library have been removed. Only the components based on the Bootstrap library remain.The tslint configuration has been replaced with eslint configuration.Our 3 libraries are now published to npm (we will publish them every time we release a new version of the code on Github). Preview optimization &amp; improvements: General performance optimization to speed up the loading time of the preview, particularly with large number of pagesOptimization of the extract panel on the left, to handle a large number of extractsDisplay of the document title &amp; original URL at the top of the document navigatorImprovement of the preview tooltip look &amp; feel (dynamic scale &amp; positioning)Custom user interface for documents split by pages with document splitterThe preview facet (visible in Vanilla &amp; Pepper) now has action buttons to toggle the visibility of entities &amp; extracts highlightsWe added the possibility to remove the sandbox attribute of the preview iframe (by passing null, which can be required in some situations) Facets: New tag cloud facet component. Documentation available here. This component was added to Pepper's palette of components.Refactored my-search facet component with new options &amp; styling. Documentation available here. Note that this component replaces the breadcrumbs component in both Vanilla &amp; Pepper (the component is not displayed with a facet card, but simply above the list of results).Handling of excluded items in list facetsList facets now have an option to display a visual bar proportional to the number of items New functionalities added to the main search form of Vanilla &amp; Pepper (which are now fully identical): Inline button to clear the formInline button to keep current filters (eg. facets) active for a new search (false by default)Inline button to search by speaking (the button is not shown by default, as it relies on querying Google's servers)Inline button to display an advanced form (not shown on Pepper by default)The above options can all be turned on or off by commenting or uncommenting the features in config.ts (or alternatively by passing these options via the &quot;Customization (JSON)&quot; tab of the application's configuration - See configuration).The search form now handles a long list of fielded search &quot;badges&quot; by scrolling horizontally (with additional left/right buttons) New web services added to the @sinequa/core library: DatasetWebService: allows to fetch data from the new Dataset web service (currently in beta) as an alternative to the query web service.QueryIntentWebService: allows to analyze a user's query to infer its intent, using the latest query intent integration on the Sinequa server (currently in beta). New audit events added: Navigation events: We now record navigation between routes of the applications, as well as leaving the app and returning (navigation.home, navigation.exit, etc.)Timeline filtering (from, to)Autocomplete selectionApplication logout The analytics library contains a new &quot;finance&quot; module containing 2 components for displaying amounts of money extracted from documents. Documentation available here. These components have been added to Pepper's palette of components.Minor improvements to the network component's performance &amp; APINew options/behaviors added to the sq-result-title componentThe user ratings component does not display empty messages any moreDelegated admins can now navigate to the administration from the user menuNew documentation page on the SBA startup lifecycle available here.","keywords":"","version":"Next"},{"title":"11.6.1","type":0,"sectionRef":"#","url":"/dokku/docs/releases/release-11-6-1","content":"11.6.1 See on Github Multiple optimizations and bug fixes of the document navigator and preview module: Improved navigation in the list of extractsBetter performance with large filesFixed issues with Excel spreadsheets (eg. refresh the list of extracts when changing tabs)Improved embedded tooltip positioning and display (fixed cropped tooltip on the sides and bottom of the preview)Support entity formatting and internationalization (featured developed by Sword) Tree facets are now searchable ([searchable]=&quot;true&quot;) by default. For an optimal experience, please check &quot;Match the search terms anywhere in field values&quot; in the autocomplete web service configuration (available as of Sinequa 11.6.0).New option in facet filters (Pepper's horizontal facet bar) to let users customize the list of facets with [enableCustomization]=&quot;true&quot; (feature developed by CTC).New &quot;comments&quot; module in the @sinequa/components library to display a thread of comments attached to a document. Comments must be stored in a custom index, and accessed via a server-side plugin (which is provided along with the front-end code). Refer to the online documentation.New &quot;ag-grid&quot; module in the @sinequa/analytics library to display a list of search results as a grid component powered by the AG Grid library. The module contains one component which is a sample integration of the AG Grid library (which can be used in many other ways). We implemented the &quot;Infinite row model&quot; supported by the library, which offers a great user experience compared to alternatives. We use the free version of the library (&quot;Community&quot;), but many additional options are available with the Enterprise version. Refer to the online documentation.Improvements of the metadata module (documentation): Display entity counts within a document (returned by the server as of Sinequa 11.6.1)Collapse multi-valued metadata by defaultFixed inline display mode and general look &amp; feelRemoved the &quot;spacing&quot; parameterSimplified styling of the libraryRemoved entity-summary component and result-metadata (now redundant) Optimization and bug fixes in the timeline module (selection boundaries hidden out of viewport, fixed behavior when series are reduced to a single point) and new &quot;legend&quot; component which can be displayed with [showLegend]=&quot;true&quot; (Refer to the documentation).Refactoring and optimization of the action module.Refactoring of module dependencies to enable lazy loading of routes (See Angular documentation), which is now supported (but not implemented by default) in Vanilla Search.New option to reset all user settings in the user top-right menu.Fixed cropped drop-down/drop-up menus in Pepper.Fixed a breaking change in the &quot;user ratings&quot; component.Multiple improvements of audit events (to support the new Usage Analytics SBA released in Sinequa 11.6.1).Added a warning when editing but not saving an alert.Fixed the behavior of the app for 403 errors (forbidden access).","keywords":"","version":"Next"},{"title":"11.7.1","type":0,"sectionRef":"#","url":"/dokku/docs/releases/release-11-7-1","content":"","keywords":"","version":"Next"},{"title":"General changes:​","type":1,"pageTitle":"11.7.1","url":"/dokku/docs/releases/release-11-7-1#general-changes","content":" ⚠️ Migration to Bootstrap v5 and Popper.js v2: This migration introduces breaking changes! When migrating an existing app to this new version of the framework, please follow the official guide from Bootstrap.  Among the most impacting changes are the spacing classes used throughout the framework:  ml-* becomes ms-* (&quot;s&quot; stands for start)mr-* becomes me-* (&quot;e&quot; stands for end)same for padding: pl-* and pr-*  Why this new notation? For LTR/RTL language purpose (Left to Right/Right To Left)  If we are in LTR: &quot;start&quot; is &quot;left&quot; and &quot;end&quot; is &quot;right&quot; (&quot;s&quot; and &quot;e&quot; in the new notation)If we are in RTL: &quot;start&quot; is &quot;right&quot; and &quot;end&quot; is &quot;left&quot;, this is done automatically, no need to update UI for RTL language with this new notation.  ","version":"Next","tagName":"h2"},{"title":"Vanilla & Pepper​","type":1,"pageTitle":"11.7.1","url":"/dokku/docs/releases/release-11-7-1#vanilla--pepper","content":" Refactored search template to use a results$ observable, making customization easier, and removing the need for a subscription.Deactivate Gridster overflow when dropdown is shown (fixing cropped dropdown menus in Pepper)  ","version":"Next","tagName":"h2"},{"title":"Core library​","type":1,"pageTitle":"11.7.1","url":"/dokku/docs/releases/release-11-7-1#core-library","content":" Added a ccquery parameter to the function getColumn() to allow the use with other cc queries, default has been in case no value is set  ","version":"Next","tagName":"h2"},{"title":"Components library:​","type":1,"pageTitle":"11.7.1","url":"/dokku/docs/releases/release-11-7-1#components-library","content":" Action module: Allowed objects in dropdown-menu to get custom classesFacet module: Support distributions with null values  ","version":"Next","tagName":"h2"},{"title":"Analytics library​","type":1,"pageTitle":"11.7.1","url":"/dokku/docs/releases/release-11-7-1#analytics-library","content":" New Date facet component (in timeline module), combining (optionally): a timeline, date pickers (from/to) and predefined facet items (&quot;since 1 year&quot;)Added clientSide option to sq-ag-grid if all data is already loaded and infinite scrolling is not requiredAdded cell renderer framework to column definitions for AG GridFixed heatmap breadcrumbs bad selectionAdded a loading flag to show the user when the heatmap's data is loading ","version":"Next","tagName":"h2"},{"title":"11.7.0","type":0,"sectionRef":"#","url":"/dokku/docs/releases/release-11-7-0","content":"","keywords":"","version":"Next"},{"title":"General changes​","type":1,"pageTitle":"11.7.0","url":"/dokku/docs/releases/release-11-7-0#general-changes","content":" Migration from Angular 11 to 12.2: The migration has little impact on the source code of your application. See the official migration guide. ⚠️ However, you may encounter difficulties with your dependencies. We recommend completely deleting your node_modules folder, running npm clean cache and reinstalling it from scratch (npm install). If possible, use our provided package.json and package-lock.json as is. If you have modified these files (to install libraries), make sure to update your versions to reflect the changes we have made (like removing d3-format or setting specific versions of certain libraries).  ⚠️ Code duplications: To minimize duplication of code between Vanilla and Pepper, we modified Pepper to reference files in the Vanilla project (like the search form, autocomplete and various stylesheets). Files are typically referenced with &quot;@sinequa/vanilla&quot; (an alias added in pepper/tsconfig.json). If you use the Pepper sample application you may either use this new structure (modify files in the Vanilla Search project), or use the legacy structure. A drawback of using the legacy structure is that your application will not be updated when we release new versions (only the Vanilla Search code will be updated).  Icons and logos: We updated Sinequa icons and logos across our applications and documentation.  The loading screens (defined in index.html) now use inline styles rather than Bootstrap to avoid a positioning glitch on start-up.  A new documentation page (Speed and Performance) explains how to use module lazy loading to speed-up complex applications (typically with multiple routes and &quot;heavy&quot; components).  Compilation errors on UNC paths (due to CSS stylesheet extensions) have been fixed.  ","version":"Next","tagName":"h2"},{"title":"@sinequa/core library:​","type":1,"pageTitle":"11.7.0","url":"/dokku/docs/releases/release-11-7-0#sinequacore-library","content":" New web service &quot;Doc Builder&quot;: DocBuilderWebService allows to merge documents split by pages (PDF, Words, Powerpoints...). This is the service powering the new &quot;Presentation Builder&quot; module (see below).  New web service &quot;Text Chunks&quot;: TextChunksWebService allows to fetch text from specific documents at specific locations. This is the service powering the new &quot;entity tooltip&quot; functionality (see below).  ⚠️ Following a change in the query web service, the list of relevant extracts for each record has a new harmonized structure. This may affect your application if it makes use of this data (which is not the case in the standard Vanilla Search and Pepper application samples).  ⚠️ Minor change in the Dataset web service: The get() method returns a Dataset type instead of a Results type.  ","version":"Next","tagName":"h2"},{"title":"@sinequa/components library:​","type":1,"pageTitle":"11.7.0","url":"/dokku/docs/releases/release-11-7-0#sinequacomponents-library","content":" ","version":"Next","tagName":"h2"},{"title":"New module: Slide Builder 🎉​","type":1,"pageTitle":"11.7.0","url":"/dokku/docs/releases/release-11-7-0#new-module-slide-builder-","content":" New module to display a list of slide and a selection arranger to create a custom slide deck and export it. See documentation.  ","version":"Next","tagName":"h3"},{"title":"Search module:​","type":1,"pageTitle":"11.7.0","url":"/dokku/docs/releases/release-11-7-0#search-module","content":" Integration of Query Intent web service in the SearchService. See documentation to leverage Query intents in your SBA.Infinite scroll: Added a visual indicator that more results are being loadedSort selector: Fixed error in the sort selector (with no sort action).  ","version":"Next","tagName":"h3"},{"title":"Facets module:​","type":1,"pageTitle":"11.7.0","url":"/dokku/docs/releases/release-11-7-0#facets-module","content":" Facet tree/list: Give the possibility to customize the list of facets for each tab (includedTabs, excludedTabs properties of FacetConfig)Filters can be removed using the checkboxFixed facet list with integer values Facet Filters: New option to let users personalize their list of filters (enableCustomization). Developers must provide the complete list of facets and the default ones (See configuration of the facet bar)Fixed tree facet closing unintentionally when clicking on the tree itemsSet a minimum and maximum width for the dropdown facetsMade facet filters special states (filtered, disabled) more visible Tag Cloud: Fixed a tagcloud bug where the clear all filters wouldn't work when the Input aggregations was a stringUse column's alias instead of column's name to have consistent styles (defined in the metadata stylesheet). Facet Card: Add option collapseOnClickOutside so that it collapses once clicking outside (for dropdown behavior)  ","version":"Next","tagName":"h3"},{"title":"Preview module​","type":1,"pageTitle":"11.7.0","url":"/dokku/docs/releases/release-11-7-0#preview-module","content":" New minimap component displaying the position of extracts in the documentAdd a preview loading indicatorJump to most relevant extract when preview opensIn entity facet (preview), i18n entity labels (like &quot;Xxx[fr]Yyy&quot;) are properly displayed and formatted.Fix extracts panel sort tooltip missing text  ","version":"Next","tagName":"h3"},{"title":"Metadata module​","type":1,"pageTitle":"11.7.0","url":"/dokku/docs/releases/release-11-7-0#metadata-module","content":" Metadata component: New option showEntityTooltip to display text surrounding entities in a tooltip. To enable this functionality, set this input to true and check &quot;Include locations in the results&quot; in the Query web service &gt; Advanced &gt; Entities section.  ","version":"Next","tagName":"h3"},{"title":"Results view module​","type":1,"pageTitle":"11.7.0","url":"/dokku/docs/releases/release-11-7-0#results-view-module","content":" When 'view' query params is missing, the default view is displayed  ","version":"Next","tagName":"h3"},{"title":"Result module​","type":1,"pageTitle":"11.7.0","url":"/dokku/docs/releases/release-11-7-0#result-module","content":" Results source component propagates clicks (to open the preview in Vanilla/Pepper)Sponsored results: Tooltips are properly displayed  ","version":"Next","tagName":"h3"},{"title":"Utils module:​","type":1,"pageTitle":"11.7.0","url":"/dokku/docs/releases/release-11-7-0#utils-module","content":" Fixed tooltip remaining visible in the top left of the screenTooltips can now display HTML asynchronously  ","version":"Next","tagName":"h3"},{"title":"User settings:​","type":1,"pageTitle":"11.7.0","url":"/dokku/docs/releases/release-11-7-0#user-settings","content":" Refactored the user menu (integrated the dark mode button)  ","version":"Next","tagName":"h3"},{"title":"Baskets (aka collections):​","type":1,"pageTitle":"11.7.0","url":"/dokku/docs/releases/release-11-7-0#baskets-aka-collections","content":" Made baskets exportable (from &quot;manage baskets&quot; popup)  ","version":"Next","tagName":"h3"},{"title":"Autocomplete module:​","type":1,"pageTitle":"11.7.0","url":"/dokku/docs/releases/release-11-7-0#autocomplete-module","content":" Added a function to know if the field-search-items components has items or not.  ","version":"Next","tagName":"h3"},{"title":"@sinequa/analytics library:​","type":1,"pageTitle":"11.7.0","url":"/dokku/docs/releases/release-11-7-0#sinequaanalytics-library","content":" ","version":"Next","tagName":"h2"},{"title":"AG Grid:​","type":1,"pageTitle":"11.7.0","url":"/dokku/docs/releases/release-11-7-0#ag-grid","content":" Integrated Sinequa facets and search service in ag-grid module for optimal search experience.Fixed lost selection of records when filtering.  ","version":"Next","tagName":"h3"},{"title":"Heatmap:​","type":1,"pageTitle":"11.7.0","url":"/dokku/docs/releases/release-11-7-0#heatmap","content":" Fixed ResultsHeatmapView selectView causing search to fail (make sure that searches complete before component is destroyed)  ","version":"Next","tagName":"h3"},{"title":"Charts:​","type":1,"pageTitle":"11.7.0","url":"/dokku/docs/releases/release-11-7-0#charts","content":" Display aggregation labels instead of name in charts dropdown menus  ","version":"Next","tagName":"h3"},{"title":"Advanced form​","type":1,"pageTitle":"11.7.0","url":"/dokku/docs/releases/release-11-7-0#advanced-form","content":" Fixed styling of metadata in multi-input forms.  ","version":"Next","tagName":"h3"},{"title":"Pepper App:​","type":1,"pageTitle":"11.7.0","url":"/dokku/docs/releases/release-11-7-0#pepper-app","content":" Replaced pager by infinite scrollGave widgets specific default sizes (when adding from the &quot;add widget&quot; modal)Added the treepath facet to Pepper's facet filters by default ","version":"Next","tagName":"h2"},{"title":"General changes","type":0,"sectionRef":"#","url":"/dokku/docs/releases/release-11-8-0","content":"See on Github General changes Removed support for Internet Explorer from browserslist fileUpgrade to ngx-bootstrap v8Migration from ng5-slider to angular-sliderRefactoring of proxy config files to group all the endpoints togetherAdded &quot;override&quot; keyword from typescript 4.3 to improve type checkingFixed Bootstrap btn-light class (hover and active effects invisible when the button is on a bg-light background)Fixed some remaining Bootstrap v5 utilities (font-style -&gt; fst, font-weight -&gt; fw...) Vanilla Search New Help menu available within the User menuAdded the new sq-facet-date (featuring the timeline) as a replacement to the sq-facet-list for the &quot;modified&quot; metadataAdded the new Neural Search components, when Neural Search is activated: Neural Search On/Off button in search formAnswer card at top of results listPassages displayed instead of relevant extractsList of relevant passages available within the preview UIPassages highlighted in the HTML preview Pepper Fixed broken view when a widget is added while another is maximized Core library Fixed infinite loops upon 401 errors Components library Facets library (@sinequa/components/facet): ⚠️ Major refactoring of the &quot;facet containers&quot; (sq-facet-multi, sq-facet-filters and sq-facet-bar). Previously, these components were limited to predefined facet types, namely sq-facet-list and sq-facet-tree and predefined parameter names. Now, these containers can display any type of facet components, including custom ones. This change requires a migration of the facet configuration objects (defined by default in the config.ts files): The FacetConfig&lt;T&gt; is now parametric, requiring developers to specify what kind of configuration they contain (eg. FacetConfig&lt;FacetListParams&gt; for an sq-facet-list component. Please refer to the documentation of this module for more information.allowAnd option added to the sq-facet-tree (same usage as for sq-facet-list)Prevent sequential clicks in the sq-facet-tree to be merged with ORProper wrapping of the list of filters in the sq-facet-filters components, when there are too many filters to display on one line.Fixed wrong number of items in facets (by default 11 instead of 10)Fixed bug with null value selection in distributions Search library (@sinequa/components/search): When an http search request fails, stop the loading animationTabs (sq-tabs): Made the display of counters optional (showCounts parameter) Preview library (@sinequa/components/preview): Display the link to the PDF version of the file, when availableFixed issue with the navigation history (requiring double clicks of the back button)FIxed issue with minimap when there are no extract to display Utils library (@sinequa/components/utils): Added fallback positions (fallbackPlacements) to the sq-tooltip directiveSaved queries library (@sinequa/components/saved-queries): Prevent app from breaking if multiple query exports are definedAutocomplete library (@sinequa/components/autocomplete): Removed parsing of the query when fielded search if offRecent documents &amp; Recent queries: Fixed conversion of dates to/from UTC to avoid displaying wrong dates.Action library (@sinequa/components/action): Fixed menus left open when nested within another dropdown menuResult and Metadata libraries: Better support of change detection (primarily to enhance the User Experience in UI Builder)sq-result-title: Use the original document URL (&quot;store original&quot; option) when it exists and url1 is not available Machine Learning library (@sinequa/components/machine-learning): 2 new components dedicated to the Neural Search user interface (sq-answer-card for displaying answers found by the &quot;Answer Finder&quot; model, and sq-passage-list for displaying the list of passages found by the &quot;Passage Ranking&quot; model) Analytics library Timeline library: UI improvements to the sq-facet-date component (which is now used by default in Vanilla and Pepper)New option to display a tooltip when hovering the datapoints of the timeline Network component: Display real labels instead of aggregation names in network menus","keywords":"","version":"Next"},{"title":"Components","type":0,"sectionRef":"#","url":"/dokku/docs/releases/release-11-8-1","content":"See on Github Components Machine Learning module: New &quot;Top passages&quot; component for Neural Search displayed by default in Vanilla Search Bug fixes: Fix compatibility issues with Safari (date format not managed)Stop loading animation when an exception occursFix light button color that was to clear from Bootstrap 5 migrationFix bug with facet collapse buttonSync first-page service on login changesFix exception when facet autocomplete term contains special charactersFix neural search deactivated when &quot;keep filters&quot; is on","keywords":"","version":"Next"},{"title":"General changes","type":0,"sectionRef":"#","url":"/dokku/docs/releases/release-11-9-0","content":"","keywords":"","version":"Next"},{"title":"Library updates​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11-9-0#library-updates","content":" We upgraded most of our libraries to their latest version and adressed all known vulnerabilities, (except those for which we are blocked by a third-party library that cannot be upgraded).  These library updates also bring improved performance and often a reduction in bundle size.  These updates introduce various breaking changes and may require additional migrations in customer-maintained source code (particularly Angular, Bootstrap, RxJS and Moment).  Migration to Angular 14 (from 12)Migration to RxJs 7.5 (from 6.6)Migration to Bootstrap 5.2 (from 5.1)Migration to D3 v7 (from v5) and optimized import to reduce bundle sizeReplaced the deprecated moment library and jstz to date-fns and date-fns-tz across all components and services processing dates and datetimes.Updated the Intl, FormatJS, jssha, lodash libraries (and others) to latest versionsUpdated the ngx-charts, vis-network and vis-timeline libraries (used in the analytics library) to the latest versionsReplaced the (poorly-maintained) ngx-vis and angular-fusioncharts libraries with in-house wrappers to improve performance and fix bugsReplaced the deprecated @agm library with @angular/google-maps  ","version":"Next","tagName":"h2"},{"title":"Compatibility with Safari​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11-9-0#compatibility-with-safari","content":" We adressed different issues specific to Safari:  Broken timeline ZoomingTimeline Events not displayedDates displayed as &quot;Invalid&quot; (Sinequa's standard format was not properly parsed by new Date())  ","version":"Next","tagName":"h2"},{"title":"Project structure​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11-9-0#project-structure","content":" We reorganized our tsconfig files across the workspace, along with other configuration files (ng-package, secondary-entry-point-config, tslint/eslint, karma, etc.)  Core library  Integration in Teams: We added a TeamsInitializer (APP_INITIALIZER) in the application startup. Its role is to ensure that when the SBA is loaded within a Microsoft Teams tab, the user is automatically authenticated, without the need for additional authentication and/or redirection to an identity provider.Login: Fixed a bug where the browser would attempt multiple redirects on 401 errors, causing errors with specific Identity Providers.Fixed a syntax error thrown by the fielded search parser when a &quot;-&quot; symbol was in the query.Audit (breaking change): we harmonized our standard audit events across components and applications to be consistent with the events expected by the latest Usage Analytics application.  Components  New Sinequa Theme packaged under @sinequa/components/theme. The theme is a set of modular stylesheets that can be imported indidividually or as a whole in an application's global stylesheet. The theme modifies the appearance of standard Bootstrap components and specific Sinequa components. See https://sinequa.github.io/sba-angular/modules/components/theme.htmlWe refactored the components in the @sinequa/components/machine-learning library, following new Neural Search features and modified web services (breaking change). These components (showing answers, top passages, and matching passages per document) are all integrated by default in Vanilla Search. See https://sinequa.github.io/sba-angular/modules/components/machine-learning.htmlPreview library: Simplification of the sq-facet-preview-2 component (breaking change): This component now only manages the preview itself, and does not display the document metadata or document title. (In Vanilla Search the metadata and title are now displayed via the facet-card itself)Fixed navigation issues (eg. 2 clicks required to go back to the search view)Fixed SVG highlights in documents generated by certain converters Facet library: Facet card: Various additions to the sq-facet-card API (See https://sinequa.github.io/sba-angular/modules/components/facet.html). These new features are used in the new &quot;Mini-Preview&quot; of Vanilla Search and should be used more generally for displaying complex components with multiple views, actions and options. Natively support multiple views. These views are injected within ng-template elements decorated with a directive sqFacetView. The facet-card displays a list of actions to toggle between the views, in the bottom-left corner of the facet card header.Support primary actions (shown in the header top-right corner) and secondary actions (shown in the header bottom-right corner).The 3 action groups (views, primary, secondary) can be completely and independently customized (size, styles, positioning, etc.)The custom ng-templates (for the header, sub-header, footer and settings) that a facet component could already declare in its own template, can now be injected into the sq-facet-card directly (thus removing complexity from child components and opening more possibilities for the parent components). Facet-list and facet-tree: Refreshed look &amp; feel and checkboxes to make multiple selection more intuitive. We also added the option to display the search bar permanently.Facet-range: The min/max inputs now accept given number and Date inputs Metadata library: We removed the separator in &quot;inline&quot; mode (as opposed to &quot;tabular&quot;).Result source component: We changed the treepath separator to a prettier one (❯) and made it easier to customize the component styles.Result counter: Prevent text wrappingUser menu: We now show the user's full name if available, but it is only visible as a tooltip and within the dropdown menu's header. It is possible to display the user name as before, by passing [showText]=&quot;true&quot; to the component.Modal component: Modals now respect the height/width/fullscreen settings available in the modal service.New sq-scope component (packaged in @sinequa/components/search) to toggle between &quot;search scopes&quot; defined in the query web service. The component is integrated in the default search-form component packaged in Vanilla-Search (but it is visible only if scopes are actually configured).SearchService: We made this service (along with the QueryWebService and Breadcrumbs) generic with respect to the Results type, so that it can be easily customized for a custom index schema. (eg. inject SearchService&lt;MyResults&gt; in your component, where MyResults includes all your custom metadata).Sponsored links: handle link URL when it contains %PREVIEW_URL%Fixed broken ClickOutside directive  Analytics  New multi-level pie chart component to display tree-typed metadata. See https://sinequa.github.io/sba-angular/modules/analytics/fusioncharts.htmlImproved the API of the Tooltip component used in the analytics views (heatmap, timeline, money charts...), resulting in simplified and consistent usage across these components. The tooltip is now in its own library: @sinequa/analytics/tooltipMade the timeline tooltip scroll vertically, when too many values.Fixed the heatmap component in cooccurrence modeFixed the ngx-chart legend in dark mode  Vanilla Search  The new Sinequa Theme is used by default in Vanilla-Search.The &quot;mini-preview&quot; (displayed along the results) uses the simplified version of the facet-preview component and improved facet-card API, supporting multiple views (see above).When Neural Search is active, the mini-preview displays two views: Preview and Passages (from the machine learning package). This list of views can be easily customized by adding/removing ng-templates in the facet card.The metadata component is displayed with [tabular]=&quot;false&quot; by default, to save space in the mini preview header.A placeholder card is displayed on the right side when no preview is opened, to encourage a click on a document from the user.Refactored the application navbar to match the grid layout of the main app content.Fixed scrolling to bottom when returning to the home page ","version":"Next","tagName":"h2"},{"title":"Tips and Tricks","type":0,"sectionRef":"#","url":"/dokku/docs/tipstricks","content":"Tips and Tricks","keywords":"","version":"Next"},{"title":"Auditing applications","type":0,"sectionRef":"#","url":"/dokku/docs/tipstricks/audit","content":"","keywords":"","version":"Next"},{"title":"Prerequisites​","type":1,"pageTitle":"Auditing applications","url":"/dokku/docs/tipstricks/audit#prerequisites","content":" On the server, several prerequisites are necessary:  The creation of an audit index. The creation of jobs to process the audit logs and update the audit index. In the web app's configuration, specify which actions should be collected:  ","version":"Next","tagName":"h2"},{"title":"Standard Events​","type":1,"pageTitle":"Auditing applications","url":"/dokku/docs/tipstricks/audit#standard-events","content":" By default, Sinequa components take care of emitting audit events when needed. For example, the SearchService emits events when the user searches for some text and the FacetService emits events when they select a metadata in a facet.  This can happen in two ways:  Normally, these audit events are emitted by &quot;piggy-backing&quot; on the web service HTTP call corresponding to the audited user action.Alternatively, stand-alone audit events can be emitted via the AuditWebService.  ","version":"Next","tagName":"h2"},{"title":"Audit events via standard web service calls​","type":1,"pageTitle":"Auditing applications","url":"/dokku/docs/tipstricks/audit#audit-events-via-standard-web-service-calls","content":" Sinequa Web Services accept an optional $auditRecord parameter that is used to write events to the audit logs.  For example, in the QueryWebService, the web service call looks as follows:  const observable = this.httpClient.post&lt;Results&gt;(this.makeUrl(this.endPoint), { app: this.appName, query, $auditRecord: auditEvents, queryIntentData });   Note that the $auditRecord field is supported across all web services, including the custom ones (in particular JsonMethodPlugin).  ","version":"Next","tagName":"h3"},{"title":"Audit events via the audit web service​","type":1,"pageTitle":"Auditing applications","url":"/dokku/docs/tipstricks/audit#audit-events-via-the-audit-web-service","content":" The AuditWebService is a standard Sinequa service that can be injected anywhere in your application to emit &quot;standalone&quot; audit events.  For example, it is used to emit events when users open a document (by following its original URL) in the SearchService:  this.auditService.notifyDocument( AuditEventType.Click_ResultLink, record, results || resultId || &quot;&quot;, { querytext: this.query.text, querylang, }, { queryhash: results ? results.rfmQueryHash : undefined, querytext: this.query.text, querylang: querylang } );   ","version":"Next","tagName":"h3"},{"title":"Custom Events​","type":1,"pageTitle":"Auditing applications","url":"/dokku/docs/tipstricks/audit#custom-events","content":" Audit events are not limited to a predefined list of event types or a predefined content. It is possible to create new types of events and customize their structure.  The AuditEvent interface is very flexible as it requires:  A type, which can be a standard type (among those listed in the AuditEventType) or a custom string. A detail field, which is a simple key-value map, where the keys correspond to columns of the audit index (of course, these columns must exist in the audit index schema, which can be customized).  Therefore, emitting a custom standalone event is as simple as the following example:  this.auditWebService.notify({ type: &quot;ResultsView_Change&quot;, detail: { view: this.resultsViewService.resultsView.name } });   ","version":"Next","tagName":"h2"},{"title":"Customizing standard events​","type":1,"pageTitle":"Auditing applications","url":"/dokku/docs/tipstricks/audit#customizing-standard-events","content":" It is often required to add some custom data to a standard event (or even to all standard events). One solution to that problem would be to modify (or override) the existing services (SearchService, FacetService, etc.), to add the missing data. But this approach is cumbersome and requires more maintenance.  A better alternative is to intercept audit events globally (just before they are sent to the server) and modify them all in this centralized location. This can be achieved by extending the standard AuditInterceptor and overriding the updateAuditRecord() method.  HTTP interceptors are a standard way to manipulate HTTP requests and responses globally in Angular. Sinequa includes an interceptor dedicated to audit events. It is provided by default in application samples, such as Vanilla Search, in the app.module.ts file:  @NgModule({ ..., providers: [ ... // Provides an HttpInterceptor that offers a centralized location through which all client-side // audit records pass. An application can replace AuditInterceptor with a subclass that overrides // the updateAuditRecord method to add custom audit information to the records. {provide: HTTP_INTERCEPTORS, useClass: AuditInterceptor, multi: true},   You can replace this standard interceptor with your custom version:  {provide: HTTP_INTERCEPTORS, useClass: MyAuditInterceptor, multi: true},   This custom interceptor should extend the original version and override the updateAuditRecord() method. In the example below, we modify specifically the Search_Text audit events to include the query web service's name in the detail object.  import { Injectable, Inject } from '@angular/core'; import { AuditInterceptor } from '@sinequa/core/app-utils'; import { AuditRecord, StartConfig, START_CONFIG, AuditEventType } from '@sinequa/core/web-services'; import { SearchService } from '@sinequa/components/search'; @Injectable({ providedIn: &quot;root&quot; }) export class MyAuditInterceptor extends AuditInterceptor { constructor( @Inject(START_CONFIG) startConfig: StartConfig, public searchService: SearchService){ super(startConfig); } protected updateAuditRecord(auditRecord?: AuditRecord) { auditRecord?.auditEvents?.forEach(event =&gt; { if(event.type === AuditEventType.Search_Text &amp;&amp; event.detail) { event.detail.queryWS = this.searchService.query.name; } }); } }  ","version":"Next","tagName":"h2"},{"title":"Configuration","type":0,"sectionRef":"#","url":"/dokku/docs/tipstricks/configuration","content":"","keywords":"","version":"Next"},{"title":"Source-code configuration​","type":1,"pageTitle":"Configuration","url":"/dokku/docs/tipstricks/configuration#source-code-configuration","content":" The first one is not specific to Sinequa: You can simply store your settings in a global TypeScript file that you can import anywhere in your app. An example of this is available in Vanilla Search with the src/config.ts file. You can use this file to store any data you need, and then import this data from a component or service.  config.ts export const FACETS = [ { &quot;title&quot;: &quot;Companies&quot;, &quot;aggregation&quot;: &quot;Companies&quot; }, { &quot;title&quot;: &quot;People&quot;, &quot;aggregation&quot;: &quot;People&quot; }, ... ]   app.component.ts import { FACETS } from &quot;../config&quot;; ... public getFacets(){ return FACETS }   app.component.html &lt;sq-facet-card *ngFor=&quot;let facet of getFacets()&quot; [title]=&quot;facet.title&quot;&gt; &lt;sq-facet-list #facet [results]=&quot;results&quot; [aggregation]=&quot;facet.aggregation&quot;&gt;&lt;/sq-facet-list&gt; &lt;/sq-facet-card&gt;   The drawback of this method is that you have to rebuild your application to take into account any change in the configuration.  ","version":"Next","tagName":"h2"},{"title":"Server-side configuration​","type":1,"pageTitle":"Configuration","url":"/dokku/docs/tipstricks/configuration#server-side-configuration","content":" This approach stores the configuration in JSON format in the Sinequa administration. Your App configuration has a &quot;Customization (JSON)&quot; tab as described in Server configuration.  Unlike the first method, this configuration is dynamic, meaning you won't have to rebuild your application to see the difference. However, it is only available post-login, so you cannot store information like the URL of your web-service (See environment for that).  We can adapt our first example:    app.component.ts import { AppService } from '@sinequa/core/app-utils'; ... constructor( ... private appService: AppService) { } public get facets() { return this.appService.app?.data?.facets || []; }   (The HTML template is unchanged)  ","version":"Next","tagName":"h2"},{"title":"Combining both approaches​","type":1,"pageTitle":"Configuration","url":"/dokku/docs/tipstricks/configuration#combining-both-approaches","content":" In Vanilla Search both approaches are used. By default, the src/config.ts file is used, but if configuration is passed through the AppService as above, then it takes precedence.  For example, the Home component has the following logic for listing the active features (resulting in specific facets on the home page):  home.component.ts import { AppService } from '@sinequa/core/app-utils'; import { FEATURES } from '../../config'; constructor( ... private appService: AppService) { } ... public get features(): string[] { return this.appService.app?.data?.features as string[] || FEATURES; }  ","version":"Next","tagName":"h2"},{"title":"General changes","type":0,"sectionRef":"#","url":"/dokku/docs/releases/release-11.10.0","content":"","keywords":"","version":"Next"},{"title":"⚠️ Platform breaking changes​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#️-platform-breaking-changes","content":" Unlike previous versions of the SBA Framework, the 11.10.0 release is not compatible with older versions of Sinequa ES (11.9.0 and below). This is due to various new functionalities in the platform's REST API (see below).  ","version":"Next","tagName":"h2"},{"title":"Documentation updates​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#documentation-updates","content":" The SBA documentation has been significantly enriched, rewritten and reorganized. In particular:  Rewritten Introduction and Getting Started sectionsNew Guides section with guidance on SBA architecture, development environment, versioning, etc.Reorganized the Components documentation and introduced interactive examples to replace the previous static screenshots and code snippets.New Applications section including not only the core framework (vanilla, pepper) but also the Usage Analytics and Vanilla Builder applications.New Releases section with a list of all SBA releases and their main changes (mirroring the Github releases).Auto-generated documentation (compodoc) was removed. Instead, we automatically link class names and interfaces found in the documentation to the matching source code in the Github repository.  ","version":"Next","tagName":"h2"},{"title":"End-to-end tests​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#end-to-end-tests","content":" This release introduces end-to-end (e2e) tests for the SBA components. These tests are written with Cypress and defined in the cypress folder of the repository. These tests cover the (new) projects/components-docs application which centralizes all of Sinequa components from projects/analytics and projects/components (see below). These tests consist primarily in rendering each component and comparing its visual appearance with a reference screenshot. The reference screenshots are stored in the cypress/snapshots folder.  Library updates  ","version":"Next","tagName":"h2"},{"title":"Core​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#core","content":" ","version":"Next","tagName":"h2"},{"title":"Web services​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#web-services","content":" Removed support of fielded search expressions (Expr, ExprParser, ExprBuilder classes). Expressions are replaced with a new &quot;filter&quot; syntax documented in the Core library. Note that the fielded search syntax used in the search form is still interpreted by the platform as before (but the SBA is unaware of it). ⚠️ Any usage of Expr in a custom application must be migrated to the new filter syntax. The new syntax essentially provides the same level of functionality: Before: expr = this.exprBuilder.concatAndExpr([ this.exprBuilder.makeExpr(&quot;docformat&quot;, &quot;pdf&quot;), this.exprBuilder.concatOrExpr([ this.exprBuilder.makeExpr(&quot;authors&quot;, &quot;John&quot;), this.exprBuilder.makeNumericalExpr(&quot;size&quot;, &quot;&lt;&quot;, 1024) ]) ]); query.addSelect(expr); After: filter = { operator: &quot;and&quot;, filters: [ { field: &quot;docformat&quot;, value: &quot;pdf&quot; }, { operator: &quot;or&quot;, filters: [ { field: &quot;authors&quot;, value: &quot;John&quot; }, { field: &quot;size&quot;, operator: &quot;&lt;&quot;, value: 1024 } ] } ] }; query.addFilter(filter); Dataset web service: New isDatasetError(result) method to easily test whether a result returned by the dataset web service is valid.The get(webService, dataset) now throws an error if the result is not a valid dataset, and its return signature has therefore been changed to Observable&lt;Results&gt;.The getAll() method is removed. Use getBulk() without specifying any dataset instead. The Json Method web service now has proper typing for the options argument, enables typing the return type and does not log the response to the console anymore. The Query web service Results object is more accurately typed and was updated to match the latest platform changes (especially around the Neural Search data structures). The download service now allows specifying a file name for the downloaded file (rather than the default one sent by the server).  ","version":"Next","tagName":"h3"},{"title":"Login​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#login","content":" ⚠️ Removed support for login in a popup window using ng2-ui-auth (unmaintained library). The Login interceptor now sends the UI language to the platform (via headers and/or body). The Login interceptor now intercepts network errors (eg. 0, 503, 504) and automatically performs retries (progressively spaced in time, as in gmail) while displaying a special notification to the user. The Login service now supports hard-coded credentials for development or CI purposes. Credentials can be injected in an app module's providers: {provide: CREDENTIALS, useValue: {username: &quot;admin&quot;, password: &quot;admin&quot;}}   ","version":"Next","tagName":"h3"},{"title":"Audit​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#audit","content":" All events now include the current browser URL so the current route &amp; query are always available in the logs.Logging of route change events is now a core feature as opposed to an app-by-app implementation.Logging of exit/return events is now a core feature as opposed to an app-by-app implementation. Now only the Navigation_Return events are captured, following a click on a document link (as opposed to tracking any kind of navigation, or alt-tabbing).  ","version":"Next","tagName":"h3"},{"title":"Miscellaneous​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#miscellaneous","content":" Fixed the escaping of html elements passed to formatjs (https://github.com/sinequa/sba-angular/issues/108).IntlService.formatRelativeTime() now behaves consistently whether given a string/Date (delay relative to now) or a number (delay) and always auto-determines the display unit (min, hour, day, week, etc.).  ","version":"Next","tagName":"h3"},{"title":"Components​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#components","content":" All components that apply filters to the Query have been migrated to the new filter syntax (see above)  ","version":"Next","tagName":"h2"},{"title":"Autocomplete module​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#autocomplete-module","content":" ⚠️ Removed the sqAutocompleteFieldSearch directive and sq-field-search-items component (following the removal of the fielded search syntax).New SuggestService features: When no suggestion is returned, attempt a new strategy of autocompleting only the last token of the query (eg. &quot;Sinequa Sea&quot; -&gt; &quot;Sinequa Search Engine&quot;).Deduplication, highlighting and scoring of suggest results.Better protection against HTML injection in the suggest results.  ","version":"Next","tagName":"h3"},{"title":"Collapse module​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#collapse-module","content":" ⚠️ Removed sq-collapse-link (unused and redundant with sq-collapse-button).  ","version":"Next","tagName":"h3"},{"title":"Facet module​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#facet-module","content":" ⚠️ Major refactoring of the sq-facet-list component: Removal of the sq-facet-tree component. sq-facet-list now handles both list and tree aggregations.A click on the checkbox displays an &quot;Apply&quot; button that lets user check other items before applying the selection.A click anywhere else on an item applies the selection immediately.Advanced selection options (AND / OR / NOT operators) are nested under a dropdown menu.New icon for &quot;removing a filter&quot;.Changes in options: Added focusSearch (default: false): Automatically focus the search bar when the facet is expanded.Added expandedLevel (default: 2): The number of levels expanded by default (for tree aggregations).Removed showCheckbox (determined automatically)Removed displayActions (not useful anymore)Removed showProgressBar (unused)Removed alwaysShowSearch (the search bar is always shown when searchable is true)allowAnd is false by default ⚠️ Removed sq-facet-mysearch (Replaced by the Filters module). Change of behavior in the sq-facet-refine component: Rather than adding a special select property to the query and letting the server modify the fulltext search query accordinly, this component now directly modifies the fulltext query via query.addRefine(). Refactoring of the sq-facet-multi component. The component now displays a custom header template. The icon and title of the facet should be passed as input to this component rather than to the parent sq-facet-card. New sq-facet-container component to display a list of facets as a toolbar, where one facet can be expanded at a time. This component is documented in the Facet library. This component is used in the new integrated search form (packaged in Pepper). Refactoring of the sq-facet-filters component to properly display the actions and custom templates of the facet components in the dropdown panels. Facet card: Handle the &quot;click outside&quot; event more efficiently (see: https://github.com/sinequa/sba-angular/issues/106).New inputs to control the actions' tooltip placement (defaultTooltipPlacement and defaultTooltipFallbackPlacements).  ","version":"Next","tagName":"h3"},{"title":"New Filters module​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#new-filters-module","content":" This new module is documented in the Components library. It allows displaying and editing the filters of a Query object. The component is meant to replace the sq-facet-mysearch and sq-breadcrumbs components.  ","version":"Next","tagName":"h3"},{"title":"Machine Learning module​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#machine-learning-module","content":" New sq-chat component and ChatService service to display a chatbot interface. This component allows to chat with a Large Language Model such as GPT-4 (the model powering ChatGPT). This component is documented in the Machine Learning library. Refactored the sq-top-passages component: No more pagination, passage truncation or custom facet card header. The text of the answer (predicted by the answer finder model is highlighted within the text of the passage). The component also auto-hides if no passages are found.  ","version":"Next","tagName":"h3"},{"title":"Metadata module​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#metadata-module","content":" ⚠️ Major refactoring of the module:  Removal of the sq-metadata-access-list component (unused).Redesign of the sq-metadata and sq-metadata-item components. Metadata is now displayed according to a configuration (incl. icon, label, filterable, etc.), similar to how the facets and facet containers work. The components are documented in the Metadata library.New HighlightService whose role is to dynamically generate CSS styles to highlight entities in text, based on a given configuration. This service allows to decouple the preview CSS (which used to contain highlight colors for entities) from the main application, which may or may not want to highlight entities or other metadata dependending on the context. In the context of the metadata module, this service allows to apply highlighting in the &quot;entity tooltip&quot; that displays an extract from a document featuring the entity (see the documentation for more information).  ","version":"Next","tagName":"h3"},{"title":"Preview module​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#preview-module","content":" ⚠️ Major refactoring of the module:  Removal of unused legacy components (from SBA v1). Replacement of the sq-preview-document-iframe and sq-facet-preview components, as well as the PreviewDocument class with a new sq-preview component. This component is documented in the Preview library. A new script must be injected in the preview, similar to how the CSS stylesheet was injected so far: The script file name must be configured in the preview web service configuration on the server. The default name should be preview/preview.js (see the _preview configuration for reference).The script must be included in your application build. This is now the case by default in Vanilla Search, Pepper and Hello Search. The preview highlights (colors of the entities) are now generated dynamically based on configuration passed to the sq-preview component. This allows adding or removing entity highlights without having to recompile the application (simply by adding your custom configuration in the &quot;Customization JSON&quot; object of your application). This is again illustrated by default in Vanilla Search. Note: This refactoring allows the preview to be used in CORS contexts (eg. when the application is served from a different domain as the Sinequa WebApp).  ","version":"Next","tagName":"h3"},{"title":"Result module​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#result-module","content":" Three new components allow to display exact and approximate* duplicate documents in a result list: sq-result-duplicates: A simple component that displays the number of exact and approximate duplicates for a given document.sq-result-duplicates-spacer: A component that visually differentiates approximate duplicates in a results list.sq-result-duplicates-list: Displays a list of &quot;approximate duplicates&quot; for a given document. *: &quot;Approximate duplicates&quot; are determined by a developer-supplied function (see SearchOptions) that compares two documents and returns a boolean. See the Result module documentation for more information. Refactoring of the sq-result-icon component: Rather than relying on a global stylesheet to map file extensions to icons, the component now accepts a custom mapping as input (a default mapping is provided with the same icons as those previously defined in CSS). New showMustInclude option added to sq-missing-terms to allow users to force a missing term to be included in the query. Added internationalization of the treepath items in sq-result-source. The sq-result-thumbnail component does NOT wrap the thumbnail in a link anymore if either linkBehavior is false or if the URL of the document is empty.  ","version":"Next","tagName":"h3"},{"title":"New Search-Form module​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#new-search-form-module","content":" New module exporting a customizable sq-search-form component.  This component is used in a simple way in Vanilla Search (where it only shows an autocomplete component in the expanded state).  It is also used in Pepper to display an integrated search form (featuring filters, facets and autocomplete).  This module is documented in the Components library.  ","version":"Next","tagName":"h3"},{"title":"Search module​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#search-module","content":" ⚠️ Removal of the sq-breadcrumbs component (replaced by the Filters module).⚠️ Removal of the Breadcrumbs class.Scopes: The sq-scope component now properly handles default scopes or disabled scopes configured in the query web service.Tabs: The sq-tabs component can now have custom icons (rather than only text).SearchService: The service now enriches the Results object new properties computed by the SBA (eg. record.$isDuplicate, record.$duplicateCount, aggregation.$filtered etc.). These new pre-computed properties allow to simplify the logic of the SBA components and avoid code duplication.New optional SearchOptions: testDuplicates: A function that compares two documents and returns a boolean indicating whether they are duplicates (see the new sq-result-duplicates components).initializeResults: A functional that can be used to customize the Results object before it is used by the SBA components.initializeRecord: Similar to initializeResults but for a single record.initializeAggregation: Similar to initializeResults but for a single aggregation.  ","version":"Next","tagName":"h3"},{"title":"Theme toggle​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#theme-toggle","content":" ⚠️ Removed, because the user menu now includes a theme toggle by default.  ","version":"Next","tagName":"h3"},{"title":"Theme​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#theme","content":" ⚠️ Major refactoring of the Sinequa theme that was introduced in the 11.9.0 release. The theme is now more modular and more simply organized. It makes heavy usage of Bootstrap variables rather than overriding CSS rules. The theme is documented in the Components library.  ","version":"Next","tagName":"h3"},{"title":"Utils​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#utils","content":" The sqTooltip directive: now displays a custom template with the sqTooltipTemplate input.instead of a string, accepts a function that returns arbitrary data (asynchronously) to be displayed in this template. This allows fetching data from the server to display in the tooltip upon hovering an element.the tooltip can now be hoverable itself (rather than only the element that triggers the tooltip) with the hoverableTooltip input. This allows to display a tooltip with a link or button that can be clicked. Removed the sqExpr pipe (replaced by sq-filters). The UIService now handles whether the dark theme is on or off. New sq-virtual-scroller component that allows an infinite scroll behavior on a long list of data (e.g. the extracts of the preview).  ","version":"Next","tagName":"h3"},{"title":"Analytics​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#analytics","content":" All components that apply filters to the Query have been migrated to the new filter syntax (see above)  ","version":"Next","tagName":"h2"},{"title":"New Dashboard module​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#new-dashboard-module","content":" The Pepper dashboard has been extracted into a separate module @sinequa/analytics/dashboard and can be imported in any application. The content of the dashboard is still defined in the host application and can thus be customized easily. This new module is documented in the Analytics library.  ","version":"Next","tagName":"h3"},{"title":"Heatmap module​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#heatmap-module","content":" The heatmap component properly handles filtering and formatting of the data (entities, CSV, string, etc.) in both &quot;cooccurrence&quot; and &quot;cross-distribution&quot; modes.  ","version":"Next","tagName":"h3"},{"title":"Timeline module​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#timeline-module","content":" Integrated the timeline legend (sq-timeline-legend component) into the sq-timeline component instead of the sq-facet-component component. The inputs of the legend component are now inputs of the timeline component.The sq-facet-timeline component now handles timelines computed with hour or minute granularity (MASK parameter).The sq-timeline component now handles data points with a displayedDate property. This property allows to show on the same chart 2 timeseries from a different time range plotted against each other. This allows for example to compare the evolution of a metric for a year vs. the same metric for the previous year. The timeline tooltip displays the date information accordingly.  Application updates  ","version":"Next","tagName":"h3"},{"title":"Vanilla Search​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#vanilla-search","content":" Removed the logging of audit events from the AppComponent (now handled by the core library). Complete reorganization of the application CSS, based on the new Sinequa Theme (see above). The application behavior on small screens was also improved. Improved the Neural Search UI (based on @sinequa/components/machine-learning). Replaced the sq-facet-mysearch component with the new sq-filters-view (see above). Implemented the new visualization of duplicate documents (see above). Implemented the new sq-metadata component (see above). The configuration is defined in config.ts but can be overriden by the server without recompiling the application. Implemented the new sq-preview component (see above). The configuration is defined in config.ts but can be overriden by the server without recompiling the application. Refactored search form: Now based on the new sq-search-form component (see above). This removes a large portion of the complex logic that was previously implemented at the application level.New simpler app-autocomplete component (replacing the sqAutocompleteExtended directive), which can still be easily customized to add new sources of suggestions or modify the display of the suggestions.Removed the &quot;advanced search&quot; mode from the default UI. This can still be added back by customizing the search form component and using the components from @sinequa/components/advanced. Redesigned preview route: Now based on the refactoring of the preview module (see above).Improved minimap component (showing matches more accurately).Improved highlighting of long extracts (Now surrounded with a rectangle rather than highlighting the whole extract).Improved embedded tooltip look &amp; feel.Improved list of extracts (now displayed in a virtual scroller).Improved list of entities and query matches (with a refreshed look &amp; feel and auto storage of highlight preferences).  ","version":"Next","tagName":"h2"},{"title":"Pepper​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#pepper","content":" Removed the logging of audit events from the AppComponent (now handled by the core library). Complete reorganization of the application CSS, based on the new Sinequa Theme (see above). Replaced the sq-facet-mysearch component with the new sq-filters-view (see above). Implemented the new sq-preview component (see above). The configuration is defined in config.ts but can be overriden by the server without recompiling the application. The sq-facet-filters was removed from the application (replaced by the integrated search form) The previous search form was replaced by a new &quot;Integrated Search Form&quot;. This search form is based on the new sq-search-form component (see above) and allows to display facets and filters in addition to the autocomplete. The search form is documented in the Pepper documentation. The Pepper dashboard is now based on the new sq-dashboard component (see above). The dashboard customization process is documented in the Pepper documentation. The dashboard toolbar was simplified to only include the most useful actions: Collapse the search resultsAdd a new widgetImport or export the dashboard configurationClose the currently open previews Only one dashboard can be saved in the user settings (as opposed to a list of named dashboards)  ","version":"Next","tagName":"h2"},{"title":"LLM Integration​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#llm-integration","content":" The new sq-chat component (see above) allows to interact with a Large Language Model (LLM). This component was integrated in a custom version of Vanilla Search currently available on a separate branch of the repository (chatgpt-integration). On top of the chat itself, an &quot;assistant&quot; component acts as an interface between the Search interface and the chat (to perform Retrieval Augmented Generation). This application is documented in the LLM integration documentation.  ","version":"Next","tagName":"h2"},{"title":"Component-docs​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#component-docs","content":" Components-docs is a new application not meant to be used as a &quot;starter application&quot; (unlike Vanilla or Pepper). It is included for various technical reasons:  It is used to generate the interactive examples in the SBA documentation (using Angular Elements).It is used to quickly visualize and test components that are not included by default in Vanilla or Pepper.It is used to run the end-to-end tests of the SBA components with Cypress.  Note that the data used by this application can be either real data from a Sinequa server, or mocked data (included in the application itself).  ","version":"Next","tagName":"h2"},{"title":"Usage Analytics​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#usage-analytics","content":" Removed programmatically added boundaries of value 0 in timeline-typed widgets and updated the curve type used to draw the timeline.Disabled change selection on timeline zooming (to avoid unwanted selection changes when zooming in/out).Empty timeline-typed widgets are now displaying no data to display message.Added native plot of multiple time series from different queries in timeline-typed widgets.Changed the display of tooltips in timeline-typed widgets in order to fit the case of multiple time series charts.Added a toggle button to timeline-typed widgets to display time series of the preceding period.Enabled *Rename dashboard&quot; action in the dashboard toolbar.Fixed log errors when trying to switch from Chart to Grid view.Added a custom configuration to the column timestamp, in the default query configuration so that it will be automatically well-formatted.Enabled the feature to use multiple dataset web services in the same application. Queries having the same name are now overriden by the last one in the last dataset web service (from left to right).The dashboard service DashboardItemOption object now has proper typing for the parameters argument, enables typing each widget (timeline, chart, grid ...). New configuration interfaces are documented in the Usage analytics documentation.Added new type heatmap chart, based on sq-heatmap component (see above), allowing to display analytic indicator requesting cross-distribution.Added new type multi level pie chart, allowing to display hierarchical-tree indicator. This new component is documented in the Analytics library.Reorganized Palette of widgets and default dashboards.Refreshed look &amp; feel, based on the new Sinequa Theme (see above).Added link to a new Help page, including detailed informations and explanations of the overall context of the application.Help page and feedback buttons could be displayed or not, depending on the respective JSON configuration properties enableHelpPageLink and enableUserFeedbackMenu.Grid rows are now selectable (with a checkbox) and the selection is handled by onGridSelectionChanged() in the dashboard-item.component.ts.  ","version":"Next","tagName":"h2"},{"title":"Vanilla Builder​","type":1,"pageTitle":"General changes","url":"/dokku/docs/releases/release-11.10.0#vanilla-builder","content":" supports new metadata componentsupports new preview componentadd global configuration as a servicenew global configuratornew image selector configuratormove checkbox, color picker, image selector and multi-select components to the ngx-ui-builder library. Those components are now prefixed by uib_search-form component was renamed search-form-legacy  ⚠️ As the global configuration structure has changed, weird effects might occur with existing configuration. Specifically with images.  Before:  { &quot;id&quot;: &quot;...&quot;, &quot;logoLight&quot;: &quot;/assets/vanilla-logo.png&quot;, &quot;logoDark&quot;: &quot;/assets/vanilla-logo_dark.png&quot; }   After:  { &quot;id&quot;: &quot;...&quot;, &quot;images&quot;: { &quot;logoLight&quot;: {&quot;filename&quot;: &quot;/assets/vanilla-logo.png&quot; }, &quot;logoDark&quot;: { &quot;filename&quot;: &quot;/assets/vanilla-logo_dark.png&quot; } } }   When a previous configuration is detected, an automatic conversion will be done. In the case where this conversion doesn't work, just update manually the image using the builder. ","version":"Next","tagName":"h2"},{"title":"Custom entities","type":0,"sectionRef":"#","url":"/dokku/docs/tipstricks/entities","content":"","keywords":"","version":"Next"},{"title":"Back-end configuration​","type":1,"pageTitle":"Custom entities","url":"/dokku/docs/tipstricks/entities#back-end-configuration","content":" As in the previous chapter, you can configure an alias and an aggregation for your custom entity.  Additionally, you need to configure your Preview web service to highlight this new entity. This is done via the administration in Search-Based Applications &gt; Web Services &gt; Your preview configuration. Add your entity in Highlights to display:    ","version":"Next","tagName":"h2"},{"title":"Highlighting entities​","type":1,"pageTitle":"Custom entities","url":"/dokku/docs/tipstricks/entities#highlighting-entities","content":" If you open a document's HTML preview, your entity may not appear as highlighted (yet). You need to add some configuration, so that the entities marked with HTML tags are highlighted (eg. &lt;span class=&quot;person&quot;&gt;Barack Obama&lt;/span&gt;).  In Vanilla Search, you can find the default configuration in the config.ts file with the PREVIEW_HIGHLIGHTS constant:  config.ts export const PREVIEW_HIGHLIGHTS: PreviewHighlightColors[] = [ { name: 'company', color: 'white', bgColor: '#FF7675' }, { name: 'geo', color: 'white', bgColor: '#74B9FF' }, { name: 'person', color: 'white', bgColor: '#00ABB5' }, { name: 'extractslocations', color: 'black', bgColor: '#fffacd' }, { name: 'matchlocations', color: 'black', bgColor: '#ff0' } ];   The understanding is pretty straight forward, where we define that the classes of name name take color as text color and bgColor as background color.  This value is then passed by default to the Preview component if there is no config for previewHighlights in the AppService.  Just below in config.ts is the SELECTORS_HIGHLIGHTS constant which is used by the HighlightService to apply additional highlights to other components that require some. Note this can also be overridden if you configure the highlights parameter in the AppService.  config.ts export const SELECTORS_HIGHLIGHTS: {selectors: string[], highlights: PreviewHighlightColors[]}[] = [ { selectors: ['.sq-metadata-tooltip span', 'sq-preview-extracts-panel span'], highlights: PREVIEW_HIGHLIGHTS } ];   In this case, the same highlights than the Preview are applied to the spans in the sq-metadata-tooltip class (for the metadata entity tooltip) and in the sq-preview-extracts-panel component (inside the list of extracts next to the preview of a document).  ","version":"Next","tagName":"h2"},{"title":"Troubleshooting​","type":1,"pageTitle":"Custom entities","url":"/dokku/docs/tipstricks/entities#troubleshooting","content":" If you followed the above steps but cannot see highlights in the preview, consider the following failure cases:  Entities might not be indexed properly: In the inspector, look at the content of a record, and check whether it contains your entity:    Entities might not be highlighted by the preview web service: In the inspector, inspect the HTML preview to check whether your entities are properly surrounded by &lt;span&gt; tags:    You have not setup properly the JS and/or CSS files as described on the Preview Module page. Your CSS rules might be incorrect or overridden: Make sure that the &lt;span&gt; tags are properly targeted by the rules.   ","version":"Next","tagName":"h2"},{"title":"Debugging your SBA","type":0,"sectionRef":"#","url":"/dokku/docs/tipstricks/debugging","content":"","keywords":"","version":"Next"},{"title":"How to deal with runtime errors​","type":1,"pageTitle":"Debugging your SBA","url":"/dokku/docs/tipstricks/debugging#how-to-deal-with-runtime-errors","content":" Read the error message. The messages are not always clear and explicit but don't ignore them. After a while, you will recognize these errors and the solutions will become obvious with experience. Look in the error message for names of parameters and components from your app, or from the Sinequa libraries. If you recognize a name it's likely a good place to start investigating in your code. Google the error message. It's unlikely you are the only person having that problem. Google is likely to give you a lot of ideas on how to deal with the problem. However, some errors are too generic and don't put you in the right direction. Look at the linked source, if any. An error message often has a source file and line number linked on the right: If the source file is one of yours, it probably contains the error. If it is an Angular file, it probably means you misused an Angular feature at some point. You can also open a specific source file of your app (or from the Sinequa libraries) by exploring the tree in the Source tab. The sources of your app are normally under webpack:// &gt; . &gt; src, and the (compiled) sources of the Sinequa libraries under webpack:// &gt; C:\\... &gt; dist &gt; components/fesm2015 In the source, add a breakpoint before the point where the app failed and refresh your app to reach that breakpoint. When your app reached the breakpoint and paused, there are many things that you can try, such as: Looking for the values of variables in the scope, simply by hovering your mouse over these variables in the source code.Run JavaScript commands in the Console (you have access to the scope of the breakpoint).Keep executing the app step by step (buttons on the right). Look for failures in the Network tab. Failures are indicated in red. You often want to filter for XHR requests, which correspond to the interactions with the API (all the static resources are hidden). Both the requests and responses may contain interesting information. Inspect the state of your Angular component. You can easily select an Angular component by clicking on it in the Elements tab (and/or by use the selection tool). In the example above, the Angular component are easy to spot: they are the ones with non-standard HTML names (like &lt;div&gt;, &lt;span&gt;, etc.), and generally have a prefix (&lt;sq-...&gt; for Sinequa components, &lt;app-...&gt; for the components of your app). When an element is selected, you can access it with $0 in the console. If the selected element is an Angular component, you can get the instance of this component by typing ng.getComponent($0), which gives you access to all its fields and properties. ","version":"Next","tagName":"h2"},{"title":"Environments","type":0,"sectionRef":"#","url":"/dokku/docs/tipstricks/environment","content":"Environments In Angular, application environments allow you to specify different configurations for different build targets (typically dev, prod, staging, etc.). In the case of the Sinequa SBA Framework, the parameters which often need to be environment-specific are those of the StartConfig object: app: Name of the App configured on the serverauditEnabled: Whether or not to enable audit loggingautoSAMLProvider, autoOAuthProvider: Name of the login providers configured on the serverproduction: Whether the app is built for production or noturl: URL of the Sinequa server (if you are using CORS -- See Connecting to the Sinequa server). To take an example, let's say you have to develop your SBA with a Sinequa server at https://sinequa-dev.customer.com and you will deploy your production application on https://sinequa.customer.com. You may have something like the following: app.module.ts import { environment } from &quot;../environments/environment&quot;; export const startConfig: StartConfig = { url: environment.url, app: environment.app, production: environment.production, auditEnabled: environment.auditEnabled, autoSAMLProvider: environment.autoSAMLProvider }; environment/environment.ts export const environment = { url: &quot;https://sinequa-dev.customer.com&quot;, app: &quot;enterprise-search-app&quot;, auditEnabled: false, production: false }; (Notice that autoSAMLProvider is omitted, meaning we will use default login/password authentication in dev) environment/environment.prod.ts export const environment = { url: &quot;https://sinequa-prod.customer.com&quot;, app: &quot;enterprise-search-app&quot;, auditEnabled: true, production: true, autoSAMLProvider: &quot;enterprise-sso&quot; }; Note that the url parameter can be omitted if your application is hosted on the Sinequa server or if you use a proxy (the url will just be inferred from the browser URL). It can also be omitted if you use a proxy with ng serve (See Getting Started).","keywords":"","version":"Next"},{"title":"Exporting Standalone Components","type":0,"sectionRef":"#","url":"/dokku/docs/tipstricks/export-standalone","content":"","keywords":"","version":"Next"},{"title":"Creating an Angular Elements projects​","type":1,"pageTitle":"Exporting Standalone Components","url":"/dokku/docs/tipstricks/export-standalone#creating-an-angular-elements-projects","content":" An Angular Elements project is very similar to a regular Angular application project, with a few small differences.  For example, if you want to base your project on the Vanilla Search application, simply copy and rename the Vanilla Search project. You will also need to copy (and rename) the project declared in the angular.json file, and add a build command to the package.json file.  At this point the project is a clone of Vanilla Search.  Now the key difference between an &quot;Application project&quot; and an &quot;Elements project&quot; is what happens on startup. If you have a look at the main.ts file, you can see that it does essentially one thing: Bootstrap your AppModule (defined in app.module.ts). And if you look at the AppModule, you can see that it declares one bootstrap component, the AppComponent.  See the documentation of the bootstrap property:  bootstrap: The main application view, called the root component, which hosts all other app views. Only the root NgModule should set the bootstrap property.  In the case of an Angular Elements project, we do not want an application main view, and so we can remove the bootstrap property.  While we are at it, we can also completely remove the AppComponent from the rest of project (along with the other unneeded components from the original application). You can also remove the &lt;app&gt; element from the index.html file.  Instead of this bootstrap property, we are going to customize our AppModule class by adding a ngDoBootstrap() method where we declare the component(s) which we want to &quot;export&quot; as Custom Element(s):  import { NgModule, Injector} from &quot;@angular/core&quot;; import { createCustomElement } from '@angular/elements'; ... @NgModule({ imports: [ BrowserModule, FormsModule, ... ], declarations: [ SearchFormComponent, AutocompleteExtended, ... ], providers: [ ... ], //bootstrap: [ // AppComponent //] }) export class AppModule { constructor(private injector: Injector){ } ngDoBootstrap() { const searchForm = createCustomElement(SearchFormComponent, { injector: this.injector }); customElements.define('my-search-form', searchForm); } }   Now, you can build your application as usual with ng build. The output in the dist/ folder looks similar to a regular application build. The difference is you can now take the generated javascript files (main, polyfills and runtime), and put them into a different application. In order to instantiate your Angular component(s), simply use the name you defined in the ngDoBoostrap() method (note that this NOT the Angular selector of the component):  &lt;body&gt; ... &lt;my-search-form&gt;&lt;/my-search-form&gt; ... &lt;script src=&quot;runtime-es2015.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt; &lt;script src=&quot;polyfills-es2015.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt; &lt;script src=&quot;main-es2015.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt; &lt;/body&gt;   ","version":"Next","tagName":"h2"},{"title":"Other considerations​","type":1,"pageTitle":"Exporting Standalone Components","url":"/dokku/docs/tipstricks/export-standalone#other-considerations","content":" ","version":"Next","tagName":"h2"},{"title":"Inputs and Outputs​","type":1,"pageTitle":"Exporting Standalone Components","url":"/dokku/docs/tipstricks/export-standalone#inputs-and-outputs","content":" Note that it is also possible to pass inputs and listen to outputs to/from the element, much like in Angular, but now using native Browser syntax (See Mappings).  However, you probably want to make your components truly standalone (with no Input/Output), to avoid adding additional JavaScript logic on top of built components. The exception is of course if your components do need to exchange data with the third party application.  ","version":"Next","tagName":"h3"},{"title":"Wrapping​","type":1,"pageTitle":"Exporting Standalone Components","url":"/dokku/docs/tipstricks/export-standalone#wrapping","content":" You may want to export an existing component from the @sinequa/components libraries, but these components generally expect Inputs to work properly. For example, the sq-facet-list component expects at least a Results object (and the name of an aggregation, which can be static).  In order to export such a component, wrap it inside a new component which manages the data flow to/from other components of the project. In the case of the sq-facet-list component, it is simple: just inject the SearchService in the wrapper component and map the results to the child component.  @Component({ ..., template: ` &lt;sq-facet-list [results]=&quot;searchService.results&quot; [aggregation]=&quot;aggregation&quot;&gt;&lt;/sq-facet-list&gt;` }) export class FacetListWrapper { @Input() aggregation: string; constructor(public searchService: SearchService){} }   Then export the wrapper component in your app module:  const facet = createCustomElement(FacetListWrapper, { injector: this.injector }); customElements.define('my-facet', facet);   Now you can add facets to your 3rd party app with:  &lt;my-facet aggregation=&quot;Company&quot;&gt;&lt;/my-facet&gt;   ","version":"Next","tagName":"h3"},{"title":"Dependencies​","type":1,"pageTitle":"Exporting Standalone Components","url":"/dokku/docs/tipstricks/export-standalone#dependencies","content":" Your components will generally have dependencies other than the JavaScript libraries bundled in the main JS file. For example, you may need to include CSS files and assets (images, fonts, etc.). All these static files in the dist/ folder need to be copied to the target application and served appropriately.  ","version":"Next","tagName":"h3"},{"title":"Login​","type":1,"pageTitle":"Exporting Standalone Components","url":"/dokku/docs/tipstricks/export-standalone#login","content":" In order to use the Sinequa API, you need to be logged in. This means that at least one of your components will need to call loginService.login(). Your component can typically extend the ComponentWithLogin class from @sinequa/core/login to make this automatic.  ","version":"Next","tagName":"h3"},{"title":"CORS​","type":1,"pageTitle":"Exporting Standalone Components","url":"/dokku/docs/tipstricks/export-standalone#cors","content":" If you embed components in a third-party application, this application will probably have a URL different from the Sinequa server's URL. This means you will need to enable CORS in your WebApp configuration (See CORS and WebApp Configuration and Deploying an App on another server).  Note that CORS limits certain functionalities due to security restrictions in the browser. In order to get around CORS issues, consider using a proxy or reverse-proxy (so that the app is served from the same URL as the Sinequa REST API).  ","version":"Next","tagName":"h3"},{"title":"Optimization​","type":1,"pageTitle":"Exporting Standalone Components","url":"/dokku/docs/tipstricks/export-standalone#optimization","content":" In the example above, we start by copying the Vanilla Search application. In order to minimize the size of the resulting JavaScript files, you should try to keep only the modules that your component(s) need in your AppModule's imports (which should quite fewer than for an entire application). ","version":"Next","tagName":"h3"},{"title":"Combining D3 and Angular","type":0,"sectionRef":"#","url":"/dokku/docs/tipstricks/d3-angular","content":"","keywords":"","version":"Next"},{"title":"What is D3.js​","type":1,"pageTitle":"Combining D3 and Angular","url":"/dokku/docs/tipstricks/d3-angular#what-is-d3js","content":" The Data-Driven Documents (D3) library is one of the most popular libraries for producing interactive charts. There are many samples of charts available on the Internet, which can be reused in an Angular application.  Most charting libraries, like ngx-charts or Highcharts, package many pre-defined charts that can be configured with a bunch of options. The problem with this approach is that there are many degrees of freedom when building an interactive chart, and no amount of options can handle them all. At some point you will need to do something that wasn't forseen by the component's designer.  For this reason, D3 does not package any pre-defined chart. Instead, it packages many primitives and algorithms to efficiently build exactly the custom chart that you need. This approach is very powerful, especially when looking at the huge variety of D3's gallery of visualization, none looking like another.  The drawback is that D3 is difficult to learn and to use. Even after working with it for a long time, you can be easily confused by its complex code, especially when charts grow in complexity (multiple &quot;behaviors&quot;, transition, update mechanism, etc.).  If you want to learn about D3, their latest tutorial covers a lot of the key concepts and can be done completely online.  ","version":"Next","tagName":"h2"},{"title":"D3 concepts​","type":1,"pageTitle":"Combining D3 and Angular","url":"/dokku/docs/tipstricks/d3-angular#d3-concepts","content":" D3 essentially draws charts as Scalable Vector Graphics (SVG) and everything revolves around modifying these SVG and listening to users mouse and keyboard interactions on these SVG.  It is important to be relatively familiar with the SVG language to understand D3 generally and this page in particular.  For example, the following SVG code renders as follow:  &lt;svg width=&quot;200&quot; height=&quot;200&quot; style=&quot;background-color: #eee;&quot;&gt; &lt;rect x=&quot;30&quot; y=&quot;100&quot; width=&quot;50&quot; height=&quot;80&quot; fill=&quot;#d00&quot;&gt;&lt;/rect&gt; &lt;rect x=&quot;80&quot; y=&quot;50&quot; width=&quot;50&quot; height=&quot;130&quot; fill=&quot;#0d0&quot;&gt;&lt;/rect&gt; &lt;rect x=&quot;130&quot; y=&quot;20&quot; width=&quot;50&quot; height=&quot;160&quot; fill=&quot;#00d&quot;&gt;&lt;/rect&gt; &lt;/svg&gt;   &lt;svg width=&quot;200&quot; height=&quot;200&quot; style=&quot;background-color: #eee;&quot;&gt; &lt;rect x=&quot;30&quot; y=&quot;100&quot; width=&quot;50&quot; height=&quot;80&quot; fill=&quot;#d00&quot;&gt;&lt;/rect&gt; &lt;rect x=&quot;80&quot; y=&quot;50&quot; width=&quot;50&quot; height=&quot;130&quot; fill=&quot;#0d0&quot;&gt;&lt;/rect&gt; &lt;rect x=&quot;130&quot; y=&quot;20&quot; width=&quot;50&quot; height=&quot;160&quot; fill=&quot;#00d&quot;&gt;&lt;/rect&gt; &lt;/svg&gt;   This is exactly the kind of SVG that D3 can generate, except of course it normally generates them with JavaScript code.  In most examples you see online, the SVG actually starts empty and is populated with elements programmatically.  For example, to reproduce the example above:  &lt;!-- An empty SVG --&gt; &lt;svg id=&quot;my-svg&quot;&gt;&lt;/svg&gt; &lt;script&gt; const svg = d3.select(&quot;#my-svg&quot;) .attr(&quot;width&quot;, 200) // Set the attributes of the SVG element .attr(&quot;height&quot;, 200) .style(&quot;background-color&quot;, &quot;#eee&quot;); svg.append(&quot;rect&quot;) // Create a &lt;rect&gt; element .attr(&quot;x&quot;, 10) // Set each attribute of the new &lt;rect element&gt; .attr(&quot;y&quot;, 100) .attr(&quot;width&quot;, 50) .attr(&quot;height&quot;, 80) .attr(&quot;fill&quot;, &quot;#d00&quot;); // etc. for the 2 other rects &lt;/script&gt;   Of course, in practice what you want to plot on the screen is data, which unfortunately is not measured on a scale of pixels. So we need to somehow transform our data into proportionate numbers for our x, y, width, height, and even fill attributes. This is where D3 starts to come in handy, with the concept of Scale (See d3-scale).  Let's say the data from the chart above is in fact defined as below:  const data = [ {label: 'banana', value: 0.8}, {label: 'apple', value: 1.3}, {label: 'strawberry', value: 1.6} ];   Let's refactor the example above using D3 scales:  // Create a scale for the X axis, that maps each label to a range of pixels const xScale = d3.scaleBand() .domain(data.map(d =&gt; d.label)) // ['banana', 'apple', 'strawberry'] .range([30, 190]) // The first bar will start at 30px, and the last will end at 190px // Create a scale for the Y axis, that maps each numerical value to a pixel dimension const yScale = d3.scaleLinear() .domain([0, d3.max(data, d =&gt; d.value)]) // The Y axis will always start at 0 .range([180, 20]) // The 0 is mapped to 180px (the bottom of the chart - 20px for margin) and the max is mapped to 20px (the height of the chart + 20px for margin) // Create a scale for the colors. Each index will yield a different color const colorScale = d3.scaleOrdinal(d3.schemeCategory10); // Now we can build our &lt;rect&gt; in a for-loop! for(let i=0; i&lt;data.length; i++) { svg.append(&quot;rect&quot;) .attr(&quot;x&quot;, xScale(data[i].label)) .attr(&quot;y&quot;, yScale(data[i].value)) .attr(&quot;width&quot;, xScale.bandwidth()) .attr(&quot;height&quot;, yScale(0) - yScale(data[i].value)) .attr(&quot;fill&quot;, colorScale(i)); }   This generates the following SVG:    Note that the code above generalizes for any amount and scale of data and SVG dimensions.  If you are familiar with D3, the for-loop probably looks at bit strange to you. Indeed, the idiomatic way of writing it with D3 would be instead:  svg.selectAll(&quot;.bar&quot;) .data(data) // We are &quot;attaching&quot; the data to DOM elements .enter() // Here we select only the elements that enter the DOM .append(&quot;rect&quot;) // For each new element, we insert a &lt;rect&gt; .attr(&quot;class&quot;, &quot;bar&quot;) .attr(&quot;x&quot;, d =&gt; xScale(d.label)) // Works as before, except we access the data with arrow functions .attr(&quot;y&quot;, d =&gt; yScale(d.value)) .attr(&quot;width&quot;, xScale.bandwidth()) .attr(&quot;height&quot;, d =&gt; yScale(0) - yScale(d.value)) .attr(&quot;fill&quot;, (d,i) =&gt; colorScale(i));   This syntax is a lot more powerful for reasons that become clear when you use more advanced features of D3.  While we're here, let's use D3's axes primitives to nicely visualize our labels and numerical values:  svg.append(&quot;g&quot;) // Create a new &lt;g&gt; element .attr(&quot;transform&quot;, `translate(0, 180)`) // Move it to the bottom .call(d3.axisBottom(xScale)); // Turn it into an axis svg.append(&quot;g&quot;) // Create a new &lt;g&gt; element .attr(&quot;transform&quot;, `translate(30, 0)`) // Move it to the left of the chart .call(d3.axisLeft(yScale)); // Turn it into an axis     This is D3's most basic example. There are many other primitives and algorithms, but in the end it always comes down to manipulating the DOM in an efficient way.  But, let's stop here for a second... Because Angular is also really good at manipulating the DOM. Unlike D3, Angular does not force you to create and modify every DOM element programmatically by writing JavaScript. Instead, Angular uses a template language which manages a lot of the functionalities of D3 selections, but in a way that is a lot more expressive and pleasant.  ","version":"Next","tagName":"h2"},{"title":"Leveraging Angular​","type":1,"pageTitle":"Combining D3 and Angular","url":"/dokku/docs/tipstricks/d3-angular#leveraging-angular","content":" Instead of creating our &lt;rect&gt; elements programmatically, let's use Angular's template language:  &lt;svg width=&quot;200&quot; height=&quot;200&quot; style=&quot;background-color: #eee;&quot;&gt; &lt;rect *ngFor=&quot;let d of data; let i=index&quot; [attr.x]=&quot;xScale(d.label)&quot; [attr.y]=&quot;yScale(d.value)&quot; [attr.width]=&quot;xScale.bandwidth()&quot; [attr.height]=&quot;yScale(0) - yScale(d.value)&quot; [attr.fill]=&quot;colorScale(i)&quot;&gt; &lt;/rect&gt; &lt;/svg&gt;   This descriptive approach has various advantages:  It is a lot more expressive than the equivalent code based on d3.select(). What you see is what you get. There is no risk of forgetting to call a .select() or an .append(). A new developer reading this understands immediately what is going on.This code updates automatically and efficiently when the data and scales change. Angular takes care of adding or remove the necessary DOM elements for you, whereas the equivalent task is non-trivial when you need to do it programmatically.This removes a significant part of the code from your component and makes it easier to debug and maintain.  Let's see how this component's controller looks like:  @Component({ selector: 'my-chart', templateUrl: 'my-chart.html' // Template shown above }) export class MyChart { @Input() data; xScale = d3.scaleBand().range([30, 190]); yScale = d3.scaleLinear().range([180, 20]); colorScale = d3.scaleOrdinal(d3.schemeCategory10); /** * When the data changes, we only need to update our scales, * and the template will magically update! * */ ngOnChanges() { this.xScale.domain(this.data.map(d =&gt; d.label)); this.yScale.domain([0, d3.max(this.data, d =&gt; d.value)]); } }   You'll notice the chart does not contain axes. This is because axes are complex and cannot be easily replaced by Angular template syntax. However, we can still leverage Angular to simplify things.  Let's start by adding and positioning the two &lt;g&gt; elements that will contain the X and Y axes:  &lt;svg width=&quot;200&quot; height=&quot;200&quot; style=&quot;background-color: #eee;&quot;&gt; &lt;rect *ngFor=&quot;let d of data; let i=index&quot; [attr.x]=&quot;xScale(d.label)&quot; ...&gt; &lt;/rect&gt; &lt;g #xAxis transform=&quot;translate(0, 180)&quot;&gt;&lt;/g&gt; &lt;g #yAxis transform=&quot;translate(30, 0)&quot;&gt;&lt;/g&gt; &lt;/svg&gt;   Notice the #xAxis and #yAxis identifiers. We can use them to retrieve these elements in the controller:  @ViewChild(&quot;xAxis&quot;) gx: ElementRef; @ViewChild(&quot;yAxis&quot;) gy: ElementRef;   Now we can draw our axes with:  drawAxes() { d3.select(this.gx.nativeElement) .call(d3.axisBottom(this.xScale)); d3.select(this.gy.nativeElement) .call(d3.axisLeft(this.yScale)); }   However, there is an issue here: The gx and gy elements will be undefined until the DOM is first rendered, and ngOnChanges() gets called before that! This is why we need to use ngAfterViewInit(), which runs once after the template is first rendered:  ngOnChanges() { this.xScale.domain(this.data.map(d =&gt; d.label)); this.yScale.domain([0, d3.max(this.data, d =&gt; d.value)]); if(this.gx){ // We draw the axes unless the view hasn't yet been rendered this.drawAxes(); } } ngOnAfterViewInit() { if(this.data) { // We draw the axes if there's any data (ie. the scales have been initialized in ngOnChanges()) this.drawAxes(); } }   ","version":"Next","tagName":"h2"},{"title":"Methodology​","type":1,"pageTitle":"Combining D3 and Angular","url":"/dokku/docs/tipstricks/d3-angular#methodology","content":" ","version":"Next","tagName":"h2"},{"title":"1) Component scope​","type":1,"pageTitle":"Combining D3 and Angular","url":"/dokku/docs/tipstricks/d3-angular#1-component-scope","content":" In Angular you can design tiny components that do very few things or large components that do a lot of things.  In the case of charts, a good pattern is that your component should take the data as an Input(), without including interactions with the server (if the data needs to be refreshed from the server, because of user interactions, you can create a parent component that takes care of this). Your component should be in charge of drawing a SVG, updating that SVG when the data changes and emitting events when users interact with the data.  The good thing about having the data as an input is that Angular will call ngOnChanges() and refresh the view just when you need it.  ","version":"Next","tagName":"h3"},{"title":"2) Mock-up​","type":1,"pageTitle":"Combining D3 and Angular","url":"/dokku/docs/tipstricks/d3-angular#2-mock-up","content":" When you want to develop a new chart, a good idea is to first write a mock SVG manually, to list the elements the you need and how they should be positioned together.  It is even easier if you start from an example you find online: the whole structure is available if you just inspect the SVG element.  ","version":"Next","tagName":"h3"},{"title":"3) Declarative vs. Programmatic​","type":1,"pageTitle":"Combining D3 and Angular","url":"/dokku/docs/tipstricks/d3-angular#3-declarative-vs-programmatic","content":" Some elements need to be created programmatically, like the axes in our example above. This is the case every time you see the pattern .select(...).call(some D3 primitive). The call() function means the D3 functionality is packaged as a function that modifies existing DOM element(s) (by adding sub-elements, or adding listeners, etc.). In this case, use a container element with an id as we did above for the axes. You can then access the native element by using @ViewChild and then call the D3 primitive.  Apart from these special elements, you should generally write the SVG declaratively, as a regular Angular template, using *ngFor and *ngIf to create the right number of elements in the right place, as we did for the &lt;rect&gt; elements above.  The template might look like this for a multi-line chart:  &lt;svg [attr.viewBox]=&quot;'0 0 '+width+' '+height&quot;&gt; &lt;g [attr.transform]=&quot;'translate('+this.margin.left+','+ margin.top +')'&quot;&gt; &lt;!-- One path per series. line is a d3 shape primitive defined in the controller --&gt; &lt;path *ngFor=&quot;let series of data&quot; [attr.d]=&quot;line(series)&quot;&gt; &lt;/path&gt; &lt;!-- Containers for &quot;special&quot; elements --&gt; &lt;g #xAxis class=&quot;axis&quot;&gt;&lt;/g&gt; &lt;g #yAxis class=&quot;axis&quot;&gt;&lt;/g&gt; &lt;/g&gt; &lt;/svg&gt;   ","version":"Next","tagName":"h3"},{"title":"4) Pseudo code​","type":1,"pageTitle":"Combining D3 and Angular","url":"/dokku/docs/tipstricks/d3-angular#4-pseudo-code","content":" It is easy to write D3 code that looks a bit like a plate of spaghetti, where it's hard to tell if the methods are called once or many times, and how they relate to each other.  Generally, this is the structure your component should have:  export class MyChart { // The data type here is for a multiline chart @Input() data: {x: number, y: number}[][]; // You can have many settings if needed. A good practice is to defined default values @Input() width = 200; @Input() height = 200; @Input() margin = {top: 20, bottom: 20, left: 20, right: 20}; // Container(s) for the &quot;special&quot; elements (that need to be created programmatically) @ViewChild(&quot;xAxis&quot;) xAxis: ElementRef; @ViewChild(&quot;yAxis&quot;) yAxis: ElementRef; // Scales, shapes, behaviors, etc. which need to be used in the template. x; y; line; // Called first constructor() { // Initialize the scales, shapes behaviors // Note: Using ngOnInit is potentially risky as it gets called AFTER the first ngOnChanges() this.x = d3.scaleLinear() .range([0, this.innerWidth]); this.y = d3.scaleLinear() .range([this.innerHeight, 0]); this.line = d3.line() .x(d =&gt; this.x(d.x)) .y(d =&gt; this.y(d.y)); } // Called second (and every time data or settings are changed) ngOnChanges() { // Update primitives that depend on the data (computation of min/max not shown) this.x.domain([minX, maxX]); this.y.domain([minY, maxY]); // If the view has been rendered already if(this.xAxis) { this.redrawSpecialElements(); } } // Called third (and only once) ngAfterViewInit() { // Some &quot;special&quot; elements only need to be drawn once and for all (eg. a Brush or Zoom behavior, or a fixed-scale axis). // This can be done here. // No need to draw the chart if there is no data yet if(this.data) { this.redrawSpecialElements(); } } redrawSpecialElements() { // Re-draw special elements d3.select(this.xAxis.nativeElement) .call(d3.axisBottom(this.x)); d3.select(this.yAxis.nativeElement) .call(d3.axisLeft(this.y)); } // Helper methods for the inner dimension of the chart (removing the margins) get innerWidth(): number { return this.width - this.margin.left - this.margin.right; } get innerHeight(): number { return this.height - this.margin.top - this.margin.bottom; } }   ","version":"Next","tagName":"h3"},{"title":"5) Interactions​","type":1,"pageTitle":"Combining D3 and Angular","url":"/dokku/docs/tipstricks/d3-angular#5-interactions","content":" You can add many types of interactions to a chart.  The most simple ones are CSS effects applied on hover. These effects can be animated with transitions. For example:  .line { opacity: 0.6; } .line:hover { opacity: 1; transition: opacity 0.2s ease-in 0s; }   Then there are effects that require event listeners and callbacks. Here we can use typical event listeners, such as (mouseenter), (mousemove), (mouseleave) or (click). For example, we can listen to a user click on a bar (of the bar chart from our first example).  &lt;rect *ngFor=&quot;let d of data; let i=index&quot; [attr.x]=&quot;xScale(d.label)&quot; [attr.y]=&quot;yScale(d.value)&quot; [attr.width]=&quot;xScale.bandwidth()&quot; [attr.height]=&quot;yScale(0) - yScale(d.value)&quot; [attr.fill]=&quot;colorScale(i)&quot; (click)=&quot;onClick(d)&quot;&gt; &lt;!-- Notice the (click) callback --&gt; &lt;/rect&gt;   And in the controller:  onClick(d: {label: string, value: number}) { // We can do anything with the data that was clicked on! // Including modifying the data itself, which would cause the view to be redrawn. console.log(d); }   Then, there are more complex interactions, like D3 zoom, brush or drag, which involve multiple listeners (to monitor mouse wheel, mouse click, movement, etc.). These interactions cannot be easily implemented in our template. Like the axes in the example above, we need to apply these behaviors programmatically to an existing DOM element.  For example, we can create a zoom behavior, and apply it to our SVG element:  &lt;svg #mysvg&gt; ... &lt;/svg&gt;   With:  @ViewChild(&quot;mysvg&quot;) svg; ngOnAfterViewInit() { // We create a Zoom behavior and apply it to the SVG element // The onZoom method is called when the user &quot;zooms&quot; (scroll with the mouse wheel) over the SVG const zoom = d3.zoom() .on(&quot;zoom&quot;, () =&gt; this.onZoom()); d3.select(this.svg.nativeElement) .call(zoom); } onZoom() { const transform = d3.zoomTransform(this.svg.nativeElement); // The transform object allows us to either transform elements directly // For example: d3.select(svg).attr(&quot;transform&quot;, transform) // Or modify our scales, which will redraw the shapes in our template automatically this.x = transform.rescaleX(this.x); // Since we modify the X axis, we do need to redraw the axis programmatically // (because they axes are created programmatically in the first place, not via templating) d3.select(this.xAxis.nativeElement) .call(d3.axisBottom(this.x)); }   ","version":"Next","tagName":"h3"},{"title":"6) Transitions​","type":1,"pageTitle":"Combining D3 and Angular","url":"/dokku/docs/tipstricks/d3-angular#6-transitions","content":" D3 also provides a powerful API for transitioning elements smoothly between states. For example, when the data changes, you may want to animate the shapes (lines, paths, etc.) from their previous locations to the new ones. If the scale is changed following the data change, you would also animate the axes.  For example:  // We modify the X scale because of new data this.x.domain([newMin, newMax]); d3.select(this.xAxis.nativeElement) // Select the axis .transition() // Create a transition .duration(1000) // Which lasts for 1000ms .call(d3.axisBottom(this.x)); // Animate the axis from its current state to the new state (using the updated X domain).   Unfortunately transitions can only be applied to D3 selections, which at first seems like this approach is incompatible with the declarative approach described above.  Note that Angular also has a transition API which can be used to transition between different states. This approach can be quite powerful, but it is limited to CSS styles,(for example transitioning from opacity 0 to 1 when an element is created). It doesn't seem currently possible to transition attributes, like the x and y coordinates of SVG primitives.  There is a workaround to apply a real D3 transition to the elements declared in our Angular template. Notice that the elements depend on the scale objects. So every time we modify a scale, Angular redraws the elements. In the example above we change the scale instantaneously, which means the elements transition instantaneously too. But it is possible to modify the scale at every step of the transition, which means Angular will update our SVG elements at every step too!  This looks as follows (using the same example as before):  // Store the old domain const oldDomain = this.x.domain(); // We modify the X scale because of new data this.x.domain([newMin, newMax]); // Create an interpolator for our domain const interpolator = d3.interpolateArray(oldDomain, this.x.domain()); d3.select(this.xAxis.nativeElement) // Select the axis .transition() // Create a transition .duration(1000) // Which lasts for 1000ms .tween(&quot;domain interpolation&quot;, () =&gt; (t) =&gt; { this.x.domain(interpolator(t)); // At every step of the transition we update the X scale's domain }) .call(d3.axisBottom(this.x)); // Animate the axis from its current state to the new state (using the updated X domain).   With the above workaround, not only is the X axis smoothly transitioning between 2 domains, but also will any shape which directly or indirectly depends on the x scale!  As a last recommendation, be careful to never mix transitions and User interactions. If you start a transition, but in the meantime the user can zoom in and out, moving some elements, you will most definitely have a conflict, which may result in an unknown intermediate state.  If your chart contains interactions and transitions, be sure to turn off interactions before starting the transitions and turn them back on after. ","version":"Next","tagName":"h3"},{"title":"Custom Metadata","type":0,"sectionRef":"#","url":"/dokku/docs/tipstricks/metadata","content":"","keywords":"","version":"Next"},{"title":"Back-end configuration​","type":1,"pageTitle":"Custom Metadata","url":"/dokku/docs/tipstricks/metadata#back-end-configuration","content":" It is not the best practice to expose index column names in the front-end. You can assign an alias to this column, along with some useful descriptors. This is done in the administration under Search-Based Applications &gt; Web Services &gt; Your query &gt; Advanced tab &gt; Column Aliases.    Now, your parameter is accessible under record['category']. The alias is used throughout the configuration of the SBA.  While we are configuring the Query, we can also create an aggregation to feed our facet of categories. In the General tab, add a new line under the Aggregations table. Give it a meaningful name, like &quot;Categories&quot; and set the name of the column to your alias category. Optionally edit the configuration of your aggregation for more options:    Read more about aggregations to configure these (optional) advanced parameters. Note that if you leave Include in standard search checked, it means the distribution will be computed along with any query, which may come with a performance cost.  ","version":"Next","tagName":"h2"},{"title":"Displaying the value​","type":1,"pageTitle":"Custom Metadata","url":"/dokku/docs/tipstricks/metadata#displaying-the-value","content":" Your application probably displays results in a for-loop. In Hello Search, it looks like this:  app.component.html &lt;div *ngFor=&quot;let record of results.records&quot; class=&quot;record&quot;&gt; &lt;a href=&quot;{{record.url1}}&quot;&gt; &lt;h3 [innerHtml]=&quot;record.displayTitle || record.title&quot;&gt;&lt;/h3&gt; &lt;/a&gt; &lt;div class=&quot;source&quot;&gt;{{record.url1}}&lt;/div&gt; &lt;p *ngIf=&quot;record.relevantExtracts&quot; [innerHTML]=&quot;record.relevantExtracts&quot;&gt;&lt;/p&gt; &lt;/div&gt;   You can directly display the value with something like:  app.component.html &lt;span&gt;{{ record['category'] }}&lt;/span&gt;   For something more sophisticated, which can include a label and an icon, you can try using the Metadata component:  app.component.html &lt;sq-metadata [record]=&quot;record&quot; [config]=&quot;metadata&quot;&gt; &lt;/sq-metadata&gt;   With a configuration like:  app.component.ts this.metadata: MetadataConfig[] = [ { field: &quot;category&quot;, // the field in the record label: &quot;Category&quot;, // the label to put in front of the value, it can be a key to use with sqMessage icon: &quot;far fa-file-alt&quot; // the Fontawesome class, you can find all available icons at https://fontawesome.com/v5/search } ];   ","version":"Next","tagName":"h2"},{"title":"Custom formatter​","type":1,"pageTitle":"Custom Metadata","url":"/dokku/docs/tipstricks/metadata#custom-formatter","content":" If this metadata is stored in the index in a format that needs to be processed to be displayed, it is possible to specify a custom formatter.  First of all, choose a name for the formatter, like &quot;prettifyCategory&quot;. Set this name in the &quot;formatter&quot; column in the Advanced tab of your Query configuration.    This custom formatter needs to be implemented in your Angular application. This is done by overriding the FormatService. An example is provided in the documentation of the App Utils modules.  Create your extension of the FormatService in your app. my-format.service.ts @Injectable({ providedIn: 'root' }) export class MyFormatService extends FormatService { } Implement your custom formatter by overriding the formatValue() method. The valueItem input contains the raw value stored in the index, and the column contains the properties of the index column corresponding to each metadata. my-format.service.ts // Add support for a custom formatter formatValue(valueItem: ValueItem | FieldValue, column?: CCColumn): string { if (column &amp;&amp; column.formatter === 'prettifyCategory') { ... return &quot;The formatter category&quot; } return super.formatValue(valueItem, column); } In your app.module.ts, provide your custom FormatService: app.module.ts @NgModule({ ..., providers: [ ..., { provide: FormatService, useClass: MyFormatService } ] })   Your metadata will be automatically formatted in the built-in components, such as sq-metadata, sq-facet-list, etc. But if you want to format your custom value in your own template, this can be achieve with the sqValue pipe:  &lt;strong&gt;Category:&lt;/strong&gt; {{ record['category'] | sqValue:column}}   Notice that the sqValue pipe requires a column value as a parameter. This object can be retrieved with the following call:  this.column = this.appService.getColumn('category');   (Basically getColumn() returns the configuration of this index column, which includes the name of its formatter.)  ","version":"Next","tagName":"h2"},{"title":"Displaying a list facet​","type":1,"pageTitle":"Custom Metadata","url":"/dokku/docs/tipstricks/metadata#displaying-a-list-facet","content":" If you configured an aggregation in the back-end configuration, you can first check that the data is correctly computed and available in the results. In the inspector, checkout the list of aggregations:    If your aggregation is in the list and not empty, you can display a facet list component as in the tutorial:  &lt;sq-facet-card [title]=&quot;'Categories'&quot; [icon]=&quot;'fas fa-tag'&quot;&gt; &lt;sq-facet-list #facet [results]=&quot;results&quot; [aggregation]=&quot;'Categories'&quot;&gt;&lt;/sq-facet-list&gt; &lt;/sq-facet-card&gt;   ","version":"Next","tagName":"h2"},{"title":"Filtering the results​","type":1,"pageTitle":"Custom Metadata","url":"/dokku/docs/tipstricks/metadata#filtering-the-results","content":" Both the sq-metadata component and the sq-facet-list components let you filter the results based on the value of metadata (for sq-metadata, with the filterable and excludable parameters from MetadataConfig).  Alternatively, you can apply these filters yourself by modifying the Query object and requesting new results to the server. To do so, you can use the SearchService (from @sinequa/components/search):  this.searchService.query.addFilter({field: 'category', value: &quot;&lt;a category&gt;&quot;}) // Apply the filter (to the Query) this.searchService.search(); // Request results to the server (with the new query)  ","version":"Next","tagName":"h2"},{"title":"Server-side Plugins","type":0,"sectionRef":"#","url":"/dokku/docs/tipstricks/plugins","content":"","keywords":"","version":"Next"},{"title":"Query Plugins​","type":1,"pageTitle":"Server-side Plugins","url":"/dokku/docs/tipstricks/plugins#query-plugins","content":" A QueryPlugin is a C# plugin deployed on the Sinequa server and assigned to a specific Query web service configuration.    The Query web service has a rich API which can be used in many different ways. Unlike other plugins, the QueryPlugin is NOT a class with blank hook methods called by the main web service. Instead, the plugin class implements a large part of the logic of the web service, and this QueryPlugin class is always used by the web service, even when you don't create a plugin. When you do create a QueryPlugin, you are overriding the service's behavior directly (not just hooking into it).  It is also important to know that other web services make use of the QueryPlugin. For example the Query Export web service need to fetch data in a way that is consistent with the Query web service, before exporting that data.  The QueryPlugin has many methods which can be overriden, and we cannot go in the details of all of them here. However, we can split these methods in the following categories:  Initialization: These methods initialize the properties of the QueryPlugin class in function of the user's query. The query object sent by the client corresponds to the Query type, which is used throughout the SBA framework.Before Search: These methods can be overriden to modify the way the SQL query is built (eg. to add, remove or modify specific SQL clauses).After Search: These methods can be overriden to post-process the results of the SQL query and/or modify how these results are writen in the JSON response.  The complete API of the QueryPlugin is listed on Sinequa's documentation website.  Note that within a QueryPlugin, you have access to various useful objects, in particular:  this.Request: The query object (a Json object) that this web service is responding to. It is possible to access any sub property of the query (which can include non-standard properties, added specifically for the purpose of customization).this.Response: The response returned by the web service (a Json object). It is possible to modify any property of this response. Note that, depending on the method you override, this.Response might not always have the same content (for example, if you override a &quot;before search&quot; method, the response does not contain any data yet). From the front-end point of view, this response is read as a Results object.  ","version":"Next","tagName":"h2"},{"title":"Initialization methods​","type":1,"pageTitle":"Server-side Plugins","url":"/dokku/docs/tipstricks/plugins#initialization-methods","content":" The initialization methods start with the prefix Init. The following methods are called in succession by the main Init() method (which itself may be overriden):  InitAction(): Initializes the Action member from the query (no action means this is a regular search query; &quot;open&quot; is a specific type of query for obtaining the nested values in a tree aggregation; &quot;aggregate&quot; is a specific type of query for computing a given list of aggregations, with custom settings).InitAggregations(): Initializes the Aggregations member from the query and the aggregations defined in the Query web service configuration.InitOpenAggregations(): Initializes the OpenAggregations member when the query action is &quot;open&quot;.InitEngineClient(): Sets the Client member to an instance taken from the pool if it has not already been set. Also sets Indexes and IndexList.InitConditions(): Initializes the Conditions member based on the full text, select or open conditions and advanced conditions specified in the query (sub-methods: InitSelectConditions(), InitAdvancedConditions() and PreProcessConditions()).InitTabSearch(): Initializes the TabSearch member based on the Query configuration.InitScope(): Initializes the Scope member based on the scope value in the query and the web service configuration.InitIds(): Initializes the Ids member based on the ids value in the query.InitBasket(): Initializes the Basket member based on the basket value in the query.InitTab(): Initializes the Tab&quot; member based on the tab value in the query.  It is rarely needed to override these methods, and more common to override the following ones (which actually perform some actions).  ","version":"Next","tagName":"h3"},{"title":"Before Search methods​","type":1,"pageTitle":"Server-side Plugins","url":"/dokku/docs/tipstricks/plugins#before-search-methods","content":" The methods that build the SQL query sent to the engine start with the prefix Add. The ToSql() method calls ToSqlInternal(), which calls in sequence the methods responsible for each sub-part of the query. These methods are themselves subdivided as follows:  AddSelect(): Adds the SELECT clause of the SQL query AddTabSearchDistribution(): Used when tab search is active, to compute the counters displayed for each tab.AddStandardColumns(): Adds the columns of the index to the query.AddRelevanceColumns(): Adds the columns specific to a full text search (where relevance is computed), such as globalrelevance and matchlocations, extractlocations clauses.AddGroupCountColumn(): Adds the groupcount column when a GROUP BY clause is active.AddQueryColumns(): Adds columns defined in the query.AddAdditionalSelectClause(): Adds columns defined in the Query web service configuration.AddOpenAggregations(): Adds the aggregation clause when the action is &quot;open&quot; (not used in regular search queries, only when the user &quot;opens&quot; a collapsed node in a tree facet).AddAggregations(): Adds all the aggregations configured as &quot;included in standard search&quot; (unless specific actions like &quot;open&quot; or &quot;aggregate&quot;). AddAggregation(): Adds one aggregation, based on its configuration in the Query web service. AddFrom(): Adds the FROM clause of the SQL query, based on the list of index specified in the Query web service configuration.AddWhere(): Adds the WHERE clause of the SQL query AddBasketIds(): Adds the list of ids present in a basket (when a basket is requested in the query).AddTextContains(): Adds the &quot;text contains&quot; clause (when text is requested in the query).AddProcessEntities(): Adds the &quot;process-entities&quot; clause (when configured in the web service configuration).AddIds(): Adds the list of ids (when ids are request in the query)AddGlobalSelections(): Adds configured &quot;global selections&quot;. Global selections can be set on for the treepath and collection columns.AddConditions(): Adds any metadata selection specified in the search text. Such selections can be specified using the Sinequa fielded search syntax.AddTabSelection(): Adds the tab selection, if any. This is called both when building the tab and main query. For the tab query all possible tab values will be included. For the main query the values for the currently selected tab will be included.AddScope(): Adds the scope, if any. Scopes can be configured on the query in the administration console (similar to tabs, with more flexibility).AddAdditionalWhereClause(): Adds the configured &quot;additional where clause&quot;, if any.AddRelevanceParameters(): Adds the relevance-related clauses. This methods calls a long list of other methods, each responsible for an individual clause: AddClassicSpellingCorrection(), AddDocumentWeight(), AddTextPartWeights(), AddRelevanceTransforms(), AddSynonyms(), AddReformulations(), AddDefaultSNS(), AddStopWords(), AddLightWords(), AddRawWords(), AddRequiredWords(), AddRewritings(), AddSpellingCorrectionFilter(), CreateInitialSearchParameters(), AddDefaultLanguage(), AddLanguageWeights(), AddPhonetizerLanguageMapping(), AddForceChineseScript(), AddSpellingCorrection(), AddQuestionStrategy(), AddStopWordsRuleSets(), AddDefaultOperator(), AddAdvancedSearchParameters(), AddSearchParameters(), AddRfmV2Options(), AddQuestionLanguage(), AddConceptsLimit(), AddGlobalRelevance(), AddWordsRelevance(), AddRelevanceDelta()AddRights(): Adds the access rights sub-clause AddIn(): Adds the IN clause of the SQL queryAddGroupBy(): Adds the GROUP BY clause of the SQL query, based on the configuration of the Query web service (or a groupBy parameter included in the query, if any)AddOrderBy(): Adds the ORDER BY clause of the SQL query, based on the sorting options specified in the Query web service (and a sort parameter included in the query, if any) AddSortOrderBy: Adds the ORDER BY clause of the SQL query GetCurrentSort: Returns the ORDER BY expression based on the &quot;sorting choices&quot; configuration, taking into account tab search if configured. Checks are made for a relevance sort when no fulltext terms are active. In this case the default non-relevance sorting choice is returned. AddPaging(): Adds the SKIP/COUNT clause of the SQL query  When overriding one of the above methods, one problem arises: these methods do not return a string, they write their output directly to a StringBuilder object. So, it is not possible to modify directly what the base method adds to the SQL query. For example, if we want to override the AddFrom() method to replace one index by another, the following does not work:  public override void AddFrom(StringBuilder sb) { // This fails, because AddFrom() does not return anything! // The output is written in the StringBuilder sb directly string from = base.AddFrom(sb); ... }   But we can easily overcome this problem by using the following trick:  public override void AddFrom(StringBuilder sb) { var sb2 = new StringBuilder(); base.AddFrom(sb2); // Call the base method with a blank StringBuilder string from = sb2.ToString(); // Now we can modify the from clause if we want to sb.Append(from); // Don't forget to write the clause to the real StringBuilder at the end }   This lets us modify any part of the SQL query sent to the engine.  ","version":"Next","tagName":"h3"},{"title":"After Search methods​","type":1,"pageTitle":"Server-side Plugins","url":"/dokku/docs/tipstricks/plugins#after-search-methods","content":" After the SQL query is executed, the results from the engine are written in the Response object (which a simple Json container). The methods of the QueryPlugin starting with Write each write a piece of the results. These methods can all be overriden to customize what is actually sent back to the client.  WritePredefinedAggregations(): Writes the aggregations with predefined values (if any).WriteTabResults(): Writes the results for the query responsible for computing the tabs counters (when tab search is enabled WriteTabs(): Writes the current tab and the available tabs, as defined in the Query web service configurationWriteAttributes(): Writes the non-aggregation attributes (such as matchingrowcount, processingtime, etc.)WriteAggregations(): Writes the computed aggregations to the results WriteAggregation(): Writes one computed aggregation to the results. This method has access to both the computed data and the aggregation's configuration in the Query web service. WriteTreeAggregationLevel(): For aggregations of type &quot;tree&quot; (eg. treepath), writes one level of the tree and its children in a recursive manner. WriteResults(): Writes the results for the main query. WriteScope(): Writes the current scope and the available scopes, as defined in the Query web service configuration (similar to the tabs)WriteSort(): Writes the current &quot;sort&quot; valueWriteDidYouMean(): Writes the &quot;did-you-mean&quot; object to the results. This is derived from the &quot;internalqueryanalysis&quot; attribute.WriteAttributes(): (as above, but for the main query)WriteAggregations(): (as above, but for the main query)WriteRecords(): Writes the list of Record objects retrieved by the engine. For each record, the data is retrieved from the Cursor object. Some helper methods can be overriden, to customize how some values are written: IsEmpty(): Returns TRUE if the passed value can be considered &quot;empty&quot;. Empty strings, numerics with value 0 and booleans with value false are all considered empty, and therefore not written in the record objects.GetColumnValue(): Returns the passed value for a particular column as a Json object. The form of the JSON object depends on the type of the column.GetDisplayTitle(): Returns the title field for the current record with highlighting applied using the &quot;title&quot; partname.GetRelevantExtracts(): Returns relevant extracts paragraph for the current record. HTML highlighting markup is applied to the extracts.GetThumbnailUrl(): Returns the thumbnail url for the current record.  Note the above methods manipulate Json objects, which have a rich set of methods for reading and writing values. As an example, the following piece of code produces a JSON object:  Code:  var example = Json.NewObject(); var data = example.SetArray(&quot;data&quot;); data.EltAdd(&quot;value1&quot;); data.EltAdd(42); data.EltAdd(false); example.Set(&quot;test&quot;, &quot;ok&quot;);   Result:  { &quot;data&quot;: [ &quot;value1&quot;, 42, false ], &quot;test&quot;: &quot;ok&quot; }   ","version":"Next","tagName":"h3"},{"title":"Other methods​","type":1,"pageTitle":"Server-side Plugins","url":"/dokku/docs/tipstricks/plugins#other-methods","content":" The QueryPlugin includes other customizable methods, notably:  High-level methods, which wrap the ones described above:  Execute(): Executes the query (the highest-level method, which is rarely needed to override). Init(): Wraps the initialization methods described above.ExecuteQuery(): Executes the query. This calls &quot;DoQuery&quot; preceded by a call to &quot;DoTabQuery&quot; if tab search is configured. DoTabQuery(): Executes the tab query and writes the results. This method (and the one below) wrap the &quot;Before Search&quot; and &quot;After Search&quot; methods described above. In particular they call the ToSql(), WriteTabResults() and WriteResults() methods.DoQuery(): Executes the main query and writes the results Term(): Cleans up this QueryPlugin instance. Members are set to their default values and the &quot;Client&quot; is returned to the pool unless it is external.  Query intent detection methods, which analyze the query text to detect an intent of the user, which can modify some members of the QueryPlugin to modify the search query:  MatchQueryIntents(): Initializes the &quot;QueryAnalysis&quot; member and then matches any configured query intents. If the &quot;QueryAnalysis&quot; already exists, as can be the case when processing the main query during tab search, then any query intent actions are applied AnalyseQuery(): Analyzes the text held in the &quot;Text&quot; member and returns an &quot;IQueryAnalysis&quot; instance. This method executes a custom SQL query, to get the text analysis from the engine. ToSqlForQueryAnalysis(): Generates a SELECT statement used to produce an &quot;IQueryAnalysis&quot; instance.  ","version":"Next","tagName":"h3"},{"title":"Json Method Plugins​","type":1,"pageTitle":"Server-side Plugins","url":"/dokku/docs/tipstricks/plugins#json-method-plugins","content":" ","version":"Next","tagName":"h2"},{"title":"Create a custom endpoint​","type":1,"pageTitle":"Server-side Plugins","url":"/dokku/docs/tipstricks/plugins#create-a-custom-endpoint","content":" A JsonMethodPlugin is a C# plugin deployed on the Sinequa server that exposes a custom endpoint of the Sinequa REST API. A JsonMethodPlugin has access to the full Sinequa C# API, so it can do practically anything, including one or multiple queries to the Sinequa engines.  The complete API of the JsonMethodPlugin is listed on Sinequa's documentation website.  As an example, let's take the following plugin:  public class MyJsonMethodPlugin : JsonMethodPlugin { public override void OnPluginMethod() { var input = JsonRequest.ValueStr(&quot;input&quot;); JsonResponse.Set(&quot;output&quot;, &quot;Hello, &quot; + input); } }   A POST request to /api/v1/plugin/MyJsonMethodPlugin with the following body:  { &quot;input&quot;: &quot;World!&quot; }   Yields the following response:  { &quot;output&quot;: &quot;Hello, World!&quot;, &quot;methodresult&quot;: &quot;ok&quot; }   The @sinequa/core library includes a service to easily sent GET/POST requests to a JsonMethodPlugin, as illustrated in the following example:  import { JsonMethodPluginService } from '@sinequa/core/web-services'; ... constructor(public pluginService: JsonMethodPluginService) {} example() { // Send request to the plugin const obs = this.pluginService.post('MyJsonMethodPlugin', {input: &quot;World!&quot;}); // Subscribe to response obs.subscribe(response =&gt; { console.log(response.output); }); }   Note that even an empty JsonMethodPlugin performs things like user authentication (taking into account the different types of SSO). By default, only administrators are allowed to use these plugins, but it is possible to change this rule by overriding the GetRequiredAuthLevel() method:  public override JsonMethodAuthLevel GetRequiredAuthLevel() { return JsonMethodAuthLevel.User; // Any authenticated user can use the plugin }   There are four levels: User, Admin, AdminOrDelegatedAdmin and None. Note that it is possible to retrieve the user's identity via this.Session.User. Additionally, this.Session has the following properties indicating whether the current user is an admin or delegated admin: IsAdmin, IsDelegatedAdmin, and IsAdminOrDelegatedAdmin .  ","version":"Next","tagName":"h3"},{"title":"Customizing existing web services​","type":1,"pageTitle":"Server-side Plugins","url":"/dokku/docs/tipstricks/plugins#customizing-existing-web-services","content":" Additionally, it is possible to use a JsonMethodPlugin in the context of another web service, instead of as an independent endpoint. This gives the possibility to customize the behavior of an existing web service, which, unlike the Query web service, does not have a dedicated plugin type.  For example, we can post process the suggestions returned by the Suggest Query web service, by adding the name of our plugin to the body of the request:  { &quot;app&quot;: &quot;app&quot;, &quot;suggestQuery&quot;: &quot;myQuery&quot;, &quot;text&quot;: &quot;barack ob&quot;, &quot;plugin&quot;: &quot;MyJsonMethodPlugin&quot;, &quot;input&quot;: &quot;World!&quot; }   However, in this case, the OnPluginMethod() method is not called. Instead, we can override our plugin logic in OnBegin() (to pre-process the request) or OnEnd() (to post-process the request). ","version":"Next","tagName":"h3"},{"title":"Login Methods","type":0,"sectionRef":"#","url":"/dokku/docs/tipstricks/login-methods","content":"","keywords":"","version":"Next"},{"title":"Authentication protocols​","type":1,"pageTitle":"Login Methods","url":"/dokku/docs/tipstricks/login-methods#authentication-protocols","content":" The goal of authentication protocols is to guarantee that each HTTP request comes from an identified user who has a certain set of permissions. Authentication can be managed either by Sinequa or by the web server (IIS):  Sinequa handles authentication for Login/Password, SAML2 and OAuth2 (IIS is configured with Anonymous authentication, meaning it just lets requests go through to Sinequa). IIS handles authentication for Windows Single Sign On (NTLM or Kerberos protocols). In this case, Sinequa lets IIS do all the work, and it gets the user's id from IIS itself (LOGON_USER variable). 🛈 In that sense, Windows authentication is convenient. However, it can also prove to work erratically, and differently from one browser to the other. We generally recommend using more modern protocols like SAML2 or OAuth2.  When Sinequa handles authentication rather than IIS (normal situation), it emits a JSON Web Token (JWT) that the SBA stores in a cookie (sinequa-web-token or sinequa-web-token-secure, depending on the protocol). The settings for the JWT are found in the Webapp settings (Advanced tab). In particular it is possible to increase the life span of the tokens and to automatically refresh them, to let the user be authenticated for a longer period.    The JWT is sent with every HTTP(S) request via the sinequa-web-token cookie. This allows Sinequa to know the identity of the user. When the token expires, Sinequa returns 401 errors (Unauthorized). Upon receiving this error, the SBA re-initiates the authentication process (the user does not see these errors because they are intercepted by the LoginInterceptor provided in the @sinequa/core/login library).  In the case of the SAML or OAuth protocols, an external service must authenticate the user. The browser navigates out of the SBA to this Identity Provider (for example, Google's Single Sign On). Then the browser navigates back to the Sinequa server, which redirects again to the Sinequa SBA, while delivering the JWT cookie.  The general login process is depicted in the following diagram (depending on the authentication protocol, only a subset of this diagram is relevant for a given application):  Red boxes represents calls to Sinequa web services  Notice that the Login process includes a call to three web services: app (configuration of the app and its web services), principal (identity of the user, typically from a directory), usersettings (user data, including baskets, saved queries, etc.). The login process is considered complete when all 3 services have downloaded this data and are initialized.  ","version":"Next","tagName":"h2"},{"title":"SBA Hosting: CORS or not CORS​","type":1,"pageTitle":"Login Methods","url":"/dokku/docs/tipstricks/login-methods#sba-hosting-cors-or-not-cors","content":" Cross-Origin Resource Sharing (CORS) is a mechanism that allows using web services from third party sources. CORS is active when a request is sent to a URL with an origin different from the URL in the browser. For example:  If your website is hosted on https://example.com/myapp and makes a HTTP GET request to https://example.com/api/examples/42, the two URLs have the same origin, so CORS is not active.If your website is hosted on https://example.com/myapp and makes a HTTP GET request to https://cool-service.com/api/examples/42, the two URLs have a different origin, so CORS is active.  The problem with CORS is that, when active, the browser restricts a number of functionalities. For example, in some cases it is not possible to store cookies (that are used for authentication) and it is not possible to interact with iFrames (that are used for document previews).  CORS may be an issue depending on where your SBA is deployed:  When your SBA is deployed on a Sinequa WebApp, there is no problem because CORS is not active: The application's URL (https://my-sinequa-server.com/app/my-sba) has the same origin as the application's API (https://my-sinequa-server.com/api). However, if your SBA is deployed on a different domain (https://my-app-server.com), CORS is active and you might run into some issues, which can interfere with the login process (particularly with HTTP instead of HTTPS). When the SBA is hosted on a different server, the url of the Sinequa server must be specified in the StartConfig object (defined in app.module.ts): export const startConfig: StartConfig = { app: &quot;my-app&quot;, url: &quot;https://my-sinequa-server.com&quot;, production: environment.production }; Another case where CORS can be active is during the development of the app. Using ng serve means your app is deployed on a local server (by default http://localhost:4200), but the Sinequa API is somewhere else (for example https://my-sinequa-server.com/api). Since this is a common situation, Angular CLI includes a way to proxy the Sinequa API as if it were hosted on the development server. Instead of running ng serve my-app, we simply run ng serve my-app --proxyConfig=./path/to/proxy.json, with a proxy file looking as follows: proxy.json { &quot;/api&quot;: { &quot;target&quot;: &quot;https://my-sinequa-server.com&quot;, &quot;secure&quot;: false, &quot;changeOrigin&quot;: true } } When this proxy is enabled, requests that are sent to http://localhost:4200/api are forwarded to https://my-sinequa-server.com/api. From the browser's point of view, everything comes from http://localhost:4200 (both the app and the API), so CORS is not active.  note Note that when the URL of the server is defined in a proxy file, it should not be defined in StartConfig object. In fact if you define a url in your StartConfig, it cancels the effect of the proxy: the requests will be sent to the url, thus activating CORS.  ","version":"Next","tagName":"h2"},{"title":"HTTP vs HTTPS​","type":1,"pageTitle":"Login Methods","url":"/dokku/docs/tipstricks/login-methods#http-vs-https","content":" Another parameter which can influence login protocols is whether you use HTTP or HTTPS for your Sinequa server. The table below summarizes the compatibility for the different protocol we support. We generally recommend using HTTPS, as it is more secure and suffers less restrictions from the browser than HTTP.  \tHTTP\tHTTPSDefault (Login/Password)\t✔️ Compatible (with CORS inactive*)\t✔️ Compatible SAML 2.0\t❌ Incompatible\t✔️ Compatible OAuth 2.0\t✔️ Compatible (with CORS inactive*)\t✔️ Compatible Windows Authentication\t✔️ Compatible\t✔️ Compatible  info When CORS is active, the browser requires Cookies to be stored with the SameSite=None attribute, which also requires the Secure attribute, only available with HTTPS. So effectively, it is not possible to store our JWT with HTTP + CORS.  Windows Authentication does not require storing a JWT, so it is not affected by this problem.  Note that with HTTP the cookie storing the JWT is named sinequa-web-token, and with HTTPS it is named sinequa-web-token-secure.  In development mode, with ng serve, you can serve your application over HTTPS with the --ssl=true option. You should generally use this option if your Sinequa backend is served over HTTPS too, even though it is not mandatory (except for SAML authentication for example).  ","version":"Next","tagName":"h2"},{"title":"Setting Up Login Methods​","type":1,"pageTitle":"Login Methods","url":"/dokku/docs/tipstricks/login-methods#setting-up-login-methods","content":" ","version":"Next","tagName":"h2"},{"title":"Default form (login/password)​","type":1,"pageTitle":"Login Methods","url":"/dokku/docs/tipstricks/login-methods#default-form-loginpassword","content":" By default, if no login method is configured, you log in to Sinequa via a form asking for your username and password (which must exist in a domain on the Sinequa back-end):    Your credentials are sent to the api/v1/webToken endpoint which returns a JWT directly. In the background, this is the process that is active:    Notice that on application startup, the calls to the 3 web services (app, usersettings and principal) fail with a 401 error: This is what triggers the display of the login popup asking for your credentials. These errors are invisible to the user because the LoginInterceptor (on the left) has taken care of them. But if you have a look at the browser's inspector, you should see them nevertheless:    To set-up authentication via the default form, you must do the following:  On the Sinequa server, do not configure any auto-login method in the webapp. In IIS, only enable Anonymous Authentication. In your app.module.ts, do not configure any auto-login provider. Your StartConfig should look like: export const startConfig: StartConfig = { app: &quot;my-app&quot;, production: environment.production }; (optionally with the url property to enable CORS) In development mode, you can use a proxy to avoid CORS issues. Run ng serve &lt;app name&gt; --proxyConfig=./path/to/proxy.json, with the following configuration: proxy.json { &quot;/api&quot;: { &quot;target&quot;: &quot;https://my-sinequa-server.com&quot;, &quot;secure&quot;: false, &quot;changeOrigin&quot;: true }, &quot;/xdownload&quot;: { &quot;target&quot;: &quot;https://my-sinequa-server.com&quot;, &quot;secure&quot;: false, &quot;changeOrigin&quot;: true } }   ","version":"Next","tagName":"h3"},{"title":"Windows Single Sign-On​","type":1,"pageTitle":"Login Methods","url":"/dokku/docs/tipstricks/login-methods#windows-single-sign-on","content":" Windows Single Sign-On (SSO) allows to use the fact that a user is already authentified by logging in to Windows, and that the browser can transmit their identity directly to the server.  One benefit of this approach is that all the work is managed by the Web Server (IIS). Therefore the application can send HTTP requests directly, without having to respond to 401 errors or exit the application.  The process is very much simplified:    The configuration of Windows SSO is documented in the official documentation.  If the SSO works for accessing the Sinequa administration, it should work for authenticating HTTP requests for a SBA deployed on the same WebApp.  Sometimes, however, the browser might prompt you for your credentials:    This can happen for various reasons, and can be quite erratic:  The application may not be recognized as part of the intranet, and thus the credentials are not transmitted. To solve this, add the application URL to your Control Panel &gt; Internet Options &gt; Security &gt; Local Intranet &gt; Sites &gt; Advanced.The problem may occur for the first requests, but after refreshing the page and/or cancelling the prompt, the problem eventually goes away (a symptom of this can be seen in you browser inspector (Network tab): sometimes some requests are successful (200) but others fail (401), causing the prompt).  When Windows SSO is enabled, do not configure any auto-login provider in your app.module.ts. Your StartConfig should look like:  export const startConfig: StartConfig = { app: &quot;my-app&quot;, production: environment.production };   Developers might get 401 errors when using ng serve with a regular proxy configuration. You must replace your proxy file (by default src/proxy.conf.json) by a JavaScript file with the following content (eg. src/proxy.conf.js):  proxy.conf.js const Agent = require('agentkeepalive').Agent; module.exports = [ { context: [&quot;/api&quot;, &quot;/xdownload&quot;], target: &quot;http://my-sinequa-server.com&quot;, secure: false, changeOrigin: true, agent: new Agent({ maxSockets: 100, keepAlive: true, maxFreeSockets: 10, keepAliveMsecs: 100000, timeout: 6000000, keepAliveTimeout: 90000 }), onProxyRes: proxyRes =&gt; { const key = &quot;www-authenticate&quot;; proxyRes.headers[key] = proxyRes.headers[key] &amp;&amp; proxyRes.headers[key].split(&quot;,&quot;); } } ];   warning The above script is for a server accessed over HTTP. For HTTPS, replace Agent by HttpsAgent (3 occurrences)  And of course, update your ng serve command to reflect this new file:  npm run ng serve myapp -- --proxyConfig=./projects/myapp/src/proxy.conf.js   ","version":"Next","tagName":"h3"},{"title":"Windows SSO and CORS​","type":1,"pageTitle":"Login Methods","url":"/dokku/docs/tipstricks/login-methods#windows-sso-and-cors","content":" If you need to enable Windows SSO with CORS, additional steps are needed:  To enable CORS, add the url of the Sinequa server in your app.module.ts, in the StartConfig object. Dependencies: You need to install the following modules (IIS / Security): Windows AuthenticationURL Authorization Configure your site Authentication: Enable both Anonymous and Windows Authentication If not already done, enable CORS in your WebApp configuration from the specified origins (See Server configuration). Add security rules into the web.config file Go into the sinequa/website folder where your WebApplication is installed. Edit the web.config file: Add the following &lt;security&gt; tag into the &lt;system.webServer&gt; tag: web.config.xml &lt;security&gt; &lt;authorization&gt; &lt;remove users=&quot;*&quot; roles=&quot;&quot; verbs=&quot;&quot; /&gt; &lt;add accessType=&quot;Allow&quot; users=&quot;?&quot; verbs=&quot;OPTIONS&quot; /&gt; &lt;add accessType=&quot;Deny&quot; users=&quot;?&quot; verbs=&quot;GET, POST&quot; /&gt; &lt;add accessType=&quot;Allow&quot; users=&quot;*&quot; verbs=&quot;GET, POST&quot; /&gt; &lt;/authorization&gt; &lt;/security&gt; What it actually means: Allow OPTIONS queries for all anonymous usersDenied GET / POST queries for all anonymous users (So GET and POST will be handled by the next rule)Allow GET / POST queries for all users (here authenticated users) Why this configuration: The Cross-Origin Resource Sharing standard works by adding new HTTP headers that let servers describe which origins are permitted to read that information from a web browser. Additionally, for HTTP request methods that can cause side-effects on server data (in particular, HTTP methods other than GET, or POST with certain MIME types), the specification mandates that browsers &quot;preflight&quot; the request, soliciting supported methods from the server with the HTTP OPTIONS request method, and then, upon &quot;approval&quot; from the server, sending the actual request. Servers can also inform clients whether &quot;credentials&quot; (such as Cookies and HTTP Authentication) should be sent with requests. When you fire an AJAX call to Sinequa REST API, two HTTP queries are sent (this is automatically done by your browser): The &quot;preflight&quot; : Using OPTION Method, will get the list of Access-Control-Allow in order to know if it can go to step #2. This first HTTP call is not passing any credential token in the HTTP headers so it'll be treated as &quot;anonymous&quot; by IIS Send the actual GET or POST query to the REST API using authentication in the HTTP headers  :::warning Important note Upgrading your Sinequa environment will override the web.config file. So it’s highly recommended to backup this file in the folder and replace the web.config file with the backup after an upgrade. :::  ","version":"Next","tagName":"h3"},{"title":"SAML 2.0​","type":1,"pageTitle":"Login Methods","url":"/dokku/docs/tipstricks/login-methods#saml-20","content":" The SAML 2.0 protocol is described in this picture (source: Wikipedia):    In the context of Sinequa:  &quot;Service Provider&quot; is the Sinequa Server&quot;User Agent&quot; is the user&quot;Identity Provider&quot; is the SSO service able to authenticate the user on behalf of Sinequa1: &quot;Request target resource&quot; is a HTTP request sent by the user to the Sinequa server, for example to search for content.2/3: &quot;Request SSO service&quot; is Sinequa redirecting the user to the third party service, thus forcing the user out of the SBA (because he is not authenticated).4/5: &quot;Request Assertion Consumer Service&quot; is the SSO service redirecting the user to the Sinequa server (in practice the URL is &lt;sinequa server&gt;/saml/redirect).6/7: &quot;Request target resource&quot; is Sinequa redirecting the User to the SBA, thus going back to step 1, except this time Sinequa granted a Json Web Token (JWT) to the user, persisted in a Cookie (sinequa-web-token-secure). Therefore, as long as this cookie doesn't expire, all the requests of the user will be properly authenticated.8: &quot;Respond with request resource&quot; if the user is indeed authenticated, Sinequa responds with the requested data (however if the JWT fails to be stored in a cookie, then we are back to step 2 and potentially will keep looping indefinitely)  In the front-end part of the SBA, the login process is as follows:    In the Sinequa administration, the configuration of the SAML 2.0 protocol involves various steps:  Configure an identity provider in your Sinequa WebApp Auto-Login tab (See the official documentation) You can export the standard metadata required to configure the identity provider by clicking on the &quot;Download metadata&quot; button: This standard metadata file can normally be imported in standard SAML providers (like MS ADFS), but the configuration can also be entered manually. Add the name of the provider to your app.module.ts (here we named it &quot;identity&quot;): export const startConfig: StartConfig = { app: &quot;my-app&quot;, autoSAMLProvider: &quot;identity&quot;, production: environment.production };   If your SBA is deployed on the Sinequa webapp, this configuration should enable you to log in to your application, just as you can log in to the Sinequa administration.  If your SBA is deployed on a different domain, CORS is active and you need to add the url of the Sinequa server to your StartConfig.  In development mode, you should use a proxy to avoid CORS issues. Run ng serve &lt;app name&gt; --ssl=true --proxyConfig=./path/to/proxy.json, with the following configuration:  proxy.json { &quot;/api&quot;: { &quot;target&quot;: &quot;https://my-sinequa-server.com&quot;, &quot;secure&quot;: false, &quot;changeOrigin&quot;: true }, &quot;/xdownload&quot;: { &quot;target&quot;: &quot;https://my-sinequa-server.com&quot;, &quot;secure&quot;: false, &quot;changeOrigin&quot;: true }, &quot;/saml/redirect&quot;: { &quot;target&quot;: &quot;https://my-sinequa-server.com&quot;, &quot;secure&quot;: false, &quot;changeOrigin&quot;: true } }   warning However, the problem with using a proxy in this situation is that the JWT cookie will be associated with the Sinequa server URL (https://my-sinequa-server.com) instead of your proxy URL (https://localhost:4200). The requests (sent to the latter) will not be authenticated and the user will keep being redirected to the Identity Provider.  You therefore need to configure an alternative provider where the URL of the service is set to the proxy URL. In your Webapp configuration (Auto-Login tab), duplicate the provider and set the &quot;Server url override&quot; parameter to https://localhost:4200:    Then download the metadata file and add it to the configuration of your Identity Provider.  You can now use this new provider in your SBA with ng serve. Update the StartConfig to use this alternative provider (here called &quot;identity-dev&quot;). You can use the environment files to use &quot;identity-dev&quot; in development mode (with ng serve) and &quot;identity&quot; when the app is deployed on the server:  developmentproduction export const startConfig: StartConfig = { app: &quot;my-app&quot;, autoSAMLProvider: &quot;identity-dev&quot;, production: environment.production };   developmentproduction environments/environment.ts export const environment = { autoSAMLProvider: &quot;identity-dev&quot;, production: false };   ","version":"Next","tagName":"h3"},{"title":"OAuth2​","type":1,"pageTitle":"Login Methods","url":"/dokku/docs/tipstricks/login-methods#oauth2","content":" OAuth is a protocol for managing &quot;Access Delegation&quot;, which is used by websites to let users grant them access to their information. In practice, it is not used by Sinequa to access any information of the user, but simply for identifying them and granting them an identity token. The process is therefore very similar to SAML.  In the front-end part of the SBA, the login process is the same as SAML:    In the Sinequa administration, the configuration of the OAuth2 protocol involves various steps:  Configure an identity provider in your Sinequa WebApp (See the official documentation) In the configuration of your OAuth identity provider (eg. Google SSO), include the URL of the Sinequa server (https://my-sinequa-server.com/auth/redirect) as a redirection URL. Add the name of the provider to your app.module.ts:  app.module.ts {`export const startConfig: StartConfig = { app: &quot;my-app&quot;, autoOAuthProvider: &quot;google&quot;, production: environment.production };   If your SBA is deployed on the Sinequa server, this configuration should enable you to log in to your application, just as you can log in to the Sinequa administration.  If your SBA is deployed on a different server, CORS is active and you need to add the url of the Sinequa server to your StartConfig.  {`export const startConfig: StartConfig = { app: &quot;my-app&quot;, autoOAuthProvider: &quot;google&quot;, url: &quot;https://my-sinequa-server.com&quot;, production: environment.production };   In development mode, you should use a proxy to avoid CORS issues. Run ng serve &lt;app name&gt; --ssl=true --proxyConfig=./path/to/proxy.json, with the following configuration:  proxy.json { &quot;/api&quot;: { &quot;target&quot;: &quot;https://my-sinequa-server.com&quot;, &quot;secure&quot;: false, &quot;changeOrigin&quot;: true }, &quot;/xdownload&quot;: { &quot;target&quot;: &quot;https://my-sinequa-server.com&quot;, &quot;secure&quot;: false, &quot;changeOrigin&quot;: true }, &quot;/auth/redirect&quot;: { &quot;target&quot;: &quot;https://my-sinequa-server.com&quot;, &quot;secure&quot;: false, &quot;changeOrigin&quot;: true } }   warning However, the problem with using a proxy in this situation is that the JWT cookie will be associated with the Sinequa server URL (https://my-sinequa-server.com) instead of your proxy URL (https://localhost:4200). The requests (sent to the latter) will not be authenticated and the user will keep being redirected to the Identity Provider.  You therefore need to configure an alternative provider where the URL of the service is set to the proxy URL. In your Webapp configuration (Auto-Login tab), duplicate the provider and set the &quot;Server url override&quot; parameter to https://localhost:4200:    In the Identity Provider's configuration, you also need to add https://localhost:4200/auth/redirect as a valid redirection URL.  You can now use this new provider in your SBA with ng serve. Update the StartConfig to use this alternative provider (here called &quot;google-dev&quot;). You can use the environment files to use &quot;google-dev&quot; in development mode (with ng serve) and &quot;google&quot; when the app is deployed on the server:  developmentproduction export const startConfig: StartConfig = { app: &quot;my-app&quot;, autoOAuthProvider: &quot;google-dev&quot;, production: environment.production };   developmentproduction environments/environment.ts export const environment = { autoOAuthProvider: &quot;google-dev&quot;, production: false };   ","version":"Next","tagName":"h3"},{"title":"Custom Authentication​","type":1,"pageTitle":"Login Methods","url":"/dokku/docs/tipstricks/login-methods#custom-authentication","content":" In some situations, authentication is taken care of by a process independent of Sinequa. The identity of the user is known, and we would like the HTTP requests sent to Sinequa to be automatically authenticated. This situation can occur when users go through a reverse proxy or API gateway: The proxy takes care of authentication and users never directly talk to the Sinequa server.  In this case, we need to add the user's identity to our HTTP requests, and catch this identity in Sinequa with a WebAppPlugin. One solution can be to forward an authentication token to Sinequa and decrypt it on the server to get the identity of the user.  The plugin might look as follows. Note that GetLoginInfo() is called for every HTTP request, so it needs to be relatively fast (it can be slow on the first call, to store some information in cache, and then fast for the following requests):  namespace Sinequa.Plugin { public class CustomAuthenticationPlugin : WebAppPlugin { public override LoginInfo GetLoginInfo(IDocContext Ctxt) { // The HttpManager can provide any information about the current HTTP request HttpManager hm = Ctxt.Hm; // We can also get information from a URL query parameter with Hm.Request(&lt;name&gt;) // or from a cookie with Hm.RequestCookieGet(&lt;name&gt;) string head = hm.RequestHeader(&quot;Authorization&quot;); // Then we need to obtain the identity of the user somehow string userid = decryptHeader(head); // The identity might not be determined, in which case returning `null` results in a 401 error if(userid == null) return null; // The user id was determined, so we return a LoginInfo object LoginInfo login = new LoginInfo(); login.UserInfo = userid; return login; } } }  ","version":"Next","tagName":"h2"},{"title":"Responsive Design","type":0,"sectionRef":"#","url":"/dokku/docs/tipstricks/responsive-design","content":"","keywords":"","version":"Next"},{"title":"CSS Media Queries​","type":1,"pageTitle":"Responsive Design","url":"/dokku/docs/tipstricks/responsive-design#css-media-queries","content":" The CSS language provides a very useful tool to make an application responsive: Media Queries.  For example, you may specify that a .column element must take the full width of its parent when the screen is 600px or less:  @media screen and (max-width: 600px) { .column { width: 100%; } }   Similarly, you can hide or show elements with a display: none; property, or change the layout with flexbox rules. The drawback of this approach is that your stylesheet is going to grow significantly.  ","version":"Next","tagName":"h2"},{"title":"Bootstrap​","type":1,"pageTitle":"Responsive Design","url":"/dokku/docs/tipstricks/responsive-design#bootstrap","content":" These media query rules are also used by UI frameworks, like Bootstrap. With Bootstrap, rather than writing rules in your stylesheet, you assign predefined rules to your HTML elements with class names (these class names include screen size modifiers that make the app responsive).  The Grid System of Bootstrap allows you to design your app according to a layout that self-adjusts depending on the size of the screen. The names of the screen size modifiers used by bootstrap are by convention xs, sm, md, lg, xl, and each corresponds to a default screen width range. These sizes can be customized for your app, by setting your own sizes in CSS variables before importing Bootstrap (See the tutorial on Responsive Design).  Using Bootstrap is a good way to make your application responsive, all while minimizing the size of your stylesheet. In the SBA Framework, Bootstrap is used extensively:  In the @sinequa/components library, in all the components whose class name are prefixed by Bs.In the Vanilla Search application.  The features of Bootstrap that are commonly used in the framework are:  The Grid System (.container, .row, .col-xx-y): Control the layout of the app in a responsive way.The Flex utilities (d-flex, flex-column, align-items-center, flex-grow-1, etc.): Easily use all the possibilities of the Flex layout.The Spacing utilities (p-1, m-3, pt-0, etc.): Easily add margin and padding to your elements.Various UI components, like lists (list-group, list-group-item...), forms (form-group, form-group-inline...), cards (card, card-header...), modals, etc.  ","version":"Next","tagName":"h2"},{"title":"UI Service​","type":1,"pageTitle":"Responsive Design","url":"/dokku/docs/tipstricks/responsive-design#ui-service","content":" CSS can handle a lot of the work by changing the layout and visibility of elements, but keep it mind that it works on a fixed HTML page. The CSS cannot add or remove elements from the DOM (at best it can toggle their display or visibility).  However, Angular is very effective at adding and removing elements from the DOM, based on application logic. The SBA framework includes a dedicated Angular service, the UIService (from @sinequa/components/utils) that allows you to test the size of the screen, and perform arbitrary actions when a change occurs.  To use the UIService, do the following:  First, inject the screen sizes you want to use in your app.module.ts (unless you are fine with the defaults): app.module.ts import { SCREEN_SIZE_RULES } from '@sinequa/components/utils'; ... // Screen size breakpoints (must be consistent with Bootstrap custom breakpoints in styles/app.scss) export const breakpoints = { lg: &quot;(min-width: 1000px)&quot;, sm: &quot;(min-width: 600px) and (max-width: 999px)&quot;, xs: &quot;(max-width: 599px)&quot;, } ... providers: [ ... {provide: SCREEN_SIZE_RULES, useValue: breakpoints} ], Import the UIService and inject it in your component's constructor: import { UIService } from '@sinequa/components/utils'; ... constructor( ... public ui: UIService ) Use the service in your HTML templates and/or TypeScript controllers: &lt;div *ngIf=&quot;ui.screenSizeIsGreaterOrEqual('lg')&quot;&gt; ... &lt;/div&gt; if(ui.screenSizeIsGreaterOrEqual('lg')){ ... }  ","version":"Next","tagName":"h2"},{"title":"Speed and Performance","type":0,"sectionRef":"#","url":"/dokku/docs/tipstricks/speed-performance","content":"","keywords":"","version":"Next"},{"title":"Lazy loading feature modules​","type":1,"pageTitle":"Speed and Performance","url":"/dokku/docs/tipstricks/speed-performance#lazy-loading-feature-modules","content":" Lazy load is a design pattern that loads NgModules on-demand. Thus, it helps keep initial bundle sizes smaller, which in turn helps decrease load times.  To help users, easily, lazy load specific modules of an SBA application, all libraries have been updated to support this pattern.  For example, if you want to lazy load the preview component, you should start creating an angular module with all its dependencies:  @NgModule({ declarations: [PreviewComponent], imports: [ CommonModule, ... // other modules dependencies PreviewRoutingModule ], exports: [PreviewComponent] }) export class PreviewModule { }   Then, in the PreviewModule's routing module, add a route for this component:  const routes: Routes = [ { path: '', component: PreviewComponent }, ]; @NgModule({ imports: [RouterModule.forChild(routes)], exports: [RouterModule] }) export class PreviewRoutingModule { }   The final step is to use loadChildren (instead of component) in your AppRoutingModule routes configuration as follows:  const routes: Routes = [ ... // other routes { path: 'preview', loadChildren: () =&gt; import('./preview/preview.module').then(m =&gt; m.PreviewModule) } ];   With this in place, you should notice the Lazy chunk files, while compiling your application. Those are simply referring to our lazy loaded module    ","version":"Next","tagName":"h2"},{"title":"Module Federation​","type":1,"pageTitle":"Speed and Performance","url":"/dokku/docs/tipstricks/speed-performance#module-federation","content":" Historically, build tools (Webpack,…) assume that the entire program code is available when compiling. Lazy loading is possible, but only from areas that were split off during compilation.  This was the main motivation behind the creation of Module Federation as a new feature of Webpack 5. Hence, it allows loading separately compiled and deployed code (also called micro front-ends or plugins) into an application.  To simplify the concept, a so-called host references a remote using a configured name. This reference is only resolved at runtime by loading a so-called remote entry point.  ⚠️ NOTE: This concept is environment-independent (Angular, React, Vue, ASP.NET, etc.) ⚠️  ","version":"Next","tagName":"h2"},{"title":"Activating Module Federation for Angular Projects​","type":1,"pageTitle":"Speed and Performance","url":"/dokku/docs/tipstricks/speed-performance#activating-module-federation-for-angular-projects","content":" To do so, you need to tell the CLI to use Module Federation when building. However, as the CLI shields webpack from us, you need a custom builder.  Fortunately, the package @angular-architects/module-federation provides such a custom builder.  For the following example, let's assume the following naming : the host application as shell and the remote application as mfe (stands for Micro front-end).  To get started, you can just &quot;ng add&quot; the package to your projects:  ng add @angular-architects/module-federation --project shell --port 5000  ng add @angular-architects/module-federation --project mfe --port 3000  These commands activate module federation, assign a port for ng serve, and generate the skeleton of a module federation configuration (webpack.config.js).  ⚠️ NOTE: The webpack.config.js is only a partial webpack configuration. It only contains stuff to control module federation. The rest is generated by the CLI as usual ⚠️  Now let's jump onto the project mfe and edit the generated configuration in .../projects/mfe/webpack.config.js  const ModuleFederationPlugin = require(&quot;webpack/lib/container/ModuleFederationPlugin&quot;); [...] module.exports = { [...], plugins: [ new ModuleFederationPlugin({ name: &quot;mfe&quot;, filename: &quot;remoteEntry.js&quot;, exposes: { // The update './Module': './projects/mfe/src/app/toto/toto.module.ts', }, shared: { &quot;@angular/core&quot;: { singleton: true, strictVersion: true }, &quot;@angular/common&quot;: { singleton: true, strictVersion: true }, &quot;@angular/router&quot;: { singleton: true, strictVersion: true }, [...] } }), [...] ], };   This exposes the TotoModule under the name ./Module. Hence, the shell can use this path to load it.  To do so, you need to adjust the shell's generated configuration as follows :  const ModuleFederationPlugin = require(&quot;webpack/lib/container/ModuleFederationPlugin&quot;); [...] module.exports = { [...], plugins: [ new ModuleFederationPlugin({ // Make sure to use port 3000 defined on the first step while adding the package to the projects remotes: { 'mfe': &quot;mfe@http://localhost:3000/remoteEntry.js&quot; }, shared: { &quot;@angular/core&quot;: { singleton: true, strictVersion: true }, &quot;@angular/common&quot;: { singleton: true, strictVersion: true }, &quot;@angular/router&quot;: { singleton: true, strictVersion: true }, [...] } }), [...] ], };   This references the separately compiled and deployed mfe project.  Now, all remains is to update the routing module of the shell  const routes: Routes = [ ... // other routes { path: 'toto', loadChildren: () =&gt; import('mfe/Module').then(m =&gt; m.TotoModule) } ];   However, the path mfe/Module which is imported here, does not exist within the shell. It is just a virtual path pointing to another project.  To ease the TypeScript compiler, you need a typing for it by adding the following line to the file .../projects/shell/src/decl.d.ts :  declare module 'mfe/Module';   Once starting both applications side by side (ng serve shell and ng serve mfe), you should notice, at runtime, that shell loads the mfe from its own URL    ","version":"Next","tagName":"h3"},{"title":"Dynamic federation​","type":1,"pageTitle":"Speed and Performance","url":"/dokku/docs/tipstricks/speed-performance#dynamic-federation","content":" In the previous section, we assumed that micro front-ends, used in the shell, are already known by the developer.  However, there might be situations where you don’t even know the list of micro front-ends upfront. For example, an application with different dynamic views based on user privileges. This information can be hold by an external system and fetched at runtime via HTTP request.  To dynamically load a micro-frontend at runtime, you need to remove the registration of the micro front-end upfront within shell configuration :  remotes: { // &quot;mfe&quot;: &quot;mfe@http://localhost:3000/remoteEntry.js&quot;, },   Instead, you should use the helper function loadRemoteModule provided by the @angular-architects/module-federation :  const routes: Routes = [ ... // other routes { path: 'toto', loadChildren: () =&gt; loadRemoteModule({ remoteEntry: 'http://localhost:3000/remoteEntry.js', remoteName: 'mfe', exposedModule: './Module' }) .then(m =&gt; m.TotoModule) } ];   To showcase the use of external systems, remotes information can be provided at runtime via a lookup service :  @Injectable({ providedIn: 'root' }) export class LookupService { lookup(): Promise&lt;Microfrontend[]&gt; { [...] } }   Then, after receiving the Microfrontend array from the LookupService, you can build your dynamic routes as follows :  export function buildRoutes(options: Microfrontend[]): Routes { const lazyRoutes: Routes = options.map(o =&gt; ({ path: o.routePath, loadChildren: () =&gt; loadRemoteModule(o).then(m =&gt; m[o.moduleNameProperty]) })); return [...APP_ROUTES, ...lazyRoutes]; }   ","version":"Next","tagName":"h3"},{"title":"More Details on Module Federation​","type":1,"pageTitle":"Speed and Performance","url":"/dokku/docs/tipstricks/speed-performance#more-details-on-module-federation","content":" Please have a look at Webpack federation feature and Angular module federation package ","version":"Next","tagName":"h3"},{"title":"Query Intent Detection","type":0,"sectionRef":"#","url":"/dokku/docs/tipstricks/query-intent","content":"","keywords":"","version":"Next"},{"title":"Query Intent Web Service​","type":1,"pageTitle":"Query Intent Detection","url":"/dokku/docs/tipstricks/query-intent#query-intent-web-service","content":" This functionality is exposed as a web service. The service takes in a user query and returns one or several intents, including the entities (or their Machine Learning equivalent, &quot;slots&quot;) that have been matched.  In the Sinequa administration, the Query Intents are configured in the Search-Based Applications &gt; App Dependencies &gt; Query Intent Sets section. Once configured there, the Query Intent Set must be attached to the SBA's query web service (Under the Search settings tab and Query Options - Intents section).  Requesting the intent of a query can then be done easily, by using QueryIntentWebService from the @sinequa/core/web-services module:  this.queryIntentWebService.getQueryIntent(this.query);   In this example, this.query is a Query object. The method returns an observable of QueryIntentMatch[].  ","version":"Next","tagName":"h2"},{"title":"Integration in the Search process​","type":1,"pageTitle":"Query Intent Detection","url":"/dokku/docs/tipstricks/query-intent#integration-in-the-search-process","content":" Query Intent detection is already integrated in the search process orchestrated by the SearchService. It is automatically triggered when you configure a Query Intent Set in your query web service on the back-end.  However, there are two possible processes:  Asynchronous detection (by default): The Query Intent detection is performed in parallel with Search. This process is well suited when query intent is needed for displaying information in addition to the search results, like for example in an info-card. This process is analogous to how sponsored links work.Synchronous detection: The Query Intent detection is performed before Search, which allows to potentially modify or cancel the query, and/or perform other actions before Search is actually executed. This process is analogous to how the Did You Mean functionality works. Note that this process involves an additional round-trip with the Sinequa platform, so it slows down search a little bit.    Synchronous detection can be activated by setting the queryIntentsSync property of the SearchOptions in your AppModule:  @NgModule({ imports: [ ..., BsSearchModule.forRoot({queryIntentsSync: true})   The SearchService emits a new-query-intents event when results are in. Other components and services can listen to this event and perform custom actions depending on the presence and type of intents.  this.searchService.events.subscribe(event =&gt; { if(event.type === 'new-query-intents') { const events = event.intents.filter(intent =&gt; intent.name === &quot;my-intent&quot;); if(events.length &gt; 0) { ... } } }   ","version":"Next","tagName":"h2"},{"title":"Examples​","type":1,"pageTitle":"Query Intent Detection","url":"/dokku/docs/tipstricks/query-intent#examples","content":" ","version":"Next","tagName":"h2"},{"title":"Managing Query Intents​","type":1,"pageTitle":"Query Intent Detection","url":"/dokku/docs/tipstricks/query-intent#managing-query-intents","content":" A good idea is to centralize the management of Query Intents in one place. We can create a service that listens to the SearchService events, and performs custom actions, depending on the type of intent that is detected.  @Injectable({providedIn: 'root'}) export class QueryIntentService { constructor( public searchService: SearchService, public exprBuilder: ExprBuilder ){ this.init(); } init() { this.searchService.events.subscribe(event =&gt; { if(event.type === 'new-query-intents') { // Perform custom actions here } }); } }   It is important that this service be created from the start of the application life. You can force that by including it in the constructor of your AppComponent:   constructor( ..., public queryIntentService: QueryIntentService ){}   ","version":"Next","tagName":"h3"},{"title":"Example 1: Displaying an info-card​","type":1,"pageTitle":"Query Intent Detection","url":"/dokku/docs/tipstricks/query-intent#example-1-displaying-an-info-card","content":" Displaying an info-card is independent from the main search process, so we can work in asynchronous mode.  Let's say we have configured an intent named &quot;people&quot; on the backend. When we search for &quot;who is John Doe?&quot;, this intent matches and we can display an info-card about that person.  In our QueryIntentService let's add a method that looks for the &quot;people&quot; intent and fetches data about that person:   // People Query intent data person?: string; personData = new ReplaySubject&lt;Results|undefined&gt;(1); processPeople(event: SearchService.NewQueryIntentsEvent) { // Look for the &quot;people&quot; intent const people = event.intents.filter(intent =&gt; intent.name === &quot;people&quot;) .map(intent =&gt; intent.globalEntities?.[0]?.normalization as string) .filter(f =&gt; !!f); // If any (and if not already processed) if(people.length &gt; 0 &amp;&amp; this.person !== people[0]) { // Create a query for this person const query = this.searchService.makeQuery(); query.text = people[0]; query.action = &quot;aggregate&quot;; query.aggregations = [&quot;geo&quot;, &quot;company&quot;, &quot;person&quot;]; this.searchService.getResults(query) .subscribe(r =&gt; { this.person = people[0]; this.personData.next(r); // Emits the data for the infocard }); } // If none, we want to stop displaying the infocard, if any else if(people.length === 0) { this.person = undefined; this.personData.next(undefined); } }   We can call this method from the init() method we defined above.  Then, to display the infocard, we simply create a component that displays the personData, if any. This can be as simple as the following:  @Component({ selector: 'sq-query-intent-people', template: ` &lt;sq-facet-card *ngIf=&quot;queryIntentsService.personData | async; let results&quot; [title]=&quot;queryIntentsService.person&quot; [icon]=&quot;'fas fa-user'&quot;&gt; &lt;sq-facet-tag-cloud #facet [results]=&quot;results&quot; [aggregations]=&quot;['Company','Geo','Person']&quot;&gt; &lt;/sq-facet-tag-cloud&gt; &lt;/sq-facet-card&gt; ` }) export class QueryIntentPeopleComponent { constructor( public queryIntentsService: QueryIntentService ){} }   With the example above we display a tag-cloud with terms related to a person. This infocard can be displayed, for example, on the right side of the user interface. This component has no input, and it manages its own visibility, so it's enought to embed it with something as simple as:  &lt;sq-query-intent-people&gt;&lt;/sq-query-intent-people&gt;   Result of searching &quot;who is Barack Obama?&quot;  ","version":"Next","tagName":"h3"},{"title":"Example 2: Automatic filters​","type":1,"pageTitle":"Query Intent Detection","url":"/dokku/docs/tipstricks/query-intent#example-2-automatic-filters","content":" Another use-case for Query Intent is to detect the intent of applying a specific filter. For example, if a user searches for &quot;earnings report pdf&quot;, we can detect that they really means &quot;earnings report&quot; and format = pdf.  Let's say we have configured an intent named &quot;format&quot; that detects a file format in the query. Now, since we want to modify the search query, we need to work in synchronous mode. So, in our AppModule, let's start by adding the queryIntentSync option, as explained above:  export const searchOptions: SearchOptions = { ..., queryIntentsSync: true };   In our QueryIntentService let's add a method that looks for the &quot;format&quot; intent, modifies the query, cancels the current search and performs a new query:   formats: string[]; processFormats(event: SearchService.NewQueryIntentsEvent) { // Activate only if user has not already created a docformat filter if(!event.query.findSelect(&quot;docformat&quot;)) { // Look for the &quot;format&quot; intents this.formats = event.intents.filter(intent =&gt; intent.name === &quot;format&quot;) .map(intent =&gt; intent.globalEntities?.[0]?.value.toLowerCase() as string) .filter(f =&gt; !!f); // If any... if(this.formats.length &gt; 0) { // Add a format filter to the query and remove the format from the searched text event.query.addSelect(this.exprBuilder.makeOrExpr(&quot;docformat&quot;, this.formats), &quot;docformat&quot;); for(let format of this.formats){ event.query.text = event.query.text?.replace(new RegExp(&quot;\\\\s*\\\\b&quot;+format+&quot;\\\\b\\\\s*&quot;, &quot;i&quot;), &quot; &quot;).trim(); } // Cancel the current search event.cancelSearch = true; // Create a new search this.searchService.search(); } } }   Notice that we cancel the current search and create a new one. This is not stricly mandatory, and it would also work to only modify the query. But the problem with that is that the URL would contain the old query, not the modified query. The URL would reflect the actual search parameters only on the next search, which is not very satisfying.  One limit of this type of Query Intent is that the user may have actually meant to search for the term &quot;pdf&quot;. Therefore, it is important to give them the possibility of forcing that search and ignoring the Query Intent. To do so, we can develop a component similar to the &quot;Did you mean&quot; component:  @Component({ selector: 'sq-query-intent-format', template: ` &lt;div *ngIf=&quot;queryIntentService.formats?.length&quot;&gt; Did you mean to filter by formats? &lt;a href=&quot;#&quot; (click)=&quot;cancel()&quot;&gt;cancel&lt;/a&gt; &lt;/div&gt; ` }) export class QueryIntentFormatComponent { constructor( public queryIntentService: QueryIntentService ){} cancel() { this.queryIntentService.cancelFormats(); return false; } }   This component is displayed only when the QueryIntentService has detected formats and modified the query. We just need to implement the cancelFormats() method on the service. This can be done in different ways, but in our case, let's assume we want to disable the format detection once and for all (until the app is reloaded):   ignoreFormat = false; cancelFormats() { // Remove the docformat selection this.searchService.query.removeSelect(&quot;docformat&quot;); // Put back the format name in the query text const text = this.searchService.query.text? [this.searchService.query.text] : []; this.searchService.query.text = text.concat(this.formats).join(&quot; &quot;); // Search again this.searchService.search(); // Set a flat to turn off format detection this.ignoreFormat = true; this.formats = []; } processFormats(event: SearchService.NewQueryIntentsEvent) { // Turn off the format detection in our existing processFormats() method if(!event.query.findSelect(&quot;docformat&quot;) &amp;&amp; !this.ignoreFormat) { ... } }   Result of searching &quot;code civil pdf&quot; ","version":"Next","tagName":"h3"},{"title":"Third-Party libraries","type":0,"sectionRef":"#","url":"/dokku/docs/tipstricks/thirdparty","content":"Third-Party libraries Adding third-party libraries to your SBA works just like with a regular Angular application. See the official documentation. When you install a new library, say with npm install d3, npm also installs the dependencies of this library, and modifies your package.json file accordingly. This can potentially have side effects on the Sinequa libraries (which maybe rely on the same dependencies, but a different version). When you install new libraries: Always check what happened in your package.json file. Use Git to look for the added libraries and the changes of version.Always rebuild the Sinequa libraries (@sinequa/core and @sinequa/components). Also note that you can install dependencies specifically for your application, without affecting the rest of the workspace (although this does not solve possible conflicts of version mentioned above). To do so, add a package.json file at the root of your application. You can then add libraries as usual with npm install. Your imports will be correctly resolved in the new node_modules/ folder, as well as in the other node_modules/ folder at the root of the workspace (the first one takes precedence).","keywords":"","version":"Next"},{"title":"User preferences","type":0,"sectionRef":"#","url":"/dokku/docs/tipstricks/user-preferences","content":"User preferences Users expect the app to &quot;remember&quot; their decisions and not have to re-apply the same simple settings every time. There two main mechanisms to enable this: localStorage: Store string key/value string pairs in the user's browser (note that in case of multiple devices you have to apply the setting once on each device). Sinequa User Settings: Store arbitrary objects tied to the user on the Sinequa server. User Settings is a general system supporting many specific features. One of them is the User Preferences, which allow you to store arbitrary key/value data for specific features of your app. Note that: User settings (and preferences) are limited to small objects! There is no pagination system, and all the data is downloaded on the application started.User settings (and preferences) are available post-login, which means you cannot use them to store the theme of the app or the preferred language (since you need them even before the user is logged in). To store information in the User Preferences, do the following: Import UserPreferences from @sinequa/components/user-settings and inject it in your constructor: import { UserPreferences } from '@sinequa/components/user-settings'; ... constructor( ... public prefs: UserPreferences ) You can then read from the preferences (post-login) with: let value = this.prefs.get(&quot;some-parameter&quot;); And write (post-login) with: this.prefs.set(&quot;some-parameter&quot;, value); Note: if you need to know whether login is complete or not, import the LoginService from sinequa/core/login and test the (boolean) value of loginService.complete.","keywords":"","version":"Next"},{"title":"SBA Framework tutorial","type":0,"sectionRef":"#","url":"/dokku/docs/tutorial","content":"SBA Framework tutorial This section contains a tutorial to build your first SBA, starting from the Hello Search application.","keywords":"","version":"Next"},{"title":"Application Startup","type":0,"sectionRef":"#","url":"/dokku/docs/tipstricks/startup","content":"","keywords":"","version":"Next"},{"title":"Angular Startup​","type":1,"pageTitle":"Application Startup","url":"/dokku/docs/tipstricks/startup#angular-startup","content":" The very first HTTP request is the one that downloads your application's index.html. This file is very short, because the content of the application is downloaded separately. The HTML essentially contains references to your application's scripts and styles, and the body only contains some placeholder elements displayed prior to your scripts execution. The &lt;app&gt; element is where Angular is going to build the application.  &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Vanilla Search&lt;/title&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,shrink-to-fit=no&quot;&gt; &lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot; href=&quot;assets/vanilla-favicon.png&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;app.e7f07e699a63ac84627f.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;app&gt; &lt;div class=&quot;h-100 d-flex flex-column justify-content-center align-items-center&quot;&gt; &lt;img id=&quot;sinequa-logo&quot; class=&quot;mb-3&quot; src=&quot;assets/sinequa-logo-light-lg.png&quot; width=&quot;180px&quot;&gt; &lt;img src=&quot;assets/loading.gif&quot;&gt; &lt;/div&gt; &lt;/app&gt; &lt;script src=&quot;runtime-es2015.c4eb816dab7c85f6f92f.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt; &lt;script src=&quot;polyfills-es2015.664a2443c66af66d5b66.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt; &lt;script src=&quot;main-es2015.06f35789ec82dfebff6b.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;   Your Angular code and libraries are all bundled into one main file. When the browser finishes downloading it, it is executed. The first step corresponds to the main.ts file in your app's source code, which contains the following line:  platformBrowserDynamic().bootstrapModule(AppModule, {preserveWhitespaces: true})   Here, we tell Angular to load the AppModule (defined in the app/app.module.ts file). The AppModule is the root module of your application. It is very central in any Angular project, as it is where you define your routes, components, dependencies and a few other things.  ","version":"Next","tagName":"h2"},{"title":"AppModule Breakdown​","type":1,"pageTitle":"Application Startup","url":"/dokku/docs/tipstricks/startup#appmodule-breakdown","content":" In Sinequa application samples (like Vanilla Search), the AppModule is where you define and configure:  The startup configuration (StartConfig object).The application's routes (Routes object from Angular).The &quot;search options&quot; of the SearchService (SearchOptions object).The supported languages of the applications (LocaleConfig object).The screen size breakpoints of the application.Optionally, the &quot;selection options&quot; of the SelectionService (SelectionOptions object).Optionally, the list of &quot;results views&quot; of the application (ResultsView objects).The list of Sinequa or third-party Angular modules used by the application.The list of components of the application (including the root component, generally called AppComponent and defined in the bootstrap list. The selector of this component must correspond to the one defined in the index.html mentioned above)The list of providers of the application, in particular the HTTP_INTERCEPTORS (which allow to perform custom actions when HTTP requests are sent by the app) and APP_INITIALIZER (custom actions executed during the application startup).  ","version":"Next","tagName":"h2"},{"title":"Startup Configuration​","type":1,"pageTitle":"Application Startup","url":"/dokku/docs/tipstricks/startup#startup-configuration","content":" The StartConfig object contains basic information needed by components and services in the application, like the name of App (which must be defined on the Sinequa server).  The StartConfig data can be populated in 2 different ways:  Manually: the values are directly written in app.module.ts (and/or in environment.ts, if the data is environment-dependent). Automatically: You can activate the StartConfigInitializer (it is commented out by default) so that the StartConfig is fetched automatically from the server. This approach is convenient, but has two issues: It requires that your app is served from a URL with the pattern /app/&lt;app-name&gt; (which is the case if the app is deployed in Sinequa, but not if you are using ng serve).It makes an extra web service call to fetch the data from the server, which slows down the application startup.  The key properties of the StartConfig are the following:  app (required): The name of the App defined on the Sinequa server.url (optional): Can be used to specify the URL of the Sinequa server when the app is hosted at a different address. (By default, the app's URL is used to query the web services.)auditEnabled (optional): Whether the audit is enabled in the app.autoOAuthProvider and autoSAMLProvider, which are necessary for some Login Methods.production (optional): A flag indicating whether the app is running in production mode or not.  ","version":"Next","tagName":"h3"},{"title":"Application Routes​","type":1,"pageTitle":"Application Startup","url":"/dokku/docs/tipstricks/startup#application-routes","content":" An Angular application can have multiple &quot;routes&quot;. A route is a URL scheme, allowing to switch between different views and resources.  For instance, Vanilla Search has 3 routes: /home (displays the home page), /search (displays search results) and /preview (displays a document's preview). These 3 routes are defined as follows:  export const routes: Routes = [ {path: &quot;home&quot;, component: HomeComponent}, {path: &quot;search&quot;, component: SearchComponent}, {path: &quot;preview&quot;, component: PreviewComponent}, {path: &quot;**&quot;, redirectTo: &quot;home&quot;} ];   These routes must be injected in the RouterModule (a standard Angular module providing components and services for managing route changes).  @NgModule({ imports: [ RouterModule.forRoot(routes), ...   ","version":"Next","tagName":"h3"},{"title":"Search Options​","type":1,"pageTitle":"Application Startup","url":"/dokku/docs/tipstricks/startup#search-options","content":" The SearchOptions object contains configuration required by Sinequa's SearchService. In Vanilla Search, it is configured as follows:  export const searchOptions: SearchOptions = { routes: [&quot;search&quot;], homeRoute: &quot;home&quot; };   Effectively, this tells the SearchService that /search is a &quot;search route&quot; (where we need to monitor the URL for changes in the query, and update search results accordingly). The homeRoute is also needed in some case.  The SearchOptions also contains the following options:  deactivateRouting can be used to deactivate the storage of the search query in the URL (which means the query is not persisted in case of a page refresh).preventQueryNameChanges can be used to explicitly forbid the use of a query web service different from the primary one.  These search options must be injected in the BsSearchModule:  @NgModule({ imports: [ BsSearchModule.forRoot(searchOptions), ...   ","version":"Next","tagName":"h3"},{"title":"Languages​","type":1,"pageTitle":"Application Startup","url":"/dokku/docs/tipstricks/startup#languages","content":" The language configuration is covered at length in the tutorial.  The language configuration must be injected in the IntlModule:  @NgModule({ imports: [ IntlModule.forRoot(AppLocalesConfig), ...   ","version":"Next","tagName":"h3"},{"title":"Screen Size Breakpoints​","type":1,"pageTitle":"Application Startup","url":"/dokku/docs/tipstricks/startup#screen-size-breakpoints","content":" Applications like Vanilla Search use Bootstrap for styling the app and making it work on multiple screen sizes. In addition to Bootstrap styles, the app actively monitors the screen size and adjusts its content in function of the size interval. These size intervals (which should be aligned with the Bootstrap ones) are defined as follows:  export const breakpoints = { xl: &quot;(min-width: 1650px)&quot;, lg: &quot;(min-width: 1400px) and (max-width: 1649.98px)&quot;, md: &quot;(min-width: 992px) and (max-width: 1399.98px)&quot;, sm: &quot;(min-width: 576px) and (max-width: 991.98px)&quot;, xs: &quot;(max-width: 575.98px)&quot;, };   (The .98 decimal values are needed to avoid overlaps of the intervals)  These breakpoints must be injected in the list of providers (they are used essentially by the UIService):  @NgModule({ ... providers: [ {provide: SCREEN_SIZE_RULES, useValue: breakpoints},   ","version":"Next","tagName":"h3"},{"title":"Selection Options​","type":1,"pageTitle":"Application Startup","url":"/dokku/docs/tipstricks/startup#selection-options","content":" The selection options (SelectionOptions) allow to customize the behavior of the SelectionService, which keeps track of the documents selected by the user via checkboxes (aka selectors).  The options are detailed in the documentation of the SelectionModule.  These options must be injected in the list of providers:  @NgModule({ ... providers: [ {provide: SELECTION_OPTIONS, useValue: mySelectionOptions},   ","version":"Next","tagName":"h3"},{"title":"Help folder settings​","type":1,"pageTitle":"Application Startup","url":"/dokku/docs/tipstricks/startup#help-folder-settings","content":" The folder settings allow you to customize the help's folder to use within the application.  @NgModule()({ ... providers: [ { provide: APP_HELP_FOLDER_OPTIONS, useValue: { folder: 'vanilla-search' } },   useValue expect an object of typeFolderOptions  export type FolderOptions = { folder: string, path?: string, indexFile?: string, useLocale?: boolean, useLocaleAsPrefix?: boolean }   We can instead provide this settings using the custom JSON configuration associated with the application in the administration page: Search-Based-Applications/Apps/&lt;app_name&gt;  The Json key to use with, is:  &quot;help-folder-options&quot;: { &quot;folder&quot;: string, &quot;path&quot;: string, &quot;indexFile&quot;: string, &quot;useLocale&quot;: boolean, &quot;useLocaleAsPrefix&quot;: boolean }   Where  folder (required): the folder name should exists in:path/to/help/&lt;folder&gt;path (optional): the full pathname where the help's files are located.indexFile (optional): is the html file to open when the user click on the help menu action eg: index.html.useLocale (optional) when true, help's folder should be put inside a locale sub-folder (en, fr, de, ...), eg: path/to/help/&lt;locale&gt;/...when false, no sub-folder will be used. useLocaleAsPrefix (optional) when true, index file is prefixed by the locale followed by a dot character eg: en., eg: path/to/help/&lt;locale&gt;.index.htmlwhen false, only indexFile is used to identify the file to open or the indexFile.  ","version":"Next","tagName":"h3"},{"title":"Results Views​","type":1,"pageTitle":"Application Startup","url":"/dokku/docs/tipstricks/startup#results-views","content":" Results views can be configured to display search results in different ways. The configuration is described in the documentation of the Results Views module.  The list of views (ResultsView objects) and the default one must be injected in the BsResultsViewModule:  @NgModule({ imports: [ BsResultsViewModule.forRoot(allViews, defaultView) ...   ","version":"Next","tagName":"h3"},{"title":"List of Modules​","type":1,"pageTitle":"Application Startup","url":"/dokku/docs/tipstricks/startup#list-of-modules","content":" The AppModule is the root module of the application. It is where we define the list of submodules (dependencies) used by the app. These can include Angular modules (like BrowserModule, RouterModule or FormsModule), Sinequa modules (like WebServicesModule, LoginModule, etc.) or third-party modules (like FusionChartsModule).  The list of imported submodules is defined within the @NgModule construct:  @NgModule({ imports: [ ... ] })   Importing a module gives us access to the components and directives that it encapsulate.  However, sometimes these components require some global input configuration. This is why we often need to call a .forRoot() method.  In the case of the Results View module above, we call the forRoot() method to inject the list of views, so that the components and services of this module have access to them:  BsResultsViewModule.forRoot(allViews, defaultView)   ","version":"Next","tagName":"h3"},{"title":"List of Components​","type":1,"pageTitle":"Application Startup","url":"/dokku/docs/tipstricks/startup#list-of-components","content":" An application can use components defined in imported modules, but it can also have components of its own (at the very least the root AppComponent). These components must be added to the list of declarations of the AppModule.  The list of components is defined within the @NgModule construct:  @NgModule({ declarations: [ ... ] })   ","version":"Next","tagName":"h3"},{"title":"List of Providers​","type":1,"pageTitle":"Application Startup","url":"/dokku/docs/tipstricks/startup#list-of-providers","content":" A provider is an instruction to the Dependency Injection system of Angular on how to obtain a value for a dependency.  In the AppModule, we see typically three types of providers:  APP_INITIALIZER: An app initializer is a piece of code that can be inserted in the Angular initialization process (before Angular starts rendering components). It can be especially useful to fetch some required configuration from the server. The @sinequa/core library already injects a few initializers implicitly, but it is possible to add new ones. In particular, we provide a StartConfigInitializer to automatically fetch configuration from the Sinequa server (see Startup configuration). HTTP_INTERCEPTORS: An HTTP interceptor is a piece of code that hooks into the Angular HTTP client. It can &quot;intercept&quot; any request sent to the server, to perform some global actions. By default, three interceptors are injected: The LoginInterceptor takes care of triggering the authentication process when the server sends back a 401 error (Unauthorized). When the authentication is complete, the interceptor plays back the failed query. See Login methods.The AuditInterceptor takes care of normalizing the Audit event messages sent to the server via any web service call. It can be overridden to customize all the audit events across the app. See Auditing applications.The NotificationsInterceptor takes care of displaying notifications coming from the server (Notifications can be included via a $notifications array appended to the JSON response). Global configuration: As seen above, some configuration must sometimes be injected via the list of providers (SCREEN_SIZE_RULES, SELECTION_OPTIONS, LocationStrategy, APP_HELP_FOLDER_OPTIONS)  ","version":"Next","tagName":"h3"},{"title":"AppComponent​","type":1,"pageTitle":"Application Startup","url":"/dokku/docs/tipstricks/startup#appcomponent","content":" Once the AppModule is loaded, Angular renders the root component of the application, the AppComponent.  In Vanilla Search, the AppComponent does three important things:  In the controller (app.component.ts), notice that the component extends ComponentWithLogin. This parent component takes care of initiating the login process (calling LoginService.login() method). This means the login process is always initiated regardless of the active route.In the onLoginComplete() method, some initialization tasks are implemented (these tasks could only be performed post-login). In particular, the action bar's selectionActions are populated (in function of the features activated in the configuration).In the template (app.component.html) we include the &lt;router-outlet&gt; component. The role of the outlet is to display the currently active route. In vanilla the default route is the /home route, displaying the HomeComponent. Note that the route component is displayed even if the user is not logged in.  The Login process is described extensively in Login Methods. It is important to be aware that a common source of error is trying to perform some actions requiring to be logged in, without verifying whether or not it is the case. Because of point 3) above, it is very important to include checks in the applications, such as:  &lt;h1 *ngIf=&quot;loginService.complete&quot;&gt; Hello {{principalService.principal.fullName}}! &lt;/h1&gt;   It is also frequently required to perform tasks upon login or logout events. The correct way to do so is to subscribe to the LoginService events:  this.loginSubscription = this.loginService.events.subscribe(event =&gt; { if (event.type === &quot;session-start&quot;) { ... } });  ","version":"Next","tagName":"h2"},{"title":"Connection to the Sinequa server","type":0,"sectionRef":"#","url":"/dokku/docs/tutorial/connection","content":"Connection to the Sinequa server In this chapter we need to connect the Hello Search app to the Sinequa test server. The URL of this server is: https://su-sba.demo.sinequa.com and the name of the SBA configured on the server is just 'training'. Additionally, the app is secured with the SAML protocol. The name of the identity provider is 'identity-dev'. In your hello-search/ project, open the src/app/app.module.ts file, and replace the placeholders parameters in the StartConfig object: export const startConfig: StartConfig = { app: &quot;training&quot;, autoSAMLProvider: &quot;identity-dev&quot;, production: environment.production, auditEnabled: true }; Notice that this startConfig object gets passed to the WebServiceModule from @sinequa/core. In fact, the forRoot() method adds this object to the list of providers, and Angular then injects it in all the web services (which then know the URL of the server and can send queries to it). At this point, you can build and serve your app (from the root of the workspace) with: npm run ng serve hello-search -- --ssl=true --proxy-config=./projects/hello-search/src/proxy.conf.json Please read the Getting Started section if you wonder about the proxyConfig argument. If the build is successful, you can navigate to https://localhost:4200 in your favorite web browser. You should be greeted by a login page (this is where your need your Sinequa account). Put in your credentials and you should be redirected to the simplest of search pages. Type some keywords and search! Note: the searchable content is composed of a few wikipedia pages and the Sinequa documentation. Before going to the next step, take some time to analyze the source code of Hello Search and more specifically the src/app/ subfolder, to fully understand its internal logic.","keywords":"","version":"Next"},{"title":"User Settings","type":0,"sectionRef":"#","url":"/dokku/docs/tipstricks/user-settings","content":"","keywords":"","version":"Next"},{"title":"Developing your own User-Settings service​","type":1,"pageTitle":"User Settings","url":"/dokku/docs/tipstricks/user-settings#developing-your-own-user-settings-service","content":" The Tutorial already introduces the main characteristics of a User-Settings service. In this section, we will go through the code of the Recent Queries service (RecentQueriesService) step by step, to explain the role of each part (other services follow a very similar structure).  ","version":"Next","tagName":"h2"},{"title":"Data structure​","type":1,"pageTitle":"User Settings","url":"/dokku/docs/tipstricks/user-settings#data-structure","content":" The data structure is the type of object you want to store in the user-settings, on the server-side. In the case of the Recent Queries, it is the query object (which contains the searched text and filters), and the date at which this query was made.  export interface RecentQuery { query: Query; date: Date; }   ","version":"Next","tagName":"h3"},{"title":"Events and Event types​","type":1,"pageTitle":"User Settings","url":"/dokku/docs/tipstricks/user-settings#events-and-event-types","content":" Your service should not be a black box. It should enable a Sinequa administrator to monitor its activity with Audit event and enable other SBA services to use its features and be notified of its state changes.  The following code includes:  Event types: The list of all events possibly occurring in the service. These will be used for both the audit and the internal events.Change event types: This is a sublist of the event types which contains only the event that result in a change of the data (this is useful to refresh menus for example).Change event interface: An interface that contains an event type and an optional recent query object (the piece of data that has changed).  // from core/models/audit export const enum RecentQueryEventType { Loaded = &quot;RecentQuery_Loaded&quot;, Patched = &quot;RecentQuery_Patched&quot;, Add = &quot;RecentQuery_Add&quot;, Update = &quot;RecentQuery_Update&quot;, Delete = &quot;RecentQuery_Delete&quot;, Search = &quot;Search_RecentQuery&quot; } // Types of events triggering a change event export const RECENT_QUERIES_CHANGE_EVENTS = [ RecentQueryEventType.Add, RecentQueryEventType.Update, RecentQueryEventType.Delete, ]; // CRUD Events export interface RecentQueryChangeEvent { type: RecentQueryEventType; recentquery?: RecentQuery; }   ","version":"Next","tagName":"h3"},{"title":"Injection token​","type":1,"pageTitle":"User Settings","url":"/dokku/docs/tipstricks/user-settings#injection-token","content":" A service can be configured with global parameters, via injection tokens. Here, we define a token named MAX_QUERIES (for a parameter of type Number), which we need to define a maximum number of recent queries to be stored by the service.  export const MAX_QUERIES = new InjectionToken&lt;Number&gt;(&quot;MAX_QUERIES&quot;);   ","version":"Next","tagName":"h3"},{"title":"Class declaration and Constructor​","type":1,"pageTitle":"User Settings","url":"/dokku/docs/tipstricks/user-settings#class-declaration-and-constructor","content":" Our service is defined like a regular service, using the Injectable annotation.  By convention, we define two private sources of events (_events and _changes, where _changes triggers a subset of the events of _events, as defined above), and their public getters defined below (get changes() and get events()).  The constructor includes other services (in particular UserSettingsWebService), and the (optional) maxQueries parameter injected via the InjectionToken defined above (to inject a value for this parameter, add a provider to your app.module.ts, like { provide: MAX_QUERIES, useValue: 50 }).  The service immediately subscribes to 3 types of events:  User Settings events, which trigger when the data is first loaded (the event is simply &quot;forwarded&quot; by this service).Its own events (this._events), which is simply used to emit the &quot;change&quot; events (as defined above), in function on their event type.External service(s): In this case we subscribe to SearchService events and create a new RecentQuery every time a query is created or modified.  recent-queries.service.ts @Injectable({ providedIn: 'root', }) export class RecentQueriesService implements OnDestroy { private readonly _events = new Subject&lt;RecentQueryChangeEvent&gt;(); private readonly _changes = new Subject&lt;RecentQueryChangeEvent&gt;(); constructor( public userSettingsService: UserSettingsWebService, public searchService: SearchService, @Optional() @Inject(MAX_QUERIES) private maxQueries: number, ){ if(!this.maxQueries){ this.maxQueries = 20; } // Listen to the user settings this.userSettingsService.events.subscribe(event =&gt; { // E.g. new login occurs // ==&gt; Menus need to be rebuilt this.events.next({type: RecentQueryEventType.Loaded}); }); // Listen to own events, to trigger change events this._events.subscribe(event =&gt; { if(RECENT_QUERIES_CHANGE_EVENTS.indexOf(event.type) !== -1){ this.changes.next(event); } }); // Listen to search service and store queries this.searchService.queryStream.subscribe({ next: (query: Query) =&gt; { if(query) this.addRecentQuery({query: query.copy(), date: new Date()}); } }) } /** * Triggers any event among RecentQueryChangeEvent * (use for fine-grained control of recent queries workflow) */ public get events() : Subject&lt;RecentQueryChangeEvent&gt; { return this._events; } /** * Triggers when events affect the list of recent queries * (use to refresh recent queries menus) * Cf. CHANGE_EVENTS list */ public get changes() : Subject&lt;RecentQueryChangeEvent&gt; { return this._changes; }   ","version":"Next","tagName":"h3"},{"title":"CRUD API: Read​","type":1,"pageTitle":"User Settings","url":"/dokku/docs/tipstricks/user-settings#crud-api-read","content":" The following methods allow to retrieve the list of recent queries, directly from the User Settings. Notice that this.recentqueries is just a proxy for this.userSettingsService.userSettings[&quot;recentQueries&quot;], and this value is initialized as an empty list if it does not exist. Also notice in the code of recentquery() and recentqueryIndex() that recent queries are identified by their query.text: This is a strong assumption since a Query object has many other fields, but this allows to avoid near-duplicate queries and to store only the latest value (likely most relevant).  recent-queries.service.ts /** * Returns the list of this user's recent queries. * The list is stored in the user settings (this is a redirection). * Using this service creates the list of recent queries if it does not already exist. */ public get recentqueries() : RecentQuery[]{ if(!this.userSettingsService.userSettings) this.userSettingsService.userSettings = {}; if(!this.userSettingsService.userSettings[&quot;recentQueries&quot;]) this.userSettingsService.userSettings[&quot;recentQueries&quot;] = []; return this.userSettingsService.userSettings[&quot;recentQueries&quot;]; } /** * @returns true if there is at least one recent query */ public get hasRecentQuery(): boolean { return this.recentqueries.length &gt; 0; } /** * @returns a recent query with the given name or null if it does not exist * @param name */ public recentquery(text: string): RecentQuery { let i = this.recentqueryIndex(text); return i&gt;= 0? this.recentqueries[i] : null; } private recentqueryIndex(text: string): number { for (let i = 0, ic = this.recentqueries.length; i &lt; ic; i++) { let recentquery = this.recentqueries[i]; if (recentquery &amp;&amp; recentquery.query.text === text) { return i; } } return -1; }   ","version":"Next","tagName":"h3"},{"title":"CRUD API: Create and Update​","type":1,"pageTitle":"User Settings","url":"/dokku/docs/tipstricks/user-settings#crud-api-create-and-update","content":" The addRecentQuery() method allows to add a recent query to the user settings. It performs the following actions:  Check that the input RecentQuery is valid.Check whether a recent query with the same text already exists. If so, only update the content of the existing object. If not, add the object to the user settings. In either case, it emits an event.Sort the list with a comparator, to keep the most recent queries on top of the list.Truncate the list based on the maxQueries parameter.Patch the User Settings (we only update the server with the part of the user settings that changed), which includes sending an Audit event.  recent-queries.service.ts /** * Creates a new recent query unless it already exists, in which case the existing query is updated. * Emits an recentquery event. * Update the data on the server. * @param recentquery the recentquery to create * @returns true if recentquery was created */ public addRecentQuery(recentquery: RecentQuery) : boolean { if(!recentquery.query || !recentquery.query.text || recentquery.query.text.trim() === ''){ return false; } let i = this.recentqueryIndex(recentquery.query.text); // If the query already exists if(i &gt;= 0){ // Ignore identical queries issued within a certain time window (1s) // to avoid flooding the server. NB the request flooding mitigation in // SqHttpClient will not work in this case as the request payload includes // a timestamp if (Math.abs(recentquery.date.getTime() - this.recentqueries[i].date.getTime()) &lt; 1000) { if (Utils.equals(this.recentqueries[i].query, recentquery.query)) { return false; } } this.recentqueries[i].date = recentquery.date; // Update the date of the existing query this.recentqueries[i].query = recentquery.query; this.events.next({type : RecentQueryEventType.Update, recentquery: this.recentqueries[i]}); } else { this.recentqueries.push(recentquery); this.events.next({type : RecentQueryEventType.Add, recentquery: recentquery}); } // Sort the list this.recentqueries.sort(this.comparator); // Truncate the list if(this.maxQueries &gt;=0 ) this.recentqueries.splice(this.maxQueries); this.patchRecentQueries([{ type: RecentQueryEventType.Add, detail: { recentquery: recentquery.query.text } }]); return true; }   ","version":"Next","tagName":"h3"},{"title":"CRUD API: Delete​","type":1,"pageTitle":"User Settings","url":"/dokku/docs/tipstricks/user-settings#crud-api-delete","content":" The deleteRecentQuery() allows to delete a query from the user settings, based on the content of query.text (which should be unique, as explained above). The method also emits an event and updates the server, including an audit event.  recent-queries.service.ts /** * Deletes the given RecentQuery (based on its query.text) * Emits an RecentQuery event. * Update the data on the server. * @param recentquery * @returns true if recent query was deleted */ public deleteRecentQuery(recentquery: RecentQuery) : boolean { let index = this.recentqueryIndex(recentquery.query.text); if(index === -1) return false; // Nothing to delete this.recentqueries.splice(index, 1); this.events.next({type : RecentQueryEventType.Delete, recentquery: recentquery}); this.patchRecentQueries([ { type: RecentQueryEventType.Delete, detail: { recentquery: recentquery.query.text } } ]); return true; }   ","version":"Next","tagName":"h3"},{"title":"User Settings patch​","type":1,"pageTitle":"User Settings","url":"/dokku/docs/tipstricks/user-settings#user-settings-patch","content":" This private method is used by addRecentQuery() and deleteRecentQuery() to patch the user settings on the server, via the UserSettingsWebService.patch() method.  recent-queries.service.ts /** * Updates Recent Queries in User settings. * @param auditEvents : Audit Events to be triggered * @returns an Observable which can be used to trigger further events */ private patchRecentQueries(auditEvents: AuditEvents = null) { return this.userSettingsService.patch({recentQueries: this.recentqueries}, auditEvents) .subscribe( next =&gt; { this.events.next({type: RecentQueryEventType.Patched}); }, error =&gt; { console.error(&quot;Could not patch Recent queries!&quot;, error); } ); }   ","version":"Next","tagName":"h3"},{"title":"Other features​","type":1,"pageTitle":"User Settings","url":"/dokku/docs/tipstricks/user-settings#other-features","content":" Your service can be a bit more than just a proxy to the UserSettingsWebService. In this case, we include a method to search a RecentQuery via the SearchService (if a user selects it in a facet for example).  recent-queries.service.ts /** * Uses the SearchService to perform a search returning all * the documents matching this recent query. * @param recentquery * @returns the search service promise */ searchRecentQuery(recentquery: RecentQuery, path?: string): Promise&lt;boolean&gt; { this.searchService.query = Utils.extend(this.searchService.makeQuery(), Utils.copy(recentquery.query)); this.events.next({type: RecentQueryEventType.Search, recentquery: recentquery}); return this.searchService.search({ path: path }, { type: RecentQueryEventType.Search, detail: { recentquery: recentquery.query.text } }); }   Other services include high-level features to interact with the CRUD API. For example, the Alerts service lets you display a modal popup to create and edit an alert, and only then calls a addAlert method. ","version":"Next","tagName":"h3"},{"title":"Autocomplete","type":0,"sectionRef":"#","url":"/dokku/docs/tutorial/autocomplete","content":"","keywords":"","version":"Next"},{"title":"Importing the Search Form component​","type":1,"pageTitle":"Autocomplete","url":"/dokku/docs/tutorial/autocomplete#importing-the-search-form-component","content":" We will start by changing the search input with SearchFormComponent. In your app.module.ts, import it and add it to the NgModule declaration:  app.module.ts import { SearchFormComponent } from '@sinequa/components/search-form'; @NgModule({ imports: [ ... SearchFormComponent   The component simplifies the search handling with the minimum configuration required. It also allows to provide a template in which you can provide the autocompletion.  ","version":"Next","tagName":"h2"},{"title":"Refactoring the form​","type":1,"pageTitle":"Autocomplete","url":"/dokku/docs/tutorial/autocomplete#refactoring-the-form","content":" First, replace the whole &lt;form&gt; with the search form:  app.component.html &lt;h1&gt;Hello Search 🔍&lt;/h1&gt; &lt;div class=&quot;d-flex flex-column flex-grow-1 position-relative mb-5&quot;&gt; &lt;sq-search-form [query]=&quot;searchService.query&quot; [searchRoute]=&quot;''&quot;&gt;&lt;/sq-search-form&gt; &lt;/div&gt; &lt;div *ngIf=&quot;searchService.resultsStream | async; let results&quot;&gt;   Notice that we have have to provide the searchRoute input as an empty string since the search will redirect to this page upon submit, and the default value for the SBA is /search.  You can also remove the no longer used code inside app.component.ts:  The search() methodThe clear() method (and its usage inside logout())The searchControl and form variablesEverything in the constructor() except for the languageActions setupThe unused UntypedFormGroup and UntypedFormControl imports  There are some missing translations, to add them you need to add to your dictionaries the corresponding file:  import {enSearchForm} from &quot;@sinequa/components/search-form&quot;; ... messages: Utils.merge({}, ..., enSearchForm, appMessages)   Your form should now look like this:    ","version":"Next","tagName":"h2"},{"title":"Create the Autocomplete component​","type":1,"pageTitle":"Autocomplete","url":"/dokku/docs/tutorial/autocomplete#create-the-autocomplete-component","content":" We want to handle the autocomplete display inside its own component. Let's create a new component in src/app/ named autocomplete.ts.  autocomplete.ts import { Component, OnInit } from &quot;@angular/core&quot;; import { Observable, of } from &quot;rxjs&quot;; @Component({ selector: &quot;autocomplete&quot;, template: ` &lt;span *ngIf=&quot;items$ | async; let items&quot;&gt;{{items}}&lt;/span&gt; `, styles: [` `] }) export class Autocomplete implements OnInit { items$: Observable&lt;string&gt;; constructor() { } ngOnInit() { this.items$ = of('Hello world'); } }   In this code, you have items$ being an Observable, meaning that you can watch it to retrieve in an asynchronous way some data. Here, you don't yet make any call but you pass the string &quot;Hello world&quot; using the rxjs of() method that allows to inject some data asynchronously.  ","version":"Next","tagName":"h2"},{"title":"Display the Autocomplete component​","type":1,"pageTitle":"Autocomplete","url":"/dokku/docs/tutorial/autocomplete#display-the-autocomplete-component","content":" Now that the component is defined, you have to declare it in your app.module.ts.  import { Autocomplete } from &quot;./autocomplete&quot;; @NgModule({ declarations: [ ... Autocomplete   Let's now add the ng-template containing the autocomplete inside &lt;sq-search-form&gt;:  &lt;sq-search-form [query]=&quot;searchService.query&quot; [searchRoute]=&quot;''&quot;&gt; &lt;ng-template&gt; &lt;autocomplete&gt;&lt;/autocomplete&gt; &lt;/ng-template&gt; &lt;/sq-search-form&gt;   You should now see a &quot;Hello world&quot; appear when you click on the input:    ","version":"Next","tagName":"h2"},{"title":"Add the user input​","type":1,"pageTitle":"Autocomplete","url":"/dokku/docs/tutorial/autocomplete#add-the-user-input","content":" sq-search-form allows to pass variables to its template, so you now can add a new input to autocomplete to retrieve the query text.  Let's add the input to the component and change items$ to return the input value:  autocomplete.ts import { Input, OnChanges } from &quot;@angular/core&quot;; import { ReplaySubject } from &quot;rxjs&quot;; export class Autocomplete implements OnChanges, OnInit { @Input() queryText: string; inputChange$ = new ReplaySubject(1); items$: any; ngOnInit() { this.items$ = this.inputChange$; } ngOnChanges() { this.inputChange$.next(this.queryText); } ...   Then you can provide it to &lt;autocomplete&gt;:  &lt;sq-search-form [query]=&quot;searchService.query&quot; [searchRoute]=&quot;''&quot;&gt; &lt;ng-template let-query&gt; &lt;autocomplete [queryText]=&quot;query.text&quot;&gt;&lt;/autocomplete&gt; &lt;/ng-template&gt; &lt;/sq-search-form&gt;   It should properly appear:    ","version":"Next","tagName":"h2"},{"title":"Alter the displayed value​","type":1,"pageTitle":"Autocomplete","url":"/dokku/docs/tutorial/autocomplete#alter-the-displayed-value","content":" If you wish to apply modifications to the input value, you can use rxjs map() method. Let's simply add &quot;Hello world&quot; before the input value:  autocomplete.ts import { map } from &quot;rxjs&quot;; export class Autocomplete implements OnChanges, OnInit { items$: Observable&lt;string&gt;; ngOnInit() { this.items$ = this.inputChange$.pipe(map(text =&gt; &quot;Hello world &quot; + text)); }   And here's the result:    ","version":"Next","tagName":"h2"},{"title":"Retrieve the suggestions​","type":1,"pageTitle":"Autocomplete","url":"/dokku/docs/tutorial/autocomplete#retrieve-the-suggestions","content":" You now need to get the proper suggestions from what you type. For a better asyncronous handling of the value transformation, you can use rxjs switchMap() method which like map() allows you to change the value, but asynchronously, for example by making a call.  autocomplete.ts import { switchMap } from &quot;rxjs&quot;; import { AutocompleteItem, SuggestService } from &quot;@sinequa/components/autocomplete&quot;; @Component({ ... template: ` &lt;ul *ngIf=&quot;items$ | async; let items&quot;&gt; &lt;li *ngFor=&quot;let item of items&quot;&gt; {{item.display}} &lt;/li&gt; &lt;/ul&gt; ` }) export class Autocomplete implements OnChanges, OnInit { ... items$: Observable&lt;AutocompleteItem[] | undefined&gt;; constructor(private suggestService: SuggestService) { } ngOnInit() { this.items$ = this.inputChange$ .pipe( switchMap(text =&gt; this.suggestService.get(undefined, text as string)) // retrieve the suggestions ); } ngOnChanges() { this.inputChange$.next(this.queryText); } }   You may have a NullPointerException in the console (TypeError: Cannot read properties of undefined) since ngOnChanges() is triggered at the component creation and that the search value is empty. To fix this you can deactivate the triggering of the suggestions search using rxjs filter():  autocomplete.ts import { filter } from &quot;rxjs&quot;; this.items$ = this.inputChange$ .pipe( filter(text =&gt; !!text), // prevents searching if there is no query text switchMap(text =&gt; this.suggestService.get(undefined, text as string)) // retrieve the suggestions );   You can now see a list of suggestions when you type:    Another thing to notice is that a call is performed at every input change (so 4 calls if you try searching &quot;test&quot;). The debounceTime method can be useful here since it adds a delay before performing what follows it to make sure no more changes is expected:  this.items$ = this.inputChange$ .pipe( filter(text =&gt; !!text), // prevents searching if there is no query text debounceTime(200), // add a slight wait before retrieving the suggestions to avoid making calls at each change switchMap(text =&gt; this.suggestService.get(undefined, text as string)) // retrieve the suggestions );   That's great that we now see the suggestions, but you need to be able to choose them to replace your query. You need to incorporate the SearchService on the click action for each suggestions:  autocomplete.ts import { SearchService } from &quot;@sinequa/components/search&quot;; @Component({ selector: &quot;autocomplete&quot;, template: ` &lt;ul *ngIf=&quot;items$ | async; let items&quot;&gt; &lt;li *ngFor=&quot;let item of items&quot; (click)=&quot;search(item.display)&quot;&gt; {{item.display}} &lt;/li&gt; &lt;/ul&gt; ` ... }) export class Autocomplete implements OnChanges, OnInit { constructor(private suggestService: SuggestService, private searchService: SearchService) { } ... search(value: string) { this.searchService.query.text = value; this.searchService.searchText(); } }   Congratulations, your autocomplete works!  ","version":"Next","tagName":"h2"},{"title":"Improve the styling​","type":1,"pageTitle":"Autocomplete","url":"/dokku/docs/tutorial/autocomplete#improve-the-styling","content":" There's still one thing you may want to improve: the styling. Bootstrap provides handy classes to handle that like list-group. You can update template and styles like this:  autocomplete.ts @Component({ selector: &quot;autocomplete&quot;, template: ` &lt;div class=&quot;list-group list-group-flush&quot; *ngIf=&quot;items$ | async; let items&quot;&gt; &lt;a role=&quot;button&quot; *ngFor=&quot;let item of items&quot; class=&quot;list-group-item list-group-item-action&quot; (click)=&quot;search(item.display)&quot;&gt; {{item.display}} &lt;/a&gt; &lt;/div&gt; `, styles: [` .list-group-flush &gt; .list-group-item:last-child { border-end-start-radius: 20px; border-end-end-radius: 20px; } `] })   Now it's fully complete!   ","version":"Next","tagName":"h2"},{"title":"Facet Module","type":0,"sectionRef":"#","url":"/dokku/docs/tutorial/facet-module","content":"","keywords":"","version":"Next"},{"title":"Importing the Facet Module​","type":1,"pageTitle":"Facet Module","url":"/dokku/docs/tutorial/facet-module#importing-the-facet-module","content":" Like other modules, you have to import it in your app.module.ts file:  app.module.ts import { BsFacetModule } from '@sinequa/components/facet'; @NgModule({ imports: [ ... BsFacetModule   Unlike the BsSearchModule (and others), you do not need to use the .forRoot() method to pass configuration to the module (the method exists, but is optional).  ","version":"Next","tagName":"h2"},{"title":"Other prerequisites​","type":1,"pageTitle":"Facet Module","url":"/dokku/docs/tutorial/facet-module#other-prerequisites","content":" The Facet module includes a service, the FacetService, but there is no need to inject it in your component. This service is used internally by the components of the Facet module to manage the facet data (&quot;aggregations&quot;) and refine the search when the user actually clicks a facet item (behind the scene, the FacetService can modify SearchService.query and call SearchService.search()).  The list of aggregations needed to &quot;feed&quot; the facets is configured on the server-side in the Web services &gt; Query configuration. On the server that we use for this training, about 15 aggregations are available (you can see the full list inside the Results object with your Browser inspector).  The Facet module depends on the Bootstrap CSS library, but since we already imported Bootstrap globally in the previous chapter, there's no need to do it again.  ","version":"Next","tagName":"h2"},{"title":"Facet module components​","type":1,"pageTitle":"Facet Module","url":"/dokku/docs/tutorial/facet-module#facet-module-components","content":" You can now insert some of the Facet module components in your component's template (app.component.html).  Facets are actually composed of two components:  The outside &quot;frame&quot; or &quot;card&quot;: sq-facet-cardThe inside content, which depends of the type of data or visualization: sq-facet-list, sq-facet-tree, sq-facet-ngx-chart, sq-facet-range, sq-facet-timeline, sq-facet-refine, or in fact any other custom content you want!  We will start with a simple sq-facet-list:  app.component.html &lt;sq-facet-card [title]=&quot;'Companies'&quot; [icon]=&quot;'fas fa-building'&quot;&gt; &lt;sq-facet-list #facet [results]=&quot;results&quot; [aggregation]=&quot;'Company'&quot;&gt;&lt;/sq-facet-list&gt; &lt;/sq-facet-card&gt;   This should display something like:    Notice the #facet tag. It is important, as it allows the sq-facet-card to display the &quot;action buttons&quot; of its content in the top-right of the facet.  sq-facet-list also adapts itself automatically according to the data type. Here with a tree type:  app.component.html &lt;sq-facet-card [title]=&quot;'Sources'&quot; [icon]=&quot;'fas fa-sitemap'&quot;&gt; &lt;sq-facet-list #facet [results]=&quot;results&quot; [aggregation]=&quot;'Treepath'&quot;&gt;&lt;/sq-facet-list&gt; &lt;/sq-facet-card&gt;     The facet components have many options that can be passed via bindings. For example, here is the full list of options for sq-facet-list:  name: Internal name of the facet (Optional, by default the aggregation name is used)results: Results object (Required)aggregation: Name of the aggregation configured on the back-end (Required)query: A custom query to interfere when doing filtering actions (it uses by default the one from the SearchService)showCount: Show the number of occurrences (default: true)searchable: Allow to search for items in the facet (default: true)allowExclude: Allow to exclude selected items (default: true)allowOr: Allow to search various items in OR mode (default: true)allowAnd: Allow to search various items in AND mode (default: true)focusSearch: Whether after the page is loaded the HTML should focus on the search input (default: false)displayEmptyDistributionIntervals: Whether empty distribution intervals will be displayed if the aggregation is a distribution (default: false)acceptNonAggregationItemFilter: Whether filtered items which don't match an existing aggregation item should be added to filtered list (default: true)replaceCurrent: Whether the previous &quot;select&quot; is removed first (default: false)expandedLevel: The level to expand up to when this is a tree type of data (default: 2)  In real projects, you probably would not want to enable all these options at once. We can deactivate exclusion and the &quot;AND&quot; mode with:  app.component.html &lt;sq-facet-list #facet [results]=&quot;results&quot; [aggregation]=&quot;'Company'&quot; [allowExclude]=&quot;false&quot; [allowAnd]=&quot;false&quot;&gt;&lt;/sq-facet-list&gt;   Now the facet should look something like this when you select multiple items:    Please refer to the library documentation for more information. ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/dokku/docs/tutorial/intro","content":"","keywords":"","version":"Next"},{"title":"Starting point​","type":1,"pageTitle":"Introduction","url":"/dokku/docs/tutorial/intro#starting-point","content":" The tutorial starts at the end of the &quot;Building the libraries&quot; step of the Development section. You must have installed the required tools (NodeJs, VS Core, Git), downloaded or cloned the Angular workspace, installed the dependencies and built the @sinequa/core and @sinequa/components libraries.  Unless otherwise specified, the tutorial is based on the Hello Search app included in the workspace inside projects/hello-search/.  ","version":"Next","tagName":"h2"},{"title":"Methodology​","type":1,"pageTitle":"Introduction","url":"/dokku/docs/tutorial/intro#methodology","content":" We recommend doing this tutorial inside Visual Studio Code (with the Angular workspace root opened), and using a modern browser (Chrome, Firefox) to test and inspect your app. Keep one (or more) terminal(s) opened in VS Code, to run commands like ng serve, git status or ng generate component.  We recommend using Git to track the changes during the different steps of the tutorial. At the end of each chapter, commit your changes in a tutorial branch, to make it easy to track and revert changes, and go back in time later.  You might face runtime errors not detected during compilation. The only way to see these errors is to keep the inspector of your web browser opened, with an eye on the console.  ","version":"Next","tagName":"h2"},{"title":"Modules​","type":1,"pageTitle":"Introduction","url":"/dokku/docs/tutorial/intro#modules","content":" Module is an ambiguous term. It may refer to a typescript module, which is in fact just a .ts file, which imports variables and types from other modules and exports other variables and types. In contrast, an Angular module is a class with a NgModule annotation, which also imports other NgModule and can export Angular components, directives and pipes.  Typescript module:  import { a } from './foo'; console.log(a); export const b = a + 42;   Angular module:  import { AnotherModule } from './foo'; @NgModule({ imports: [ AnotherModule ] }) export class MyModule {}   In this tutorial, we generally refer to the second type of modules (Angular modules).  Relationships between Angular modules (blue), components (purple) and their library (green)  Some of these modules are based on the Bootstrap library. When a module or component depends on Bootstrap, its class name is prefixed with Bs (eg. BsSearchModule, BsFacetList).  The tutorial is divided in chapters which each deals with a new Sinequa feature. These features come packaged as modules of the @sinequa/components library. The illustration below depicts in more details the content of a typical module/library which you will use in this tutorial.  Content of one of the libraries (green), including modules (blue), components (purple), services (red), styles (orange) and locales (grey)  This gives you a natural checklist for dealing with these modules:  Take a look at the code of that module in the @sinequa/components library. In this example, inside: projects/components/facet/. This gives you a general idea of what components, directives and services are bundled with that module. Import the module you're interested in in your app.module.ts: import { BsFacetModule } from '@sinequa/components/facet'; @NgModule({ imports: [ ..., BsFacetModule ], ... }) ... Use the components, directives and pipes in the templates of your app: &lt;sq-facet-list [results]=&quot;...&quot;&gt;&lt;/sq-facet-list&gt; Inject the services in the constructor(s) of your component(s): import { FacetService } from '@sinequa/components/facet'; ... export class MyComponent { constructor( public facetService: FacetService ){ ... } } Some libraries include a global stylesheet that needs to be imported so that the components are correctly displayed. Import these stylesheet in your global styles\\app.scss: @import &quot;../../../components/facet/bootstrap/facet.scss&quot;; Some components contain strings that need to be translated in various languages, to internationalize your SBA. We provide translations in three languages (English, French and German) via &quot;message files&quot; which your app needs to import. Alternatively, you can ignore these files and fully rewrite the messages in your app (which is needed anyway if you are going to add additional languages). See the Internationalization chapter of the tutorial for more details. import {enFacet} from &quot;@sinequa/components/facet&quot;;  ","version":"Next","tagName":"h2"},{"title":"Preview & Modals","type":0,"sectionRef":"#","url":"/dokku/docs/tutorial/preview","content":"","keywords":"","version":"Next"},{"title":"Importing the Modal and Preview modules​","type":1,"pageTitle":"Preview & Modals","url":"/dokku/docs/tutorial/preview#importing-the-modal-and-preview-modules","content":" In your app.module.ts, import the PreviewModule and BsModalModule and add them to the NgModule declaration:  app.module.ts import { PreviewModule } from '@sinequa/components/preview'; import { BsModalModule } from '@sinequa/components/modal'; @NgModule({ imports: [ ... PreviewModule, BsModalModule   ","version":"Next","tagName":"h2"},{"title":"Opening a popup​","type":1,"pageTitle":"Preview & Modals","url":"/dokku/docs/tutorial/preview#opening-a-popup","content":" First let's try to open a popup when clicking on the title of a document. This popup is a new component.  Create a new component in src/app/, named preview.ts.  preview.ts import {Component} from &quot;@angular/core&quot;; @Component({ selector: &quot;preview&quot;, template: ` &lt;sq-modal [title]=&quot;'Hello world'&quot;&gt; Hello world &lt;/sq-modal&gt; ` }) export class Preview {}   Add this Preview component to the list of declarations in your app.module.ts.  app.module.ts import { Preview } from './preview'; @NgModule({ ... declarations: [ ... Preview   Now, in our app.component.ts, let's create a method openDocument() to open our new component with the ModalService:  app.component.ts import { Record } from '@sinequa/core/web-services'; import { ModalService } from '@sinequa/core/modal'; import { Preview } from './preview'; export class AppComponent implements AfterViewInit { ... constructor( ... public modalService: ModalService) { ... openDocument(record: Record){ this.modalService.open(Preview); return false; }   We are almost there. Refactor your app.component.html template to call this method, rather than open the original URL of the document:  app.component.html &lt;a href=&quot;#&quot; (click)=&quot;openDocument(record)&quot;&gt; &lt;h3 [innerHtml]=&quot;record.displayTitle || record.title&quot;&gt;&lt;/h3&gt; &lt;/a&gt; &lt;a href=&quot;{{record.url1}}&quot;&gt; &lt;div class=&quot;source&quot;&gt;{{record.url1}}&lt;/div&gt; &lt;/a&gt;   Now, click on one the documents... Here is what you should see:    ","version":"Next","tagName":"h2"},{"title":"Passing data to a modal component​","type":1,"pageTitle":"Preview & Modals","url":"/dokku/docs/tutorial/preview#passing-data-to-a-modal-component","content":" Now, let's try to display the title of the document in the preview header.  To do so, we need to update our openDocument() method:  app.component.ts openDocument(record: Record){ this.modalService.open(Preview, {model: record}); return false; }   The ModalService is going to inject the Record object into our Preview component. We can get this input by declaring a constructor in our Preview component:  preview.ts import { Component, Inject } from &quot;@angular/core&quot;; import { Record } from '@sinequa/core/web-services'; import { MODAL_MODEL } from '@sinequa/core/modal'; @Component({ selector: &quot;preview&quot;, template: ` &lt;sq-modal [title]=&quot;record.title&quot;&gt; Hello world &lt;/sq-modal&gt; ` }) export class Preview { constructor( @Inject(MODAL_MODEL) public record: Record){ } }   Now your dialog should display the title of the document (notice we also changed the HTML to set the [title] parameter):    ","version":"Next","tagName":"h2"},{"title":"Preview data​","type":1,"pageTitle":"Preview & Modals","url":"/dokku/docs/tutorial/preview#preview-data","content":" The component sq-preview handles automatically the loading and display of the HTML preview and requires only the record ID and the query.  preview.ts @Component({ selector: &quot;preview&quot;, template: ` &lt;sq-modal [title]=&quot;record.title&quot; [showFooter]=&quot;false&quot;&gt; &lt;sq-preview #facet [id]=&quot;record.id&quot; [query]=&quot;searchService.query&quot;&gt; &lt;/sq-preview&gt; &lt;/sq-modal&gt; ` }) export class Preview { constructor( @Inject(MODAL_MODEL) public record: Record, public searchService: SearchService) { } }     This works, but our large preview is displayed in a very small dialog... To fix this, we should first ask the ModalService to use the full screen:  this.modalService.open(Preview, {model: record, fullscreen: true});   sq-preview has no default sizing so you can use the style attribute to have it to take the full height of the modal:  &lt;sq-preview #facet class=&quot;h-100&quot; [id]=&quot;record.id&quot; [query]=&quot;searchService.query&quot;&gt; &lt;/sq-preview&gt;   Finally, a fullscreen preview!    ","version":"Next","tagName":"h2"},{"title":"Highlighting entities in the preview​","type":1,"pageTitle":"Preview & Modals","url":"/dokku/docs/tutorial/preview#highlighting-entities-in-the-preview","content":" Notice that our HTML does not seem to contain any highlight...  But, if you look closer and inspect the content of the HTML, you can actually see that the entities detected by Sinequa are wrapper in &lt;span&gt; elements with lots of attributes:    To add some highlights, sq-preview contains a [highlightColors] input. Let's add some to it with the following content:  import { PreviewHighlightColors } from &quot;@sinequa/components/preview&quot;; ... @Component({ selector: &quot;preview&quot;, template: ` &lt;sq-modal [title]=&quot;record.title&quot; [showFooter]=&quot;false&quot;&gt; &lt;sq-preview #facet class=&quot;h-100&quot; [highlightColors]=&quot;highlights&quot; [id]=&quot;record.id&quot; [query]=&quot;searchService.query&quot;&gt; &lt;/sq-preview&gt; &lt;/sq-modal&gt; ` }) export class Preview { highlights: PreviewHighlightColors[] = [ { name: 'company', color: 'white', bgColor: '#FF7675' }, { name: 'geo', color: 'white', bgColor: '#74B9FF' }, { name: 'person', color: 'white', bgColor: '#00ABB5' }, { name: 'extractslocations', color: 'black', bgColor: '#fffacd' }, { name: 'matchlocations', color: 'black', bgColor: '#ff0' } ]; ...   These properties will apply for each name classes their provided color and bgColor (e.g. the text color white and the background color #FF7675 for the company class).  And now... Voilà:   ","version":"Next","tagName":"h2"},{"title":"Designing a responsive SBA","type":0,"sectionRef":"#","url":"/dokku/docs/tutorial/responsive-design","content":"","keywords":"","version":"Next"},{"title":"Screen sizes​","type":1,"pageTitle":"Designing a responsive SBA","url":"/dokku/docs/tutorial/responsive-design#screen-sizes","content":" The first we should think about is: what should our application look like on devices of different sizes? How many different variants should we support?  In this tutorial, We'll assume 3 different sizes (mobile, tablet and desktop), with the following layouts:    First off, we need to tell Bootstrap about these screen sizes. In your styles/app.scss, insert the following maps before importing Bootstrap:  app.scss // Overriding Bootstrap variables $grid-breakpoints: ( xs: 0, sm: 600px, lg: 1000px ); $container-max-widths: ( sm: 800px, lg: 1200px ); // Bootstrap styles @import &quot;~bootstrap/scss/bootstrap&quot;;   ","version":"Next","tagName":"h2"},{"title":"Styling the Search component​","type":1,"pageTitle":"Designing a responsive SBA","url":"/dokku/docs/tutorial/responsive-design#styling-the-search-component","content":" Of course, there are many ways you could design your component. We propose the following sample code:  &lt;div class=&quot;search container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;!-- Navbar --&gt; &lt;nav class=&quot;navbar col-12 d-flex&quot;&gt; &lt;a [routerLink]=&quot;['/home']&quot;&gt; &lt;h1&gt;🔍 Hello Search&lt;/h1&gt; &lt;/a&gt; &lt;app-search-form class=&quot;flex-grow-1 position-relative mx-3&quot; style=&quot;min-height: 41px;&quot;&gt;&lt;/app-search-form&gt; &lt;ul class=&quot;navbar-nav navbar-right&quot;&gt; &lt;sq-saved-queries-menu&gt;&lt;/sq-saved-queries-menu&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;ng-container *ngIf=&quot;searchService.resultsStream | async as results&quot;&gt; &lt;!-- Results --&gt; &lt;div class=&quot;col-lg-8&quot;&gt; &lt;sq-tabs [results]=&quot;results&quot;&gt;&lt;/sq-tabs&gt; &lt;sq-loading-bar&gt;&lt;/sq-loading-bar&gt; &lt;div *ngFor=&quot;let record of results.records&quot; class=&quot;record&quot;&gt; &lt;a href=&quot;#&quot; (click)=&quot;openDocument(record)&quot;&gt; &lt;h3 [innerHtml]=&quot;record.displayTitle || record.title&quot;&gt;&lt;/h3&gt; &lt;/a&gt; &lt;a href=&quot;{{record.url1}}&quot;&gt; &lt;div class=&quot;source&quot;&gt;{{record.url1}}&lt;/div&gt; &lt;/a&gt; &lt;p *ngIf=&quot;record.relevantExtracts&quot; [innerHTML]=&quot;record.relevantExtracts&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;sq-pager [results]=&quot;results&quot;&gt;&lt;/sq-pager&gt; &lt;/div&gt; &lt;!-- Facets --&gt; &lt;div class=&quot;col-lg-4&quot;&gt; &lt;sq-facet-card [title]=&quot;'msg#facet.treepath.title'&quot; [icon]=&quot;'fas fa-sitemap'&quot;&gt; &lt;sq-facet-list #facet [results]=&quot;results&quot; [aggregation]=&quot;'Treepath'&quot;&gt;&lt;/sq-facet-list&gt; &lt;/sq-facet-card&gt; &lt;sq-facet-card [title]=&quot;'msg#facet.company.title'&quot; [icon]=&quot;'fas fa-building'&quot;&gt; &lt;sq-facet-list #facet [results]=&quot;results&quot; [aggregation]=&quot;'Company'&quot; [allowExclude]=&quot;false&quot; [allowAnd]=&quot;false&quot;&gt;&lt;/sq-facet-list&gt; &lt;/sq-facet-card&gt; &lt;sq-facet-card [title]=&quot;'msg#savedQueries.savedQueries'&quot; [icon]=&quot;'fas fa-save'&quot;&gt; &lt;sq-facet-saved-queries #facet [maxQueries]=&quot;5&quot;&gt;&lt;/sq-facet-saved-queries&gt; &lt;/sq-facet-card&gt; &lt;/div&gt; &lt;!-- Footer --&gt; &lt;div class=&quot;col-12&quot;&gt; &lt;hr&gt; &lt;span [sq-action-buttons]=&quot;{items: languageActions}&quot;&gt;&lt;/span&gt; &lt;button class=&quot;btn btn-success&quot; (click)=&quot;savedQueriesService.createSavedQueryModal()&quot;&gt; &lt;i class=&quot;fas fa-save&quot;&gt;&lt;/i&gt; &lt;/button&gt; &lt;/div&gt; &lt;/ng-container&gt; &lt;/div&gt; &lt;/div&gt;   Your app should look like this on a large screen:    Try resizing your screen to see what happens when hitting the different breakpoints we specified at the beginning.  Notice a few things in the code:  We put the search form inside the &lt;nav&gt; (of course, you can make a different choice)We display the results, facets and footer only if there are results (with the &lt;ng-container *ngIf=&quot;searchService.resultsStream | async as results&quot;&gt; element)We wrapped our components inside .container, .row and .col elements. These are standard Bootstrap classes (see Grid system).We used size modifiers, like the -lg- in col-lg-8. This means that this rule will apply only on large screens. On small screen, the rule reverts to a regular .col element.  However, our initial specifications are not met for medium and small screens! If you reduce the size of the screen, you notice that the filters are not hidden, they have just been wrapped under the results. Also, we need some buttons in the navbar to toggle the visibility of the facets and the search form...  ","version":"Next","tagName":"h2"},{"title":"UI Service​","type":1,"pageTitle":"Designing a responsive SBA","url":"/dokku/docs/tutorial/responsive-design#ui-service","content":" What we want to achieve requires more than CSS rules. We need our Angular code to be aware of the screen size, and be able to add/remove components depending on the size bracket.  Fortunately, the SBA framework includes a service to do just that: The UIService from @sinequa/components/utils.  The service needs to know what are the screen size breakpoints in use. To provide them, open your app.module.ts and add the following (notice they are the same breakpoints we defined in our CSS):  app.module.ts import { SCREEN_SIZE_RULES } from '@sinequa/components/utils'; ... // Screen size breakpoints (must be consistent with Bootstrap custom breakpoints in styles/app.scss) export const breakpoints = { lg: &quot;(min-width: 1000px)&quot;, sm: &quot;(min-width: 600px) and (max-width: 999px)&quot;, xs: &quot;(max-width: 599px)&quot;, } ... providers: [ ... {provide: SCREEN_SIZE_RULES, useValue: breakpoints} ],   Now you can import the service in your search.component.ts:  search.component.ts import { UIService } from '@sinequa/components/utils'; ... constructor( ... public ui: UIService )   We need to fix our Saved Queries menu, which by default works with different breakpoints. In your search.component.html, add these parameters:  search.component.html &lt;sq-saved-queries-menu [autoAdjustBreakpoint]=&quot;'lg'&quot; [collapseBreakpoint]=&quot;'xs'&quot;&gt;&lt;/sq-saved-queries-menu&gt;   ","version":"Next","tagName":"h2"},{"title":"Facet management​","type":1,"pageTitle":"Designing a responsive SBA","url":"/dokku/docs/tutorial/responsive-design#facet-management","content":" On medium and small screens, we want the facet to be hidden by default and to toggle their visibility by clicking a button in the navbar.  Let's add a boolean property in the search.component.ts that will store the visibility state.  search.component.ts import { UIService } from '@sinequa/components/utils'; ... export class SearchComponent { ... _showFacet: boolean = false; ... get showFacet(): boolean { return this.ui.screenSizeIsGreaterOrEqual('lg') || this._showFacet; }   Notice that facets will always be visible on large screens, but hidden (by default) on small screens.  Now, modify the search.component.html:  search.component.html &lt;!-- Facets --&gt; &lt;div class=&quot;col-lg-4&quot; *ngIf=&quot;showFacet&quot;&gt;   Your facet should now be hidden on small screens... But you have no way to show them again!  Let's add a button in the navbar to take care of this. We also need to hide the results when the facets are shown:  search.component.html &lt;!-- Navbar --&gt; &lt;nav ...&gt; ... &lt;h1&gt;🔍&lt;span *ngIf=&quot;ui.screenSizeIsGreaterOrEqual('lg')&quot;&gt; Hello Search&lt;/span&gt;&lt;/h1&gt; ... &lt;button class=&quot;btn btn-light&quot; (click)=&quot;_showFacet = !_showFacet&quot; *ngIf=&quot;ui.screenSizeIsLess('lg')&quot;&gt; &lt;i class=&quot;fas fa-filter&quot;&gt;&lt;/i&gt; &lt;/button&gt; ... &lt;/nav&gt; ... &lt;!-- Results --&gt; &lt;div class=&quot;col-lg-8&quot; *ngIf=&quot;ui.screenSizeIsGreaterOrEqual('lg') || !_showFacet&quot;&gt;   (Notice that we also remove the title on small screens.)  Your app should now look like this on medium and small screens, when you turn on the facet visibility:    ","version":"Next","tagName":"h2"},{"title":"Search form management​","type":1,"pageTitle":"Designing a responsive SBA","url":"/dokku/docs/tutorial/responsive-design#search-form-management","content":" On the smallest screens, the navbar is very crowded... We almost cannot see anything in the search form...  Let's piggy-back on the facet button feature: We will show the form on medium or large screens OR if the facets are shown:  search.component.html &lt;!-- Navbar --&gt; &lt;nav class=&quot;navbar col-12 d-flex px-2 px-sm-0&quot;&gt; &lt;a ... *ngIf=&quot;ui.screenSizeIsGreater('xs') || !showFacet&quot;&gt; ... &lt;/a&gt; &lt;app-search-form class=&quot;flex-grow-1 position-relative mx-sm-3&quot; style=&quot;min-height: 41px;&quot; *ngIf=&quot;ui.screenSizeIsGreater('xs') || showFacet&quot;&gt;&lt;/app-search-form&gt; &lt;button class=&quot;btn btn-light ml-auto&quot; ...&gt; ... &lt;/button&gt; &lt;ul ... *ngIf=&quot;ui.screenSizeIsGreater('xs') || !showFacet&quot;&gt; ... &lt;/ul&gt; &lt;/nav&gt;   This is what you should have on small screens:    And when toggling the facets:      Of course, we could go much further in this exercise of making the application responsive and good-looking. We also left out the Home route and other details, like menus, autocomplete, etc.  But the main tools for making your application responsive have been illustrated:  CSS rules (media queries, via Bootstrap classes, or directly in your app.scss)Angular logic and UIService to toggle the visibility of elements via state variables. ","version":"Next","tagName":"h2"},{"title":"Routing","type":0,"sectionRef":"#","url":"/dokku/docs/tutorial/routing","content":"","keywords":"","version":"Next"},{"title":"Creating the new components​","type":1,"pageTitle":"Routing","url":"/dokku/docs/tutorial/routing#creating-the-new-components","content":" In a terminal cd into src/app/ and run the following commands:  ng generate component home ng generate component search ng generate component search-form   (Use npm run ng if Angular CLI is not installed globally)  Note that Angular took care of add these new components to our app.module.ts, but you have a conflict with the SearchFormComponent from @sinequa/components. You can fix it by creating an alias for it in the imports:  app.module.ts import { SearchFormComponent as AppSearchFormComponent } from './search-form/search-form.component'; @NgModule({ ... declarations: [ ... AppSearchFormComponent   ","version":"Next","tagName":"h2"},{"title":"Refactoring​","type":1,"pageTitle":"Routing","url":"/dokku/docs/tutorial/routing#refactoring","content":" Open your app.component.ts and app.component.html, and move all of their respective content to search.component.ts and search.component.html, except for the login (buttons and respective methods) and notifications management (the notification container and its deleteNotification method) as they need to be on all routes. ⚠️ Be careful not to overwrite components class names and Angular selector with a copy-paste! Add the router-outlet to app.component.html. You should have something like this (note that we positioned the notifications with position: fixed in the bottom right): app.component.html &lt;router-outlet&gt;&lt;/router-outlet&gt; &lt;button *ngIf=&quot;loginService.complete&quot; type=&quot;button&quot; (click)=&quot;logout()&quot;&gt;{{ msg#app.logout | sqMessage }}&lt;/button&gt; &lt;button *ngIf=&quot;!loginService.complete&quot; type=&quot;button&quot; (click)=&quot;login()&quot;&gt;{{ msg#app.login | sqMessage }}&lt;/button&gt; &lt;ng-container *ngIf=&quot;notificationsService.notificationsStream | async as notification&quot;&gt; &lt;div *ngIf=&quot;deleteNotification(notification)&quot; class=&quot;notification position-fixed&quot; style=&quot;bottom: 5px; right: 5px; width: 500px&quot;&gt; &lt;div *ngIf=&quot;notification.title&quot; class=&quot;title&quot;&gt; &lt;span&gt;{{notification.title | sqMessage}}&lt;/span&gt; &lt;hr&gt; &lt;/div&gt; &lt;div&gt;{{notification.text | sqMessage:{values: notification.params} }}&lt;/div&gt; &lt;/div&gt; &lt;/ng-container&gt; In your app.module.ts, define two routes corresponding to our two new components: app.module.ts @NgModule({ imports: [ ... RouterModule.forRoot([ {path: &quot;home&quot;, component: HomeComponent}, {path: &quot;search&quot;, component: SearchComponent}, {path: &quot;**&quot;, redirectTo: &quot;home&quot;} ]), You should see: Open your search.component.html and migrate all the &lt;sq-search-form&gt; element to the search-form.component.html. Don't forget to add the SearchService dependency in the component's constructor. Remove the searchRoute input from &lt;sq-search-form&gt; since we now want the route to be &quot;search&quot;. Insert the new search form in the search.component.html, where the &lt;form&gt; used to be: search.component.html ... &lt;/nav&gt; &lt;app-search-form&gt;&lt;/app-search-form&gt; Also insert the search form in your home.component.html with a little formatting to make it look good: home.component.html &lt;div class=&quot;vh-100 w-100 d-flex flex-column justify-content-center align-items-center&quot;&gt; &lt;h1 class=&quot;mb-5&quot;&gt;Hello Search 🔍&lt;/h1&gt; &lt;div class=&quot;w-50 position-relative mb-5&quot;&gt; &lt;app-search-form&gt;&lt;/app-search-form&gt; &lt;/div&gt; &lt;/div&gt; This should now look like this: Modify the search() method in autocomplete.ts to also redirect on the &quot;search&quot; route: autocomplete.ts search() { ... this.searchService.searchText(&quot;/search&quot;); } When you perform a search, upon hitting Enter or clicking on an autocompletion suggestion, you are now indeed redirected to the &quot;search&quot; route, but the search result does not appear. To fix this, in your app.module.ts tell your Search module that search is a search route: app.module.ts BsSearchModule.forRoot({routes: ['search']}), At this point, your app should work, but once on the Search component, it is impossible to come back to the Home component. Let's add a router link on the &quot;Hello Search&quot; Title: &lt;a [routerLink]=&quot;['/home']&quot; class=&quot;mr-auto&quot;&gt; &lt;h1&gt;Hello Search 🔍&lt;/h1&gt; &lt;/a&gt;   ","version":"Next","tagName":"h2"},{"title":"Adding new routes​","type":1,"pageTitle":"Routing","url":"/dokku/docs/tutorial/routing#adding-new-routes","content":" The refactoring above is relatively complicated because we decided to add routes to a single-component app. More realistically, your app would have multiple routes from the start.  Adding new routes to an existing SBA is fairly simple:  Create a new component (manually or with ng generate component as above)Wire the component to your routes in your app.module.ts, as in step 3. above.Then create links from you existing routes to the new route: Either via HTML, with a router link (as above in step 9)Or programmatically, using router.navigate() (which is what the SearchService is doing in step 7 above) If you want the SearchService to be active on your route (resolve search queries based on the URL), add the route to the list passed to the BsSearchModule (as in step 8 above). Note that the SearchService does not have to be tied to routing. You can deactivate that by passing a deactivateRouting: true parameter to the service, via the BsSearchModule.forRoot() method. ","version":"Next","tagName":"h2"},{"title":"Internationalization","type":0,"sectionRef":"#","url":"/dokku/docs/tutorial/intl","content":"","keywords":"","version":"Next"},{"title":"Configuring the internationalization​","type":1,"pageTitle":"Internationalization","url":"/dokku/docs/tutorial/intl#configuring-the-internationalization","content":" In your app.module.ts file, notice that the IntlModule is imported from @sinequa/core/intl. The module is imported in the AppModule with:  app.module.ts import {IntlModule} from &quot;@sinequa/core/intl&quot;; import {DefaultLocalesConfig} from &quot;@sinequa/core/default-locales-config&quot;; ... @NgModule({ imports: [ ... IntlModule.forRoot(DefaultLocalesConfig),   We want to replace the DefaultLocalesConfig (which contains only a few default messages) by a configuration specific to our app.  To do so, we need to create our own language files. We can start with English.  Create a new src/locales/ directory. In this directory, create a en.ts file, with the following content: en.ts import {LocaleData} from &quot;@sinequa/core/intl&quot;; import {enCore} from &quot;@sinequa/core/messages&quot;; import &quot;intl/locale-data/jsonp/en-US&quot;; // Safari import {Utils} from &quot;@sinequa/core/base&quot;; import {enFacet} from &quot;@sinequa/components/facet&quot;; import {enResult} from &quot;@sinequa/components/result&quot;; import {enSearch} from &quot;@sinequa/components/search&quot;; const d3Format = require('d3-format/locale/en-US'); const d3Time = require('d3-time-format/locale/en-US'); const appMessages = { locale: { en: &quot;English&quot;, }, results: { resultsAllTab: &quot;All&quot;, tabPeople: &quot;People&quot;, tabBusiness: &quot;Companies&quot;, tabLocation: &quot;Places&quot; }, } export default &lt;LocaleData&gt; { intl: { locale: &quot;en-US&quot; }, d3: { locale: &quot;en-US&quot;, format: d3Format, time: d3Time }, messages: Utils.merge({}, enCore, enFacet, enResult, enSearch, appMessages) }; Notice the appMessages, which contains the messages specific to your app, is merged with the messages coming from the @sinequa/core and @sinequa/components libraries (enCore, enFacet, etc.). Back in your app.module.ts file, create a new AppLocalesConfig class to replace DefaultLocalesConfig: app.module.ts import {LocalesConfig, Locale} from &quot;@sinequa/core/intl&quot;; import enLocale from &quot;../locales/en&quot;; export class AppLocalesConfig implements LocalesConfig { locales: Locale[] = [{ name: &quot;en&quot;, display: &quot;msg#locale.en&quot;, data: enLocale }]; defaultLocale: Locale = this.locales[0]; } ... import: [ ... IntlModule.forRoot(AppLocalesConfig), ] At this point, your app supports one locale: English, which is obviously the default.  ","version":"Next","tagName":"h2"},{"title":"Adding messages​","type":1,"pageTitle":"Internationalization","url":"/dokku/docs/tutorial/intl#adding-messages","content":" Your app still contains a lot of hard-coded strings in the app.component.html template (&quot;Search&quot;, &quot;Clear&quot;, &quot;Login&quot;, &quot;Logout&quot;, &quot;Enter search terms...&quot;, &quot;Companies&quot;, &quot;Sources&quot;).  Replace these strings with message strings with the sqMessage pipe, and add the corresponding entries in your dictionary (locales/en.ts).  For example, replace:  &lt;button&gt;Search&lt;/button&gt;   With:  app.component.html &lt;button&gt;{{ 'msg#search.button' | sqMessage }}&lt;/button&gt;   And in your en.ts file:  en.ts { search: { button: &quot;Search&quot; } }   (You can do the same for the &quot;Clear&quot; button and the Search placehoder.)  Note that the Sinequa components that take strings as an input are already using the sqMessage pipe to display them. So, in the case of the facet title, you can directly write:  &lt;sq-facet-card [title]=&quot;'msg#facet.company.title'&quot; [icon]=&quot;'fas fa-building'&quot;&gt; ... &lt;/sq-facet-card&gt;   (By the way, this message is already in the Facet module dictionaries.)  Your dictionary en.ts should now have these extra entries:  en.ts app: { login: &quot;Login&quot;, logout: &quot;Logout&quot;, }, search: { button: &quot;Search&quot;, placeholder: &quot;Enter search terms...&quot;, clear: &quot;Clear&quot; }   ","version":"Next","tagName":"h2"},{"title":"Overriding the default messages​","type":1,"pageTitle":"Internationalization","url":"/dokku/docs/tutorial/intl#overriding-the-default-messages","content":" It is of course possible to override the default messages. For example, your facets display a &quot;Load more&quot; link at the bottom. If you want to replace this text with something else, do the following:  Find what is the key for the &quot;Load more&quot; message. You could go look into the source code of the sq-facet-list component, but a quicker approach is to use the search engine of VS Code and open the dictionary file directly. In our case, searching for &quot;Load more&quot; quickly tells us that the message key is msg#facet.loadMore. Override that key in your own dictionary: facet: { loadMore: &quot;Gimme more data, please!&quot; } (This is just an example, you do not have to keep in your code.)  ","version":"Next","tagName":"h2"},{"title":"Supporting multiple languages​","type":1,"pageTitle":"Internationalization","url":"/dokku/docs/tutorial/intl#supporting-multiple-languages","content":" Supporting multiple language means including these locales in your AppLocalesConfig. To support French, for example, copy and rename en.ts as fr.ts.  Inside this file, you need to replace imports that point to English resources by French resources. For example:  fr.ts import {LocaleData} from &quot;@sinequa/core/intl&quot;; import {frCore} from &quot;@sinequa/core/messages&quot;; import &quot;intl/locale-data/jsonp/fr-FR&quot;; // Safari import {Utils} from &quot;@sinequa/core/base&quot;; import {frFacet} from &quot;@sinequa/components/facet&quot;; import {frResult} from &quot;@sinequa/components/result&quot;; import {frSearch} from &quot;@sinequa/components/search&quot;; const d3Format = require('d3-format/locale/fr-FR'); const d3Time = require('d3-time-format/locale/fr-FR');   Then you can translate all the text in appMessages to French. This should look like:  fr.ts locale: { en: &quot;English&quot;, fr: &quot;Français&quot;, }, app: { login: &quot;Login&quot;, logout: &quot;Logout&quot;, }, search: { button: &quot;Chercher&quot;, placeholder: &quot;Termes de recherche...&quot;, clear: &quot;Effacer&quot; }, results: { resultsAllTab: &quot;Tous&quot;, tabPeople: &quot;Personnes&quot;, tabBusiness: &quot;Entreprises&quot;, tabLocation: &quot;Lieux&quot; },   You will also need to replace the export section to change the en-US occurences into fr-FR, and update all the en messages files with their french ones (for example enCore into frCore).  Notice in this dictionary that the language names themselves (&quot;English&quot;, &quot;Français&quot;, etc.) need to have an entry (locale.en, locale.fr) in order to display them in the future language menu. You might want to add the locale.fr entry to en.ts as well.  Finally, import this locale and add it to your AppLocalesConfig:  locales: Locale[] = [ { name: &quot;en&quot;, display: &quot;msg#locale.en&quot;, data: enLocale }, { name: &quot;fr&quot;, display: &quot;msg#locale.fr&quot;, data: frLocale } ];   ","version":"Next","tagName":"h2"},{"title":"Switching between languages​","type":1,"pageTitle":"Internationalization","url":"/dokku/docs/tutorial/intl#switching-between-languages","content":" Now your application supports multiple language, but you have no way to easily switch between them!  Let's add a button for each language, next to the Login and Logout buttons (that you can also internationalize). We will use another module to this end: the Action module. This module, which is used extensively across the framework, allows to easily create dynamic lists of buttons and menus and support many useful options.  Import the Action module in your app.module.ts. app.module.ts import {BsActionModule} from '@sinequa/components/action'; ... @NgModule({ imports: [ ... BsActionModule, Create a list of Action objects (one for each language) in the constructor of your app.component.ts: app.component.ts import { Action } from '@sinequa/components/action'; import { IntlService, Locale } from '@sinequa/core/intl'; ... export class AppComponent implements AfterViewInit { ... languageActions: Action[]; constructor( ... public intlService: IntlService) { ... // Create one action (button) for each language this.languageActions = this.intlService.locales.map(locale =&gt; new Action({ text: locale.display, // &quot;French&quot; data: locale, // French locale selected: locale === this.intlService.currentLocale, // If this is the current locale action: (item: Action, $event: UIEvent) =&gt; { // On click, switch to this language this.intlService.use((item.data as Locale).name).subscribe( (value) =&gt; this.languageActions.forEach(a =&gt; a.update())); }, updater: (action) =&gt; { // Update the status of buttons action.selected = action.data === this.intlService.currentLocale; } }) ); Insert this list of buttons in your app.component.html with the sq-action-buttons directive, next to the existing Login/Logout buttons: app.component.html &lt;button ...&gt;{{ msg#app.logout | sqMessage }}&lt;/button&gt; &lt;button ...&gt;{{ msg#app.login | sqMessage }}&lt;/button&gt; &lt;span [sq-action-buttons]=&quot;{items: languageActions}&quot;&gt;&lt;/span&gt;   ","version":"Next","tagName":"h2"},{"title":"Loading languages lazily​","type":1,"pageTitle":"Internationalization","url":"/dokku/docs/tutorial/intl#loading-languages-lazily","content":" If your app supports many languages, your might not want to load all of them on startup. It is possible to modify your AppLocalesConfig to load a new language only when requested by the user:  Skip the data field of the Locale object: {name: &quot;de&quot;, display: &quot;msg#locale.de&quot;}Add a loadLocale() method to AppLocalesConfig, which takes care of importing the data lazily:  loadLocale(locale: string): Observable&lt;LocaleData&gt; { return from(import('../locales/'+locale).then(m =&gt; m.default)); }   Ensure that lazily loaded locales are included in the compilation by including them explicitly in tsconfig.json:  tsconfig.json &quot;include&quot;: [ ... &quot;src/locales/*.ts&quot; ]  ","version":"Next","tagName":"h2"},{"title":"Search Module","type":0,"sectionRef":"#","url":"/dokku/docs/tutorial/search-module","content":"","keywords":"","version":"Next"},{"title":"Importing the Search Module​","type":1,"pageTitle":"Search Module","url":"/dokku/docs/tutorial/search-module#importing-the-search-module","content":" In your app.module.ts, import the BsSearchModule and add it to the NgModule declaration:  app.module.ts import { BsSearchModule } from '@sinequa/components/search'; @NgModule({ imports: [ ... BsSearchModule.forRoot({routes: [&quot;&quot;]})   Notice the call to forRoot(), which tells the SearchService to work on the empty route (Hello Search has no route).  Doing so means you can now use the components exported by this module in your app. However, we need to do things in order, and there are preliminary steps before we can actually do this...  ","version":"Next","tagName":"h2"},{"title":"Using the Search Service​","type":1,"pageTitle":"Search Module","url":"/dokku/docs/tutorial/search-module#using-the-search-service","content":" The Hello-Search has a few issues:  If you refresh the page after searching for something, your results are gone! This is not surprising, as your search criteria are not persisted anywhere.You are creating local Query and Results objects which cannot be used outside of your component.You are not generating events and keeping track of user search actions, which will be an issue for implementing some features.  The SearchService solves these issues by:  Centralizing the management of the Query and Results and providing helper method to easily modify these objects.Persisting the query in the URL, so that the app state is not lost on refresh.Generating events and keeping track of user actions (breadcrumbs).  In your app.component.ts, import the SearchService and add it to the declarations of the constructor (in place of the QueryWebService):  app.component.ts import { SearchService } from '@sinequa/components/search'; ... constructor( ... public searchService: SearchService ){   The SearchService is going to manage the Results observable (See rxjs), you can now remove the results$ object:  app.component.ts results$: Observable&lt;Results&gt; | undefined   Your search() method can be simplified to:  app.component.ts search() { this.searchService.clearQuery(); this.searchService.query.text = this.searchControl.value || ''; this.searchService.searchText(); }   You can also replace this.results$ = undefined by this.searchService.clear().  Also, remove the now unused imports:  import {QueryWebService, Results} from &quot;@sinequa/core/web-services&quot;; import {AppService`~~`, Query`~~`} from &quot;@sinequa/core/app-utils&quot;; import {Observable} from 'rxjs';   Now in your app.component.html, replace the occurrences of results$ by searchService.resultsStream.  app.component.html &lt;button *ngIf=&quot;searchService.resultsStream | async&quot; type=&quot;button&quot; (click)=&quot;clear()&quot;&gt;Clear&lt;/button&gt; &lt;/form&gt; &lt;div *ngIf=&quot;searchService.resultsStream | async; let results&quot;&gt; &lt;hr&gt; &lt;div *ngFor=&quot;let record of results.records&quot; class=&quot;record&quot;&gt; ...   At this point, your application works almost correctly. Notice that the URL now contains a serialized Query object, which contains the text you have searched for. If you refresh the page, the results are still here! However, notice that the text in the search input has disappeared...    To fix this, we need to listen to the SearchService events and fill the input when the query changes. Back in your app.component.ts, add these lines to your constructor:  app.component.ts constructor(...) { ... this.searchService.queryStream.subscribe({ next: (query) =&gt; { this.searchControl.setValue((query &amp;&amp; query.text) || ''); } }); }   Now when you refresh the page after a search, everything should be fine!  ","version":"Next","tagName":"h2"},{"title":"Importing Bootstrap​","type":1,"pageTitle":"Search Module","url":"/dokku/docs/tutorial/search-module#importing-bootstrap","content":" We are almost ready to start using the components from the Search module. But one thing remains to do: These components depend on the Bootstrap library, and our current Hello Search app does not use any style library.  In your styles/app.scss stylesheet, add the following lines:  app.scss // Bootstrap styles @import &quot;bootstrap/scss/bootstrap&quot;; /*** Fontawesome ***/ $fa-font-path: &quot;~@fortawesome/fontawesome-free/webfonts&quot;; @import &quot;@fortawesome/fontawesome-free/scss/fontawesome&quot;; @import &quot;@fortawesome/fontawesome-free/scss/brands&quot;; @import &quot;@fortawesome/fontawesome-free/scss/regular&quot;; @import &quot;@fortawesome/fontawesome-free/scss/solid&quot;;   You should notice that your app looks a little different. This is because Bootstrap applies default styling to standard HTML elements.  ","version":"Next","tagName":"h2"},{"title":"Search module components​","type":1,"pageTitle":"Search Module","url":"/dokku/docs/tutorial/search-module#search-module-components","content":" You can now insert some of the Search module components in your component's template. Here are some suggestions:  sq-tabs: Displays some tabs to filter the search corpus (the filters are configured in the administration back-end)sq-loading-bar: Displays a loading bar when a Search is in progresssq-pager: Displays a pager to navigate through the search results  app.component.ts &lt;div *ngIf=&quot;searchService.resultsStream | async; let results&quot;&gt; &lt;hr&gt; &lt;sq-tabs [results]=&quot;results&quot;&gt;&lt;/sq-tabs&gt; &lt;sq-loading-bar&gt;&lt;/sq-loading-bar&gt; &lt;sq-pager [results]=&quot;results&quot;&gt;&lt;/sq-pager&gt; &lt;div *ngFor=&quot;let record of results.records&quot; class=&quot;record&quot;&gt; ... &lt;/div&gt; &lt;/div&gt;   If everything goes well, you should see something like this in your app:    Don't worry too much about the Look &amp; Feel of the app, we'll come to that later. In particular the name of the tabs read like strange codes (msg#results.resultsAllTab): these are keys needed to internationalize your application, with a dictionary for each language (we will deal with that in the Internationalization chapter) ","version":"Next","tagName":"h2"},{"title":"Completed application","type":0,"sectionRef":"#","url":"/dokku/docs/tutorial/completed-app","content":"","keywords":"","version":"Next"},{"title":"App module​","type":1,"pageTitle":"Completed application","url":"/dokku/docs/tutorial/completed-app#app-module","content":" app.module.ts import { NgModule } from &quot;@angular/core&quot;; import { BrowserModule } from &quot;@angular/platform-browser&quot;; import { RouterModule } from '@angular/router'; import { LocationStrategy, HashLocationStrategy } from &quot;@angular/common&quot;; import { HTTP_INTERCEPTORS } from &quot;@angular/common/http&quot;; import { FormsModule, ReactiveFormsModule } from &quot;@angular/forms&quot;; import { Observable, from } from &quot;rxjs&quot;; import { WebServicesModule, StartConfigWebService, StartConfig } from &quot;@sinequa/core/web-services&quot;; import { LoginModule, LoginInterceptor } from &quot;@sinequa/core/login&quot;; import { IntlModule, LocaleData, LocalesConfig, Locale } from &quot;@sinequa/core/intl&quot;; import { ModalModule } from &quot;@sinequa/core/modal&quot;; import { NotificationsInterceptor } from &quot;@sinequa/core/notification&quot;; import { AuditInterceptor } from &quot;@sinequa/core/app-utils&quot;; import { BsSearchModule } from '@sinequa/components/search'; import { BsFacetModule } from '@sinequa/components/facet'; import { BsActionModule } from '@sinequa/components/action'; import { PreviewModule } from '@sinequa/components/preview'; import { BsModalModule } from '@sinequa/components/modal'; import { BsSavedQueriesModule } from '@sinequa/components/saved-queries'; import { SearchFormComponent } from &quot;@sinequa/components/search-form&quot;; import { environment } from &quot;../environments/environment&quot;; import { AppComponent } from &quot;./app.component&quot;; import { Preview } from &quot;./preview&quot;; import { HomeComponent } from './home/home.component'; import { SearchComponent } from './search/search.component'; import { Autocomplete } from &quot;./autocomplete&quot;; import { SearchFormComponent as AppSearchFormComponent } from './search-form/search-form.component'; import { SCREEN_SIZE_RULES } from '@sinequa/components/utils'; export const startConfig: StartConfig = { app: &quot;training&quot;, autoSAMLProvider: &quot;identity-dev&quot;, production: environment.production, auditEnabled: true }; // Locales configuration export class AppLocalesConfig implements LocalesConfig { locales: Locale[] = [ { name: &quot;en&quot;, display: &quot;msg#locale.en&quot; }, { name: &quot;fr&quot;, display: &quot;msg#locale.fr&quot; } ]; defaultLocale: Locale = this.locales[0]; loadLocale(locale: string): Observable&lt;LocaleData&gt; { return from(import('../locales/' + locale).then(m =&gt; m.default)); } } export function StartConfigInitializer(startConfigWebService: StartConfigWebService) { return () =&gt; startConfigWebService.fetchPreLoginAppConfig(); } // Screen size breakpoints (must be consistent with Bootstrap custom breakpoints in styles/app.scss) export const breakpoints = { lg: &quot;(min-width: 1000px)&quot;, sm: &quot;(min-width: 600px) and (max-width: 999px)&quot;, xs: &quot;(max-width: 599px)&quot;, } @NgModule({ imports: [ BrowserModule, RouterModule.forRoot([ { path: &quot;home&quot;, component: HomeComponent }, { path: &quot;search&quot;, component: SearchComponent }, { path: &quot;**&quot;, redirectTo: &quot;home&quot; } ]), FormsModule, ReactiveFormsModule, WebServicesModule.forRoot(startConfig), IntlModule.forRoot(AppLocalesConfig), LoginModule.forRoot(), // Just use default login modal ModalModule.forRoot(), BsSearchModule.forRoot({ routes: ['search'] }), BsFacetModule, BsActionModule, PreviewModule, BsModalModule, SearchFormComponent, BsSavedQueriesModule ], declarations: [ AppComponent, Preview, Autocomplete, HomeComponent, SearchComponent, AppSearchFormComponent ], providers: [ // Provides an APP_INITIALIZER which will fetch application configuration information from the Sinequa // server automatically at startup using the application name specified in the URL (app[-debug]/&lt;app-name&gt;). // This allows an application to avoid hard-coding parameters in the StartConfig but requires that the application // be served from the an app[-debug]/&lt;app name&gt; URL. // {provide: APP_INITIALIZER, useFactory: StartConfigInitializer, deps: [StartConfigWebService], multi: true}, // Provides the Angular LocationStrategy to be used for reading route state from the browser's URL. Currently // only the HashLocationStrategy is supported by Sinequa. { provide: LocationStrategy, useClass: HashLocationStrategy }, // Provides an HttpInterceptor to handle user login. The LoginInterceptor handles HTTP 401 responses // to Sinequa web service requests and initiates the login process. { provide: HTTP_INTERCEPTORS, useClass: LoginInterceptor, multi: true }, // Provides an HttpInterceptor that offers a centralized location through which all client-side // audit records pass. An application can replace AuditInterceptor with a subclass that overrides // the updateAuditRecord method to add custom audit information to the records. { provide: HTTP_INTERCEPTORS, useClass: AuditInterceptor, multi: true }, // Provides an HttpInterceptor that automatically processes any notifications specified in the $notifications // member of the response body to any Sinequa web service requests. { provide: HTTP_INTERCEPTORS, useClass: NotificationsInterceptor, multi: true }, { provide: SCREEN_SIZE_RULES, useValue: breakpoints } ], bootstrap: [ AppComponent ] }) export class AppModule { }   ","version":"Next","tagName":"h2"},{"title":"App Component​","type":1,"pageTitle":"Completed application","url":"/dokku/docs/tutorial/completed-app#app-component","content":" ","version":"Next","tagName":"h2"},{"title":"Controller​","type":1,"pageTitle":"Completed application","url":"/dokku/docs/tutorial/completed-app#controller","content":" app.component.ts import {Component, AfterViewInit} from &quot;@angular/core&quot;; import {LoginService} from &quot;@sinequa/core/login&quot;; import {NotificationsService, Notification} from &quot;@sinequa/core/notification&quot;; @Component({ selector: &quot;app&quot;, templateUrl: &quot;./app.component.html&quot;, styleUrls: [&quot;./app.component.scss&quot;] }) export class AppComponent implements AfterViewInit { constructor( public loginService: LoginService, public notificationsService: NotificationsService) { } ngAfterViewInit() { this.login(); } login() { this.loginService.login(); } logout() { this.loginService.logout(); } deleteNotification(notification: Notification) { setTimeout(() =&gt; this.notificationsService.deleteNotification(notification), 5000); return true; } }   ","version":"Next","tagName":"h3"},{"title":"Template​","type":1,"pageTitle":"Completed application","url":"/dokku/docs/tutorial/completed-app#template","content":" app.component.html &lt;router-outlet&gt;&lt;/router-outlet&gt; &lt;button *ngIf=&quot;loginService.complete&quot; type=&quot;button&quot; (click)=&quot;logout()&quot;&gt;{{ msg#app.logout | sqMessage }}&lt;/button&gt; &lt;button *ngIf=&quot;!loginService.complete&quot; type=&quot;button&quot; (click)=&quot;login()&quot;&gt;{{ msg#app.login | sqMessage }}&lt;/button&gt; &lt;ng-container *ngIf=&quot;notificationsService.notificationsStream | async as notification&quot;&gt; &lt;div *ngIf=&quot;deleteNotification(notification)&quot; class=&quot;notification position-fixed&quot; style=&quot;bottom: 5px; right: 5px; width: 500px&quot;&gt; &lt;div *ngIf=&quot;notification.title&quot; class=&quot;title&quot;&gt; &lt;span&gt;{{notification.title | sqMessage}}&lt;/span&gt; &lt;hr&gt; &lt;/div&gt; &lt;div&gt;{{notification.text | sqMessage:{values: notification.params} }}&lt;/div&gt; &lt;/div&gt; &lt;/ng-container&gt;   ","version":"Next","tagName":"h3"},{"title":"Styles​","type":1,"pageTitle":"Completed application","url":"/dokku/docs/tutorial/completed-app#styles","content":" app.component.scss .notification { border: solid; padding: 8px; .title { font-weight: bold; } }   ","version":"Next","tagName":"h3"},{"title":"Home Component​","type":1,"pageTitle":"Completed application","url":"/dokku/docs/tutorial/completed-app#home-component","content":" ","version":"Next","tagName":"h2"},{"title":"Controller​","type":1,"pageTitle":"Completed application","url":"/dokku/docs/tutorial/completed-app#controller-1","content":" home.component.ts import { Component, OnInit } from '@angular/core'; @Component({ selector: 'app-home', templateUrl: './home.component.html', styleUrls: ['./home.component.scss'] }) export class HomeComponent implements OnInit { constructor() { } ngOnInit() { } }   ","version":"Next","tagName":"h3"},{"title":"Template​","type":1,"pageTitle":"Completed application","url":"/dokku/docs/tutorial/completed-app#template-1","content":" home.component.html &lt;div class=&quot;vh-100 w-100 d-flex flex-column justify-content-center align-items-center&quot;&gt; &lt;h1 class=&quot;mb-5&quot;&gt;Hello Search 🔍&lt;/h1&gt; &lt;div class=&quot;w-50 position-relative mb-5&quot;&gt; &lt;app-search-form&gt;&lt;/app-search-form&gt; &lt;/div&gt; &lt;/div&gt;   ","version":"Next","tagName":"h3"},{"title":"Search Component​","type":1,"pageTitle":"Completed application","url":"/dokku/docs/tutorial/completed-app#search-component","content":" ","version":"Next","tagName":"h2"},{"title":"Controller​","type":1,"pageTitle":"Completed application","url":"/dokku/docs/tutorial/completed-app#controller-2","content":" search.component.ts import { Component } from &quot;@angular/core&quot;; import { Action } from '@sinequa/components/action'; import { IntlService, Locale } from '@sinequa/core/intl'; import { Record } from '@sinequa/core/web-services'; import { ModalService } from '@sinequa/core/modal'; import { Preview } from '../preview'; import { SavedQueriesService } from '@sinequa/components/saved-queries'; import { SearchService } from '@sinequa/components/search'; import { UIService } from '@sinequa/components/utils'; @Component({ selector: 'app-search', templateUrl: './search.component.html', styleUrls: ['./search.component.scss'] }) export class SearchComponent { languageActions: Action[]; _showFacet: boolean = false; constructor( public intlService: IntlService, public modalService: ModalService, public savedQueriesService: SavedQueriesService, public searchService: SearchService, public ui: UIService) { // Create one action (button) for each language this.languageActions = this.intlService.locales.map(locale =&gt; new Action({ text: locale.display, // &quot;French&quot; data: locale, // French locale selected: locale == this.intlService.currentLocale, // Whether French is the current locale action: (item: Action, $event: UIEvent) =&gt; { // On click, switch to this language this.intlService.use((item.data as Locale).name).subscribe( (value) =&gt; this.languageActions.forEach(a =&gt; a.update())); }, updater: (action) =&gt; { // Update the status of buttons action.selected = action.data === this.intlService.currentLocale; } }) ); } openDocument(record: Record){ this.modalService.open(Preview, {model: record, fullscreen: true}); return false; } get showFacet(): boolean { return this.ui.screenSizeIsGreaterOrEqual('lg') || this._showFacet; } }   ","version":"Next","tagName":"h3"},{"title":"Template​","type":1,"pageTitle":"Completed application","url":"/dokku/docs/tutorial/completed-app#template-2","content":" search.component.html &lt;div class=&quot;search container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;!-- Navbar --&gt; &lt;nav class=&quot;navbar col-12 d-flex px-2 px-sm-0&quot;&gt; &lt;a [routerLink]=&quot;['/home']&quot; *ngIf=&quot;ui.screenSizeIsGreater('xs') || !showFacet&quot;&gt; &lt;h1&gt;🔍&lt;span *ngIf=&quot;ui.screenSizeIsGreaterOrEqual('lg')&quot;&gt; Hello Search&lt;/span&gt;&lt;/h1&gt; &lt;/a&gt; &lt;app-search-form class=&quot;flex-grow-1 position-relative mx-sm-3&quot; style=&quot;min-height: 41px;&quot; *ngIf=&quot;ui.screenSizeIsGreater('xs') || showFacet&quot;&gt;&lt;/app-search-form&gt; &lt;button class=&quot;btn btn-light ml-auto&quot; (click)=&quot;_showFacet = !_showFacet&quot; *ngIf=&quot;ui.screenSizeIsLess('lg')&quot;&gt; &lt;i class=&quot;fas fa-filter&quot;&gt;&lt;/i&gt; &lt;/button&gt; &lt;ul class=&quot;navbar-nav navbar-right&quot; *ngIf=&quot;ui.screenSizeIsGreater('xs') || !showFacet&quot;&gt; &lt;sq-saved-queries-menu [autoAdjustBreakpoint]=&quot;'lg'&quot; [collapseBreakpoint]=&quot;'xs'&quot;&gt;&lt;/sq-saved-queries-menu&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;ng-container *ngIf=&quot;searchService.resultsStream | async as results&quot;&gt; &lt;!-- Results --&gt; &lt;div class=&quot;col-lg-8&quot; *ngIf=&quot;ui.screenSizeIsGreaterOrEqual('lg') || !_showFacet&quot;&gt; &lt;sq-tabs [results]=&quot;results&quot;&gt;&lt;/sq-tabs&gt; &lt;sq-loading-bar&gt;&lt;/sq-loading-bar&gt; &lt;div *ngFor=&quot;let record of results.records&quot; class=&quot;record&quot;&gt; &lt;a href=&quot;#&quot; (click)=&quot;openDocument(record)&quot;&gt; &lt;h3 [innerHtml]=&quot;record.displayTitle || record.title&quot;&gt;&lt;/h3&gt; &lt;/a&gt; &lt;a href=&quot;{{record.url1}}&quot;&gt; &lt;div class=&quot;source&quot;&gt;{{record.url1}}&lt;/div&gt; &lt;/a&gt; &lt;p *ngIf=&quot;record.relevantExtracts&quot; [innerHTML]=&quot;record.relevantExtracts&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;sq-pager [results]=&quot;results&quot;&gt;&lt;/sq-pager&gt; &lt;/div&gt; &lt;!-- Facets --&gt; &lt;div class=&quot;col-lg-4&quot; *ngIf=&quot;showFacet&quot;&gt; &lt;sq-facet-card [title]=&quot;'msg#facet.treepath.title'&quot; [icon]=&quot;'fas fa-sitemap'&quot;&gt; &lt;sq-facet-list #facet [results]=&quot;results&quot; [aggregation]=&quot;'Treepath'&quot;&gt;&lt;/sq-facet-list&gt; &lt;/sq-facet-card&gt; &lt;sq-facet-card [title]=&quot;'msg#facet.company.title'&quot; [icon]=&quot;'fas fa-building'&quot;&gt; &lt;sq-facet-list #facet [results]=&quot;results&quot; [aggregation]=&quot;'Company'&quot; [allowExclude]=&quot;false&quot; [allowAnd]=&quot;false&quot;&gt;&lt;/sq-facet-list&gt; &lt;/sq-facet-card&gt; &lt;sq-facet-card [title]=&quot;'msg#savedQueries.savedQueries'&quot; [icon]=&quot;'fas fa-save'&quot;&gt; &lt;sq-facet-saved-queries #facet [maxQueries]=&quot;5&quot;&gt;&lt;/sq-facet-saved-queries&gt; &lt;/sq-facet-card&gt; &lt;/div&gt; &lt;!-- Footer --&gt; &lt;div class=&quot;col-12&quot;&gt; &lt;hr&gt; &lt;span [sq-action-buttons]=&quot;{items: languageActions}&quot;&gt;&lt;/span&gt; &lt;button class=&quot;btn btn-success&quot; (click)=&quot;savedQueriesService.createSavedQueryModal()&quot;&gt; &lt;i class=&quot;fas fa-save&quot;&gt;&lt;/i&gt; &lt;/button&gt; &lt;/div&gt; &lt;/ng-container&gt; &lt;/div&gt; &lt;/div&gt;   ","version":"Next","tagName":"h3"},{"title":"Styles​","type":1,"pageTitle":"Completed application","url":"/dokku/docs/tutorial/completed-app#styles-1","content":" search.component.scss .search { h1 { margin-bottom: 0.25em; } .record { h3 { margin: 0.5em 0 0 0; font-weight: normal; font-size: 1.25em; } .source { color: #006621; font-size: 0.875em; margin: 0.25em 0; } p { color: #676767; margin-top: 0; font-size: 0.875em; } } } sq-facet-card { display: block; margin-bottom: 1em; }   ","version":"Next","tagName":"h3"},{"title":"Autocomplete component​","type":1,"pageTitle":"Completed application","url":"/dokku/docs/tutorial/completed-app#autocomplete-component","content":" ","version":"Next","tagName":"h2"},{"title":"Controller​","type":1,"pageTitle":"Completed application","url":"/dokku/docs/tutorial/completed-app#controller-3","content":" autocomplete.ts import { Component, Input, OnChanges, OnInit } from &quot;@angular/core&quot;; import { ReplaySubject, debounceTime, switchMap, filter, Observable } from &quot;rxjs&quot;; import { AutocompleteItem, SuggestService } from &quot;@sinequa/components/autocomplete&quot;; import { SearchService } from &quot;@sinequa/components/search&quot;; @Component({ selector: &quot;autocomplete&quot;, template: ` &lt;div class=&quot;list-group list-group-flush&quot; *ngIf=&quot;items$ | async; let items&quot;&gt; &lt;a role=&quot;button&quot; *ngFor=&quot;let item of items&quot; class=&quot;list-group-item list-group-item-action&quot; (click)=&quot;search(item.display)&quot;&gt; {{item.display}} &lt;/a&gt; &lt;/div&gt; `, styles: [` .list-group-flush &gt; .list-group-item:last-child { border-end-start-radius: 20px; border-end-end-radius: 20px; } `] }) export class Autocomplete implements OnChanges, OnInit { @Input() queryText: string; inputChange$ = new ReplaySubject(1); items$: Observable&lt;AutocompleteItem[] | undefined&gt;; constructor(private suggestService: SuggestService, private searchService: SearchService) { } ngOnInit() { this.items$ = this.inputChange$ .pipe( filter(text =&gt; !!text), // prevents searching if there is no query text debounceTime(200), // add a slight wait before retrieving the suggestions to avoid making calls at each change switchMap(text =&gt; this.suggestService.get(undefined, text as string)) // retrieve the suggestions ); } ngOnChanges() { this.inputChange$.next(this.queryText); } search(value: string) { this.searchService.query.text = value; this.searchService.searchText(&quot;/search&quot;); } }   ","version":"Next","tagName":"h3"},{"title":"Search form component​","type":1,"pageTitle":"Completed application","url":"/dokku/docs/tutorial/completed-app#search-form-component","content":" ","version":"Next","tagName":"h2"},{"title":"Controller​","type":1,"pageTitle":"Completed application","url":"/dokku/docs/tutorial/completed-app#controller-4","content":" search-form.component.ts import { Component } from '@angular/core'; import { SearchService } from '@sinequa/components/search'; @Component({ selector: 'app-search-form', templateUrl: './search-form.component.html', styleUrls: ['./search-form.component.scss'] }) export class AppSearchFormComponent { constructor(public searchService: SearchService) { } }   ","version":"Next","tagName":"h3"},{"title":"Template​","type":1,"pageTitle":"Completed application","url":"/dokku/docs/tutorial/completed-app#template-3","content":" search-form.component.html &lt;sq-search-form [query]=&quot;searchService.query&quot;&gt; &lt;ng-template let-query&gt; &lt;autocomplete [queryText]=&quot;query.text&quot;&gt;&lt;/autocomplete&gt; &lt;/ng-template&gt; &lt;/sq-search-form&gt;   ","version":"Next","tagName":"h3"},{"title":"Preview​","type":1,"pageTitle":"Completed application","url":"/dokku/docs/tutorial/completed-app#preview","content":" ","version":"Next","tagName":"h2"},{"title":"Controller​","type":1,"pageTitle":"Completed application","url":"/dokku/docs/tutorial/completed-app#controller-5","content":" preview.ts import { Component, Inject } from &quot;@angular/core&quot;; import { Record } from '@sinequa/core/web-services'; import { MODAL_MODEL } from '@sinequa/core/modal'; import { SearchService } from &quot;@sinequa/components/search&quot;; import { PreviewHighlightColors } from &quot;@sinequa/components/preview&quot;; @Component({ selector: &quot;preview&quot;, template: ` &lt;sq-modal [title]=&quot;record.title&quot; [showFooter]=&quot;false&quot;&gt; &lt;sq-preview #facet class=&quot;h-100&quot; [highlightColors]=&quot;highlights&quot; [id]=&quot;record.id&quot; [query]=&quot;searchService.query&quot;&gt; &lt;/sq-preview&gt; &lt;/sq-modal&gt; ` }) export class Preview { highlights: PreviewHighlightColors[] = [ { name: 'company', color: 'white', bgColor: '#FF7675' }, { name: 'geo', color: 'white', bgColor: '#74B9FF' }, { name: 'person', color: 'white', bgColor: '#00ABB5' }, { name: 'extractslocations', color: 'black', bgColor: '#fffacd' }, { name: 'matchlocations', color: 'black', bgColor: '#ff0' } ]; constructor( @Inject(MODAL_MODEL) public record: Record, public searchService: SearchService) { } }   ","version":"Next","tagName":"h3"},{"title":"Global styles​","type":1,"pageTitle":"Completed application","url":"/dokku/docs/tutorial/completed-app#global-styles","content":" ","version":"Next","tagName":"h2"},{"title":"App​","type":1,"pageTitle":"Completed application","url":"/dokku/docs/tutorial/completed-app#app","content":" app.scss @import &quot;~@angular/cdk/overlay-prebuilt&quot;; // Overriding Bootstrap variables $grid-breakpoints: ( xs: 0, sm: 600px, lg: 1000px ); $container-max-widths: ( sm: 800px, lg: 1200px ); // Bootstrap styles @import &quot;~bootstrap/scss/bootstrap&quot;; /*** Fontawesome ***/ $fa-font-path: &quot;~@fortawesome/fontawesome-free/webfonts&quot;; @import &quot;~@fortawesome/fontawesome-free/scss/fontawesome&quot;; @import &quot;~@fortawesome/fontawesome-free/scss/brands&quot;; @import &quot;~@fortawesome/fontawesome-free/scss/regular&quot;; @import &quot;~@fortawesome/fontawesome-free/scss/solid&quot;; @import &quot;../../../components/action/bootstrap/action.scss&quot;; body { font-family: Arial, &quot;Helvetica Neue&quot;, Helvetica, sans-serif; } a { text-decoration: none; color: #3434d6; } .record .match-highlight { font-weight: bold; font-style: italic; }   ","version":"Next","tagName":"h3"},{"title":"Locales​","type":1,"pageTitle":"Completed application","url":"/dokku/docs/tutorial/completed-app#locales","content":" ","version":"Next","tagName":"h2"},{"title":"English​","type":1,"pageTitle":"Completed application","url":"/dokku/docs/tutorial/completed-app#english","content":" en.ts import {LocaleData} from &quot;@sinequa/core/intl&quot;; import {enCore} from &quot;@sinequa/core/messages&quot;; import &quot;intl/locale-data/jsonp/en-US&quot;; // Safari import {Utils} from &quot;@sinequa/core/base&quot;; import {enFacet} from &quot;@sinequa/components/facet&quot;; import {enResult} from &quot;@sinequa/components/result&quot;; import {enSearch} from &quot;@sinequa/components/search&quot;; import {enSearchForm} from &quot;@sinequa/components/search-form&quot;; import {enSavedQueries} from &quot;@sinequa/components/saved-queries&quot;; const d3Format = require('d3-format/locale/en-US'); const d3Time = require('d3-time-format/locale/en-US'); const appMessages = { locale: { en: &quot;English&quot;, fr: &quot;Français&quot; }, app: { login: &quot;Login&quot;, logout: &quot;Logout&quot;, }, search: { button: &quot;Search&quot;, placeholder: &quot;Enter search terms...&quot;, clear: &quot;Clear&quot; }, facet: { loadMore: &quot;Gimme more data, please!&quot; }, results: { resultsAllTab: &quot;All&quot;, tabPeople: &quot;People&quot;, tabBusiness: &quot;Companies&quot;, tabLocation: &quot;Places&quot; }, } export default &lt;LocaleData&gt; { intl: { locale: &quot;en-US&quot; }, d3: { locale: &quot;en-US&quot;, format: d3Format, time: d3Time }, messages: Utils.merge({}, enCore, enFacet, enResult, enSearch, enSearchForm, enSavedQueries, appMessages) };   ","version":"Next","tagName":"h3"},{"title":"French​","type":1,"pageTitle":"Completed application","url":"/dokku/docs/tutorial/completed-app#french","content":" fr.ts import {LocaleData} from &quot;@sinequa/core/intl&quot;; import {frCore} from &quot;@sinequa/core/messages&quot;; import &quot;intl/locale-data/jsonp/fr-FR&quot;; // Safari import {Utils} from &quot;@sinequa/core/base&quot;; import {frFacet} from &quot;@sinequa/components/facet&quot;; import {frResult} from &quot;@sinequa/components/result&quot;; import {frSearch} from &quot;@sinequa/components/search&quot;; import {frSearchForm} from &quot;@sinequa/components/search-form&quot;; import {frSavedQueries} from &quot;@sinequa/components/saved-queries&quot;; const d3Format = require('d3-format/locale/fr-FR'); const d3Time = require('d3-time-format/locale/fr-FR'); const appMessages = { locale: { en: &quot;English&quot;, fr: &quot;Français&quot;, }, app: { login: &quot;Login&quot;, logout: &quot;Logout&quot;, }, search: { button: &quot;Chercher&quot;, placeholder: &quot;Termes de recherche...&quot;, clear: &quot;Effacer&quot; }, results: { resultsAllTab: &quot;Tous&quot;, tabPeople: &quot;Personnes&quot;, tabBusiness: &quot;Entreprises&quot;, tabLocation: &quot;Lieux&quot; }, } export default &lt;LocaleData&gt; { intl: { locale: &quot;fr-FR&quot; }, d3: { locale: &quot;fr-FR&quot;, format: d3Format, time: d3Time }, messages: Utils.merge({}, frCore, frFacet, frResult, frSearch, frSearchForm, frSavedQueries, appMessages) };  ","version":"Next","tagName":"h3"},{"title":"User Settings Features","type":0,"sectionRef":"#","url":"/dokku/docs/tutorial/user-settings","content":"","keywords":"","version":"Next"},{"title":"Importing the Saved Queries Module​","type":1,"pageTitle":"User Settings Features","url":"/dokku/docs/tutorial/user-settings#importing-the-saved-queries-module","content":" In your app.module.ts, import the BsSavedQueriesModule and add it to the NgModule declaration:  app.module.ts import { BsSavedQueriesModule } from '@sinequa/components/saved-queries'; @NgModule({ imports: [ ... BsSavedQueriesModule   ","version":"Next","tagName":"h2"},{"title":"Saved Queries Menu​","type":1,"pageTitle":"User Settings Features","url":"/dokku/docs/tutorial/user-settings#saved-queries-menu","content":" The menu is packaged in a component called sq-saved-queries-menu. We will add it to our app.component.html at the top, in a Bootstrap navbar element:  app.component.html &lt;nav class=&quot;navbar px-0&quot;&gt; &lt;h1 class=&quot;mr-auto&quot;&gt;Hello Search 🔍&lt;/h1&gt; &lt;ul class=&quot;navbar-nav navbar-right&quot;&gt; &lt;sq-saved-queries-menu&gt;&lt;/sq-saved-queries-menu&gt; &lt;/ul&gt; &lt;/nav&gt;     This sort of works, but there are some issues:  We are missing the language files for the Saved QueriesThe dropdown menus do not display correctly  Add the language files to your dictionaries:  en.ts import {enSavedQueries} from &quot;@sinequa/components/saved-queries&quot;; ... messages: Utils.merge({}, ..., enSavedQueries, appMessages)   Import the action.scss stylesheet in your app.scss (⚠️ NOT your component-specific app.component.scss) to fix the styles:  app.scss @import &quot;../../../components/action/bootstrap/action.scss&quot;;   Our menu is now displayed as expected:    ","version":"Next","tagName":"h2"},{"title":"Saved Queries Service​","type":1,"pageTitle":"User Settings Features","url":"/dokku/docs/tutorial/user-settings#saved-queries-service","content":" All the features exposed by the Saved Queries menu are also available programmatically via the SavedQueriesService.  For example, to display a button that saves the current query, you can:  Inject the SavedQueriesService in the constructor of your component: import { SavedQueriesService } from '@sinequa/components/saved-queries'; ... constructor( ... public savedQueriesService: SavedQueriesService ) Add a button to your template: &lt;button class=&quot;btn btn-success&quot; (click)=&quot;savedQueriesService.createSavedQueryModal()&quot;&gt; &lt;i class=&quot;fas fa-save&quot;&gt;&lt;/i&gt; &lt;/button&gt;     ","version":"Next","tagName":"h2"},{"title":"Saved Queries Facet​","type":1,"pageTitle":"User Settings Features","url":"/dokku/docs/tutorial/user-settings#saved-queries-facet","content":" The module also includes a facet that displays your saved queries (as a possible alternative to the menu). Note that we need to set an empty searchRoute parameter since our application has no route.  &lt;sq-facet-card [title]=&quot;'msg#savedQueries.savedQueries'&quot; [icon]=&quot;'fas fa-save'&quot;&gt; &lt;sq-facet-saved-queries #facet [maxQueries]=&quot;5&quot; [searchRoute]=&quot;&quot;&gt;&lt;/sq-facet-saved-queries&gt; &lt;/sq-facet-card&gt;     ","version":"Next","tagName":"h2"},{"title":"Developing your own User-Settings Service​","type":1,"pageTitle":"User Settings Features","url":"/dokku/docs/tutorial/user-settings#developing-your-own-user-settings-service","content":" You can leverage the User-Settings system to develop your own features. Keep in mind the following:  User settings store data per user and per App unencrypted on the Sinequa server.User settings are systematically and fully downloaded from the server on your app initialization (during login). This means the amount of data you can store is necessarily restricted for scalability reasons. If your feature requires more storage, consider using an index on the backend and a custom REST API interact with that index.When you make changes to User Settings on the client-side (eg. Saving a query), the User Settings are synced with the server. Only a subset of the data is sent to the server to improve performance (See the UserSettingsWebService.patch() method).User settings are available post-login, which means not immediately on application startup. If you need data to be available immediately on startup, consider using the browser's localStorage.   User-settings services typically expose a chunk of the User-Settings (here, recent-queries) and a CRUD API to manipulate this data   We recommend you implement your own service by mimicking the content of an existing service (SavedQueriesService, RecentQueriesService, RecentDocumentsService, AlertsService, BasketsService, UserPreferences...).  ","version":"Next","tagName":"h2"},{"title":"User Preferences​","type":1,"pageTitle":"User Settings Features","url":"/dokku/docs/tutorial/user-settings#user-preferences","content":" If you need to store simple key-value data in the User Settings, no need to develop a full-blown service for that. Simply import the UserPreferences in your component, and use the getter and setter of this service, which take care of syncing the data with the server.  import { UserPreferences } from '@sinequa/components/user-settings'; ... constructor( ... public prefs: UserPreferences, ) likesPizza(): boolean { return this.prefs.get(&quot;user-likes-pizza&quot;); } setPizza(pizza: boolean) { this.prefs.set(&quot;user-likes-pizza&quot;, pizza); }  ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}