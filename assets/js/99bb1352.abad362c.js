"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9936],{24700:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var r=t(74848),s=t(28453);const i={layout:"default",title:"Query Intent Detection",parent:"Tips and Tricks",sidebar_position:17},a="Query Intent Detection",o={id:"tipstricks/query-intent",title:"Query Intent Detection",description:"The Sinequa platform can analyze user queries to determine their intent and perform pre-determined actions for pre-determined intents. Query intent detection can be based on a trained Deep Learning model, or based on more simple and deterministic rules (like the presence of an entity in the query).",source:"@site/docs/tipstricks/query-intent.md",sourceDirName:"tipstricks",slug:"/tipstricks/query-intent",permalink:"/sba-angular/docs/tipstricks/query-intent",draft:!1,unlisted:!1,editUrl:"https://github.com/sinequa/sba-angular/tree/main/docs/tipstricks/query-intent.md",tags:[],version:"current",sidebarPosition:17,frontMatter:{layout:"default",title:"Query Intent Detection",parent:"Tips and Tricks",sidebar_position:17},sidebar:"tutorialSidebar",previous:{title:"Application Startup",permalink:"/sba-angular/docs/tipstricks/startup"},next:{title:"Releases",permalink:"/sba-angular/docs/releases/"}},c={},l=[{value:"Query Intent Web Service",id:"query-intent-web-service",level:2},{value:"Integration in the Search process",id:"integration-in-the-search-process",level:2},{value:"Examples",id:"examples",level:2},{value:"Managing Query Intents",id:"managing-query-intents",level:3},{value:"Example 1: Displaying an info-card",id:"example-1-displaying-an-info-card",level:3},{value:"Example 2: Automatic filters",id:"example-2-automatic-filters",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"query-intent-detection",children:"Query Intent Detection"}),"\n",(0,r.jsx)(n.p,{children:"The Sinequa platform can analyze user queries to determine their intent and perform pre-determined actions for pre-determined intents. Query intent detection can be based on a trained Deep Learning model, or based on more simple and deterministic rules (like the presence of an entity in the query)."}),"\n",(0,r.jsx)(n.h2,{id:"query-intent-web-service",children:"Query Intent Web Service"}),"\n",(0,r.jsx)(n.p,{children:'This functionality is exposed as a web service. The service takes in a user query and returns one or several intents, including the entities (or their Machine Learning equivalent, "slots") that have been matched.'}),"\n",(0,r.jsxs)(n.p,{children:["In the Sinequa administration, the Query Intents are configured in the ",(0,r.jsx)(n.em,{children:"Search-Based Applications > App Dependencies > Query Intent Sets"})," section. Once configured there, the Query Intent Set must be attached to the SBA's query web service (Under the ",(0,r.jsx)(n.em,{children:"Search settings"})," tab and ",(0,r.jsx)(n.em,{children:"Query Options - Intents"})," section)."]}),"\n",(0,r.jsxs)(n.p,{children:["Requesting the intent of a query can then be done easily, by using ",(0,r.jsx)(n.code,{children:"QueryIntentWebService"})," from the ",(0,r.jsx)(n.a,{href:"/sba-angular/docs/libraries/core/web-services",children:(0,r.jsx)(n.code,{children:"@sinequa/core/web-services"})})," module:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"this.queryIntentWebService.getQueryIntent(this.query);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In this example, ",(0,r.jsx)(n.code,{children:"this.query"})," is a ",(0,r.jsx)(n.code,{children:"Query"})," object. The method returns an observable of ",(0,r.jsx)(n.code,{children:"QueryIntentMatch[]"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"integration-in-the-search-process",children:"Integration in the Search process"}),"\n",(0,r.jsxs)(n.p,{children:["Query Intent detection is already integrated in the search process orchestrated by the ",(0,r.jsx)(n.code,{children:"SearchService"}),". It is automatically triggered when you configure a Query Intent Set in your query web service on the back-end."]}),"\n",(0,r.jsx)(n.p,{children:"However, there are two possible processes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Asynchronous detection (by default): The Query Intent detection is performed ",(0,r.jsx)(n.strong,{children:"in parallel"})," with Search. This process is well suited when query intent is needed for displaying information in addition to the search results, like for example in an info-card. This process is analogous to how ",(0,r.jsx)(n.strong,{children:"sponsored links"})," work."]}),"\n",(0,r.jsxs)(n.li,{children:["Synchronous detection: The Query Intent detection is performed ",(0,r.jsx)(n.strong,{children:"before"})," Search, which allows to potentially modify or cancel the query, and/or perform other actions before Search is actually executed. This process is analogous to how the ",(0,r.jsx)(n.strong,{children:"Did You Mean"})," functionality works. Note that this process involves an additional round-trip with the Sinequa platform, so it slows down search a little bit."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Query Intent modes",src:t(92459).A+"",width:"1050",height:"633"})}),"\n",(0,r.jsxs)(n.p,{children:["Synchronous detection can be activated by setting the ",(0,r.jsx)(n.code,{children:"queryIntentsSync"})," property of the ",(0,r.jsx)(n.code,{children:"SearchOptions"})," in your ",(0,r.jsx)(n.code,{children:"AppModule"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"@NgModule({\n    imports: [\n        ...,\n        BsSearchModule.forRoot({queryIntentsSync: true})\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"SearchService"})," emits a ",(0,r.jsx)(n.code,{children:"new-query-intents"})," event when results are in. Other components and services can listen to this event and perform custom actions depending on the presence and type of intents."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"this.searchService.events.subscribe(event => {\n    if(event.type === 'new-query-intents') {\n        const events = event.intents.filter(intent => intent.name === \"my-intent\");\n        if(events.length > 0) {\n            ...\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,r.jsx)(n.h3,{id:"managing-query-intents",children:"Managing Query Intents"}),"\n",(0,r.jsxs)(n.p,{children:["A good idea is to centralize the management of Query Intents in one place. We can create a service that listens to the ",(0,r.jsx)(n.code,{children:"SearchService"})," events, and performs custom actions, depending on the type of intent that is detected."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"@Injectable({providedIn: 'root'})\nexport class QueryIntentService  {\n\n    constructor(\n        public searchService: SearchService,\n        public exprBuilder: ExprBuilder\n    ){\n        this.init();\n    }\n\n    init() {\n        this.searchService.events.subscribe(event => {\n            if(event.type === 'new-query-intents') {\n                // Perform custom actions here\n            }\n        });\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["It is important that this service be created from the start of the application life. You can force that by including it in the constructor of your ",(0,r.jsx)(n.code,{children:"AppComponent"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"    constructor(\n        ...,\n        public queryIntentService: QueryIntentService\n    ){}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"example-1-displaying-an-info-card",children:"Example 1: Displaying an info-card"}),"\n",(0,r.jsx)(n.p,{children:"Displaying an info-card is independent from the main search process, so we can work in asynchronous mode."}),"\n",(0,r.jsx)(n.p,{children:'Let\'s say we have configured an intent named "people" on the backend. When we search for "who is John Doe?", this intent matches and we can display an info-card about that person.'}),"\n",(0,r.jsxs)(n.p,{children:["In our ",(0,r.jsx)(n.code,{children:"QueryIntentService"}),' let\'s add a method that looks for the "people" intent and fetches data about that person:']}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'\n    // People Query intent data\n    person?: string;\n    personData = new ReplaySubject<Results|undefined>(1);\n\n    processPeople(event: SearchService.NewQueryIntentsEvent) {\n        // Look for the "people" intent\n        const people = event.intents.filter(intent => intent.name === "people")\n            .map(intent => intent.globalEntities?.[0]?.normalization as string)\n            .filter(f => !!f);\n\n        // If any (and if not already processed)\n        if(people.length > 0 && this.person !== people[0]) {\n            // Create a query for this person\n            const query = this.searchService.makeQuery();\n            query.text = people[0];\n            query.action = "aggregate";\n            query.aggregations = ["geo", "company", "person"];\n            this.searchService.getResults(query)\n                .subscribe(r => {\n                    this.person = people[0];\n                    this.personData.next(r); // Emits the data for the infocard\n                });\n        }\n\n        // If none, we want to stop displaying the infocard, if any\n        else if(people.length === 0) {\n            this.person = undefined;\n            this.personData.next(undefined);\n        }\n    }\n'})}),"\n",(0,r.jsxs)(n.p,{children:["We can call this method from the ",(0,r.jsx)(n.code,{children:"init()"})," method we defined above."]}),"\n",(0,r.jsxs)(n.p,{children:["Then, to display the infocard, we simply create a component that displays the ",(0,r.jsx)(n.code,{children:"personData"}),", if any. This can be as simple as the following:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"@Component({\n    selector: 'sq-query-intent-people',\n    template: `\n<sq-facet-card *ngIf=\"queryIntentsService.personData | async; let results\"\n    [title]=\"queryIntentsService.person\"\n    [icon]=\"'fas fa-user'\">\n\n    <sq-facet-tag-cloud #facet\n        [results]=\"results\"\n        [aggregations]=\"['Company','Geo','Person']\">\n    </sq-facet-tag-cloud>\n\n</sq-facet-card>\n    `\n})\nexport class QueryIntentPeopleComponent {\n\n    constructor(\n        public queryIntentsService: QueryIntentService\n    ){}\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"With the example above we display a tag-cloud with terms related to a person. This infocard can be displayed, for example, on the right side of the user interface. This component has no input, and it manages its own visibility, so it's enought to embed it with something as simple as:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:"<sq-query-intent-people></sq-query-intent-people>\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.img,{alt:"Query intent people",src:t(63655).A+"",width:"746",height:"567"}),"\n",(0,r.jsx)(n.em,{children:'Result of searching "who is Barack Obama?"'})]}),"\n",(0,r.jsx)(n.h3,{id:"example-2-automatic-filters",children:"Example 2: Automatic filters"}),"\n",(0,r.jsxs)(n.p,{children:["Another use-case for Query Intent is to detect the intent of applying a specific filter. For example, if a user searches for ",(0,r.jsx)(n.em,{children:'"earnings report pdf"'}),", we can detect that they really means ",(0,r.jsx)(n.em,{children:'"earnings report"'})," and format = pdf."]}),"\n",(0,r.jsxs)(n.p,{children:['Let\'s say we have configured an intent named "format" that detects a file format in the query. Now, since we want to modify the search query, we need to work in synchronous mode. So, in our ',(0,r.jsx)(n.code,{children:"AppModule"}),", let's start by adding the ",(0,r.jsx)(n.code,{children:"queryIntentSync"})," option, as explained above:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export const searchOptions: SearchOptions = {\n    ...,\n    queryIntentsSync: true\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In our ",(0,r.jsx)(n.code,{children:"QueryIntentService"}),' let\'s add a method that looks for the "format" intent, modifies the query, cancels the current search and performs a new query:']}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'    formats: string[];\n\n    processFormats(event: SearchService.NewQueryIntentsEvent) {\n        // Activate only if user has not already created a docformat filter\n        if(!event.query.findSelect("docformat")) {\n\n            // Look for the "format" intents\n            this.formats = event.intents.filter(intent => intent.name === "format")\n                    .map(intent => intent.globalEntities?.[0]?.value.toLowerCase() as string)\n                    .filter(f => !!f);\n\n            // If any...\n            if(this.formats.length > 0) {\n                // Add a format filter to the query and remove the format from the searched text\n                event.query.addSelect(this.exprBuilder.makeOrExpr("docformat", this.formats), "docformat");\n                for(let format of this.formats){\n                    event.query.text = event.query.text?.replace(new RegExp("\\\\s*\\\\b"+format+"\\\\b\\\\s*", "i"), " ").trim();\n                }\n                // Cancel the current search\n                event.cancelSearch = true;\n                // Create a new search\n                this.searchService.search();\n            }\n        }\n    }\n'})}),"\n",(0,r.jsx)(n.p,{children:"Notice that we cancel the current search and create a new one. This is not stricly mandatory, and it would also work to only modify the query. But the problem with that is that the URL would contain the old query, not the modified query. The URL would reflect the actual search parameters only on the next search, which is not very satisfying."}),"\n",(0,r.jsx)(n.p,{children:'One limit of this type of Query Intent is that the user may have actually meant to search for the term "pdf". Therefore, it is important to give them the possibility of forcing that search and ignoring the Query Intent. To do so, we can develop a component similar to the "Did you mean" component:'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'@Component({\n    selector: \'sq-query-intent-format\',\n    template: `\n<div *ngIf="queryIntentService.formats?.length">\n    Did you mean to filter by formats?\n    <a href="#" (click)="cancel()">cancel</a>\n</div>\n    `\n})\nexport class QueryIntentFormatComponent {\n\n    constructor(\n        public queryIntentService: QueryIntentService\n    ){}\n\n    cancel() {\n        this.queryIntentService.cancelFormats();\n        return false;\n    }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["This component is displayed only when the ",(0,r.jsx)(n.code,{children:"QueryIntentService"})," has detected ",(0,r.jsx)(n.code,{children:"formats"})," and modified the query. We just need to implement the ",(0,r.jsx)(n.code,{children:"cancelFormats()"})," method on the service. This can be done in different ways, but in our case, let's assume we want to disable the format detection once and for all (until the app is reloaded):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'    ignoreFormat = false;\n\n    cancelFormats() {\n        // Remove the docformat selection\n        this.searchService.query.removeSelect("docformat");\n        // Put back the format name in the query text\n        const text = this.searchService.query.text? [this.searchService.query.text] : [];\n        this.searchService.query.text = text.concat(this.formats).join(" ");\n        // Search again\n        this.searchService.search();\n        // Set a flat to turn off format detection\n        this.ignoreFormat = true;\n        this.formats = [];\n    }\n\n    processFormats(event: SearchService.NewQueryIntentsEvent) {\n        // Turn off the format detection in our existing processFormats() method\n        if(!event.query.findSelect("docformat") && !this.ignoreFormat) {\n            ...\n        }\n    }\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.img,{alt:"Query intent formats",src:t(49176).A+"",width:"1057",height:"444"}),"\n",(0,r.jsx)(n.em,{children:'Result of searching "code civil pdf"'})]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},49176:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/queryintents-formats-04940d2ed906a6f49170fbaa53059a36.png"},63655:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/queryintents-people-d081e5cc987360b31478109078f9bb51.png"},92459:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/queryintents-d339049448f2214a854db8a6f178218a.png"},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(96540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);