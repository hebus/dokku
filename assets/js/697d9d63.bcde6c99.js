"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3587],{93669:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>d});var t=o(74848),r=o(28453);const s={layout:"default",title:"Speed and Performance",parent:"Tips and Tricks",sidebar_position:12},i="Speed and Performance",a={id:"tipstricks/speed-performance",title:"Speed and Performance",description:"In Angular, by default, NgModules are eagerly loaded, which means that as soon as the application loads, so do all the NgModules, whether or not they are immediately necessary.",source:"@site/docs/tipstricks/speed-performance.md",sourceDirName:"tipstricks",slug:"/tipstricks/speed-performance",permalink:"/sba-angular/docs/tipstricks/speed-performance",draft:!1,unlisted:!1,editUrl:"https://github.com/sinequa/sba-angular/tree/main/docs/tipstricks/speed-performance.md",tags:[],version:"current",sidebarPosition:12,frontMatter:{layout:"default",title:"Speed and Performance",parent:"Tips and Tricks",sidebar_position:12},sidebar:"tutorialSidebar",previous:{title:"D3 and Angular",permalink:"/sba-angular/docs/tipstricks/d3-angular"},next:{title:"Exporting Standalone Components",permalink:"/sba-angular/docs/tipstricks/export-standalone"}},l={},d=[{value:"Lazy loading feature modules",id:"lazy-loading-feature-modules",level:2},{value:"Module Federation",id:"module-federation",level:2},{value:"Activating Module Federation for Angular Projects",id:"activating-module-federation-for-angular-projects",level:3},{value:"Dynamic federation",id:"dynamic-federation",level:3},{value:"More Details on Module Federation",id:"more-details-on-module-federation",level:3}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"speed-and-performance",children:"Speed and Performance"}),"\n",(0,t.jsx)(n.p,{children:"In Angular, by default, NgModules are eagerly loaded, which means that as soon as the application loads, so do all the NgModules, whether or not they are immediately necessary."}),"\n",(0,t.jsx)(n.p,{children:"Although this is not problematic for small applications, it can lead to performance issues for large applications."}),"\n",(0,t.jsx)(n.p,{children:"Fortunately, Angular provides us with several tools to avoid such cases."}),"\n",(0,t.jsx)(n.h2,{id:"lazy-loading-feature-modules",children:"Lazy loading feature modules"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://angular.io/guide/lazy-loading-ngmodules",children:"Lazy load"})," is a design pattern that loads NgModules on-demand. Thus, it helps keep initial bundle sizes smaller, which in turn helps decrease load times."]}),"\n",(0,t.jsx)(n.p,{children:"To help users, easily, lazy load specific modules of an SBA application, all libraries have been updated to support this pattern."}),"\n",(0,t.jsx)(n.p,{children:"For example, if you want to lazy load the preview component, you should start creating an angular module with all its dependencies:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"@NgModule({\n\xa0\xa0declarations:\xa0[PreviewComponent],\n\xa0\xa0imports:\xa0[\n\xa0\xa0\xa0\xa0CommonModule,\n    ... // other modules dependencies\n\xa0\xa0\xa0\xa0PreviewRoutingModule\n\xa0\xa0],\n\xa0\xa0exports:\xa0[PreviewComponent]\n})\nexport\xa0class\xa0PreviewModule\xa0{\xa0}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Then, in the ",(0,t.jsx)(n.em,{children:"PreviewModule's routing module"}),", add a route for this component:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const\xa0routes:\xa0Routes\xa0=\xa0[\n\xa0\xa0{\xa0path:\xa0'',\xa0component:\xa0PreviewComponent\xa0},\n];\n@NgModule({\n\xa0\xa0imports:\xa0[RouterModule.forChild(routes)],\n\xa0\xa0exports:\xa0[RouterModule]\n})\nexport\xa0class\xa0PreviewRoutingModule\xa0{\xa0}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The final step is to use ",(0,t.jsx)(n.em,{children:"loadChildren"})," (instead of ",(0,t.jsx)(n.em,{children:"component"}),") in your ",(0,t.jsx)(n.em,{children:"AppRoutingModule"})," routes configuration as follows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const routes: Routes = [\n  ... // other routes\n  {\n    path: 'preview',\n    loadChildren: () => import('./preview/preview.module').then(m => m.PreviewModule)\n  }\n];\n"})}),"\n",(0,t.jsxs)(n.p,{children:["With this in place, you should notice the ",(0,t.jsx)(n.em,{children:"Lazy chunk files"}),", while compiling your application. Those are simply referring to our lazy loaded module"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Lazy loading preview",src:o(45791).A+"",width:"585",height:"418"})}),"\n",(0,t.jsx)(n.h2,{id:"module-federation",children:"Module Federation"}),"\n",(0,t.jsx)(n.p,{children:"Historically, build tools (Webpack,\u2026) assume that the entire program code is available when compiling.\nLazy loading is possible, but only from areas that were split off during compilation."}),"\n",(0,t.jsxs)(n.p,{children:["This was the main motivation behind the creation of ",(0,t.jsx)(n.em,{children:"Module Federation"})," as a new feature of ",(0,t.jsx)(n.em,{children:"Webpack 5"}),". Hence, it allows loading separately compiled and deployed code (also called micro front-ends or plugins) into an application."]}),"\n",(0,t.jsxs)(n.p,{children:["To simplify the concept, a so-called ",(0,t.jsx)(n.em,{children:"host"})," ",(0,t.jsx)(n.strong,{children:"references"})," a ",(0,t.jsx)(n.em,{children:"remote"})," using a configured name. This ",(0,t.jsx)(n.em,{children:"reference"})," is ",(0,t.jsx)(n.strong,{children:"only resolved at runtime"})," by loading a so-called remote entry point."]}),"\n",(0,t.jsxs)(n.p,{children:["\u26a0\ufe0f ",(0,t.jsx)(n.strong,{children:"NOTE:"})," This concept is environment-independent (Angular, React, Vue, ASP.NET, etc.) \u26a0\ufe0f"]}),"\n",(0,t.jsx)(n.h3,{id:"activating-module-federation-for-angular-projects",children:"Activating Module Federation for Angular Projects"}),"\n",(0,t.jsxs)(n.p,{children:["To do so, you need to tell the CLI to use ",(0,t.jsx)(n.em,{children:"Module Federation"})," when building. However, as the CLI shields webpack from us, you need a custom builder."]}),"\n",(0,t.jsxs)(n.p,{children:["Fortunately, the package ",(0,t.jsx)(n.code,{children:"@angular-architects/module-federation"})," provides such a custom builder."]}),"\n",(0,t.jsxs)(n.p,{children:["For the following example, let's assume the following naming : the ",(0,t.jsx)(n.em,{children:"host application"})," as ",(0,t.jsx)(n.strong,{children:"shell"})," and the ",(0,t.jsx)(n.em,{children:"remote application"})," as ",(0,t.jsx)(n.strong,{children:"mfe"})," (stands for Micro front-end)."]}),"\n",(0,t.jsx)(n.p,{children:'To get started, you can just "ng add" the package to your projects:'}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"ng add @angular-architects/module-federation --project shell --port 5000"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"ng add @angular-architects/module-federation --project mfe --port 3000"})}),"\n",(0,t.jsxs)(n.p,{children:["These commands activate module federation, assign a port for ng serve, and generate the skeleton of a module federation configuration (",(0,t.jsx)(n.code,{children:"webpack.config.js"}),")."]}),"\n",(0,t.jsxs)(n.p,{children:["\u26a0\ufe0f ",(0,t.jsx)(n.strong,{children:"NOTE:"})," The webpack.config.js is only a partial webpack configuration. It only contains stuff to control module federation. The rest is generated by the CLI as usual \u26a0\ufe0f"]}),"\n",(0,t.jsxs)(n.p,{children:["Now let's jump onto the project ",(0,t.jsx)(n.em,{children:"mfe"})," and edit the generated configuration in ",(0,t.jsx)(n.code,{children:".../projects/mfe/webpack.config.js"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'const ModuleFederationPlugin = require("webpack/lib/container/ModuleFederationPlugin");\n[...]\nmodule.exports = {\n    [...],\n    plugins: [\n        new ModuleFederationPlugin({\n\n            name: "mfe",\n            filename: "remoteEntry.js",\n            exposes: {\n                // The update\n                \'./Module\': \'./projects/mfe/src/app/toto/toto.module.ts\',\n            },\n            shared: {\n                "@angular/core": { singleton: true, strictVersion: true },\n                "@angular/common": { singleton: true, strictVersion: true },\n                "@angular/router": { singleton: true, strictVersion: true },\n                [...]\n            }\n        }),\n        [...]\n    ],\n};\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This exposes the ",(0,t.jsx)(n.strong,{children:"TotoModule"})," under the name ",(0,t.jsx)(n.strong,{children:"./Module"}),". Hence, the shell can use this path to load it."]}),"\n",(0,t.jsx)(n.p,{children:"To do so, you need to adjust the shell's generated configuration as follows :"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'const ModuleFederationPlugin = require("webpack/lib/container/ModuleFederationPlugin");\n[...]\nmodule.exports = {\n    [...],\n    plugins: [\n        new ModuleFederationPlugin({\n\n            // Make sure to use port 3000 defined on the first step while adding the package to the projects\n            remotes: {\n                \'mfe\': "mfe@http://localhost:3000/remoteEntry.js"\n            },\n            shared: {\n                "@angular/core": { singleton: true, strictVersion: true },\n                "@angular/common": { singleton: true, strictVersion: true },\n                "@angular/router": { singleton: true, strictVersion: true },\n                [...]\n            }\n        }),\n        [...]\n    ],\n};\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This references the separately compiled and deployed ",(0,t.jsx)(n.em,{children:"mfe"})," project."]}),"\n",(0,t.jsxs)(n.p,{children:["Now, all remains is to update the ",(0,t.jsx)(n.em,{children:"routing module"})," of the shell"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const routes: Routes = [\n  ... // other routes\n  {\n    path: 'toto',\n    loadChildren: () => import('mfe/Module').then(m => m.TotoModule)\n  }\n];\n"})}),"\n",(0,t.jsxs)(n.p,{children:["However, the path ",(0,t.jsx)(n.code,{children:"mfe/Module"})," which is imported here, ",(0,t.jsx)(n.strong,{children:"does not exist"})," within the shell. It is just a virtual path pointing to another project."]}),"\n",(0,t.jsxs)(n.p,{children:["To ease the TypeScript compiler, you need a typing for it by adding the following line to the file ",(0,t.jsx)(n.code,{children:".../projects/shell/src/decl.d.ts"})," :"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"declare module 'mfe/Module';\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Once starting both applications side by side (",(0,t.jsx)(n.code,{children:"ng serve shell"})," and ",(0,t.jsx)(n.code,{children:"ng serve mfe"}),"), you should notice, ",(0,t.jsx)(n.strong,{children:"at runtime"}),", that shell loads the mfe from its own URL"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Loading remotes",src:o(59069).A+"",width:"993",height:"520"})}),"\n",(0,t.jsx)(n.h3,{id:"dynamic-federation",children:"Dynamic federation"}),"\n",(0,t.jsx)(n.p,{children:"In the previous section, we assumed that micro front-ends, used in the shell, are already known by the developer."}),"\n",(0,t.jsx)(n.p,{children:"However, there might be situations where you don\u2019t even know the list of micro front-ends upfront. For example, an application with different dynamic views based on user privileges. This information can be hold by an external system and fetched at runtime via HTTP request."}),"\n",(0,t.jsx)(n.p,{children:"To dynamically load a micro-frontend at runtime, you need to remove the registration of the micro front-end upfront within shell configuration :"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'remotes: {\n    // "mfe": "mfe@http://localhost:3000/remoteEntry.js",\n},\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Instead, you should use the helper function ",(0,t.jsx)(n.em,{children:"loadRemoteModule"})," provided by the ",(0,t.jsx)(n.code,{children:"@angular-architects/module-federation"})," :"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const routes: Routes = [\n  ... // other routes\n  {\n    path: 'toto',\n    loadChildren: () =>\n            loadRemoteModule({\n                remoteEntry: 'http://localhost:3000/remoteEntry.js',\n                remoteName: 'mfe',\n                exposedModule: './Module'\n            })\n            .then(m => m.TotoModule)\n  }\n];\n"})}),"\n",(0,t.jsxs)(n.p,{children:["To showcase the use of external systems, remotes information can be provided ",(0,t.jsx)(n.strong,{children:"at runtime"})," via a lookup service :"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"@Injectable({ providedIn: 'root' })\nexport class LookupService {\n    lookup(): Promise<Microfrontend[]> {\n        [...]\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Then, after receiving the ",(0,t.jsx)(n.em,{children:"Microfrontend"})," array from the ",(0,t.jsx)(n.em,{children:"LookupService"}),", you can build your dynamic routes as follows :"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"export function buildRoutes(options: Microfrontend[]): Routes {\n\n    const lazyRoutes: Routes = options.map(o => ({\n        path: o.routePath,\n        loadChildren: () => loadRemoteModule(o).then(m => m[o.moduleNameProperty])\n    }));\n\n    return [...APP_ROUTES, ...lazyRoutes];\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"more-details-on-module-federation",children:"More Details on Module Federation"}),"\n",(0,t.jsxs)(n.p,{children:["Please have a look at ",(0,t.jsx)(n.a,{href:"https://webpack.js.org/concepts/module-federation/",children:"Webpack federation feature"})," and ",(0,t.jsx)(n.a,{href:"https://www.npmjs.com/package/@angular-architects/module-federation",children:"Angular module federation package"})]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},45791:(e,n,o)=>{o.d(n,{A:()=>t});const t=o.p+"assets/images/lazy-loading-56d768a9276058d48aa1e860430d4cb4.PNG"},59069:(e,n,o)=>{o.d(n,{A:()=>t});const t=o.p+"assets/images/loading-remote-989ec143b9ed797a1c00e78e4e66355f.PNG"},28453:(e,n,o)=>{o.d(n,{R:()=>i,x:()=>a});var t=o(96540);const r={},s=t.createContext(r);function i(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);